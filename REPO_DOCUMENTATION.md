# Arda Onboarding Repository - Complete Documentation

> **Purpose**: This document contains the **complete, verbatim contents** of every source file in the
> `Arda-cards/onboarding` repository. It is intended to enable an **identical recreation** of the repo
> as part of another codebase. Every file, every configuration, every line of code is included below.
>
> **Package name**: `luminescent-coronal` (frontend) / `orderpulse-server` (backend)
> **Branding**: OrderPulse / Arda Order Intelligence

---

## Table of Contents

1. [Repository Overview](#repository-overview)
2. [Directory Tree](#directory-tree)
3. [File Contents](#file-contents)

---

## Repository Overview

### Tech Stack

| Layer | Technology | Version |
|-------|-----------|---------|
| Frontend Framework | React | 19.2.0 |
| Language | TypeScript | ~5.9.3 |
| Build Tool | Vite | 5.4.21 |
| CSS Framework | Tailwind CSS | 3.4.19 |
| Data Grid | AG Grid Enterprise | 35.1.0 |
| Charts | Recharts | 3.7.0 |
| Icons | Lucide React | 0.563.0 |
| AI (Frontend) | @google/genai | 1.0.0 |
| Validation (Frontend) | Zod | 4.3.6 |
| Barcode | @zxing/browser + @zxing/library | 0.1.5 / 0.21.3 |
| Backend | Express | 4.21.0 |
| AI (Server) | @google/generative-ai | 0.21.0 |
| Database | PostgreSQL (pg) | 8.12.0 |
| Cache | Redis (ioredis) | 5.4.1 |
| Scraping | Playwright | 1.58.2 |
| Validation (Server) | Zod | 3.23.8 |
| Cloud Storage | Cloudinary | 2.9.0 |
| Monitoring | Sentry | 10.38.0 |
| Auth | Google OAuth, AWS Cognito, bcryptjs |  |
| Deployment (Frontend) | Vercel |  |
| Deployment (Backend) | Railway (Nixpacks) |  |
| CI/CD | GitHub Actions |  |
| Node.js | 20.20.0 (strict engine enforcement) |  |

### Architecture

- **Frontend**: React SPA with 8-step onboarding wizard (Welcome → Email → Integrations → URLs → Barcodes → Photos → CSV → Master List)
- **Backend**: Express API with PostgreSQL, Redis sessions, background job processing
- **Integrations**: Google OAuth/Gmail, Gemini AI, Amazon PA-API, QuickBooks, Xero, Cloudinary, Sentry, AWS Cognito, Postmark
- **Business Logic**: ReLoWiSa Kanban calculations (lean manufacturing inventory), velocity profiling, supplier discovery

---

## Directory Tree

```
./.codex/environments/environment.toml
./.env.example
./.githooks/pre-commit
./.githooks/pre-push
./.github/workflows/railway-deploy.yml
./.gitignore
./.node-version
./.npmrc
./.nvmrc
./README.md
./eslint.config.js
./index.html
./package.json
./postcss.config.cjs
./public/vite.svg
./scripts/install-git-hooks.sh
./scripts/worktree-backup-and-clean.sh
./scripts/worktree-check-clean.sh
./server/.env.example
./server/data/cognito_users.csv
./server/docs/cognito-provisioning.md
./server/package.json
./server/railway.json
./server/src/config.ts
./server/src/db/index.ts
./server/src/db/migrate.ts
./server/src/db/schema.sql
./server/src/index.ts
./server/src/middleware/errorHandler.ts
./server/src/middleware/rateLimiter.ts
./server/src/middleware/requestLogger.ts
./server/src/middleware/securityHeaders.ts
./server/src/routes/amazon.ts
./server/src/routes/analysis.ts
./server/src/routes/arda.test.ts
./server/src/routes/arda.ts
./server/src/routes/auth.ts
./server/src/routes/cognito.ts
./server/src/routes/discover.ts
./server/src/routes/gmail.ts
./server/src/routes/inboundEmail.test.ts
./server/src/routes/inboundEmail.ts
./server/src/routes/integrations.test.ts
./server/src/routes/integrations.ts
./server/src/routes/jobs.ts
./server/src/routes/jobsProcessingUtils.test.ts
./server/src/routes/jobsProcessingUtils.ts
./server/src/routes/jobsQueryUtils.test.ts
./server/src/routes/jobsQueryUtils.ts
./server/src/routes/orders.ts
./server/src/routes/photo.ts
./server/src/routes/scan.ts
./server/src/routes/urlIngestion.test.ts
./server/src/routes/urlIngestion.ts
./server/src/scripts/ensureCognitoUser.ts
./server/src/services/amazon.ts
./server/src/services/arda.test.ts
./server/src/services/arda.ts
./server/src/services/ardaSyncStatus.ts
./server/src/services/barcodeLookup.ts
./server/src/services/cognito.ts
./server/src/services/cognitoScheduler.ts
./server/src/services/emailExtraction.ts
./server/src/services/imageUpload.ts
./server/src/services/inboundReceiptWorker.test.ts
./server/src/services/inboundReceiptWorker.ts
./server/src/services/integrations/errors.ts
./server/src/services/integrations/providers/adapters.test.ts
./server/src/services/integrations/providers/quickbooksAdapter.ts
./server/src/services/integrations/providers/xeroAdapter.ts
./server/src/services/integrations/quickbooksOAuth.ts
./server/src/services/integrations/store.ts
./server/src/services/integrations/syncOrchestrator.test.ts
./server/src/services/integrations/syncOrchestrator.ts
./server/src/services/integrations/syncScheduler.test.ts
./server/src/services/integrations/syncScheduler.ts
./server/src/services/integrations/types.ts
./server/src/services/integrations/xeroOAuth.ts
./server/src/services/jobManager.test.ts
./server/src/services/jobManager.ts
./server/src/services/urlScraper.test.ts
./server/src/services/urlScraper.ts
./server/src/services/userStore.ts
./server/src/types/amazon-paapi.d.ts
./server/src/utils/encryption.ts
./server/src/utils/loadEnv.ts
./server/src/utils/orderConsolidation.ts
./server/src/utils/redisClient.ts
./server/src/utils/urlExtraction.ts
./server/tsconfig.json
./server/vitest.config.ts
./src/App.css
./src/App.tsx
./src/__tests__/appAuth.test.tsx
./src/assets/react.svg
./src/components/AlertCard.tsx
./src/components/ErrorBoundary.tsx
./src/components/Icons.tsx
./src/components/InstructionCard.tsx
./src/components/ItemDetailPanel.tsx
./src/components/ItemsTable/ItemsGrid.tsx
./src/components/ItemsTable/ardaGridTheme.css
./src/components/ItemsTable/cellRenderers/ActionsCellRenderer.tsx
./src/components/ItemsTable/cellRenderers/ColorCellEditor.tsx
./src/components/ItemsTable/cellRenderers/ColorCellRenderer.tsx
./src/components/ItemsTable/cellRenderers/ImageCellRenderer.tsx
./src/components/ItemsTable/cellRenderers/SourceBadgeRenderer.tsx
./src/components/ItemsTable/cellRenderers/SyncStatusRenderer.tsx
./src/components/ItemsTable/cellRenderers/UrlCellRenderer.tsx
./src/components/ItemsTable/gridSetup.ts
./src/components/ItemsTable/index.ts
./src/components/ItemsTable/types.ts
./src/components/LoadingSkeleton.tsx
./src/components/OrderTimeline.tsx
./src/components/OrderTree.tsx
./src/components/ReorderAlerts.tsx
./src/components/ReorderSparkline.tsx
./src/components/Sidebar.tsx
./src/components/SupplierConfig.tsx
./src/components/TreeNode.tsx
./src/components/VelocityBadge.tsx
./src/components/__tests__/ReorderSparkline.test.tsx
./src/components/__tests__/TreeNode.test.tsx
./src/components/__tests__/VelocityBadge.test.tsx
./src/constants.ts
./src/hooks/useAutoIngestion.ts
./src/hooks/useSyncToArda.ts
./src/index.css
./src/main.tsx
./src/services/__tests__/apiAuth.test.ts
./src/services/__tests__/apiBaseUrl.test.ts
./src/services/__tests__/ardaOpenUrl.test.ts
./src/services/api.ts
./src/services/geminiService.ts
./src/services/gmailService.ts
./src/services/mockData.ts
./src/setupTests.ts
./src/types.ts
./src/utils/__tests__/supplierUtils.test.ts
./src/utils/exportUtils.ts
./src/utils/inventoryLogic.ts
./src/utils/masterListItems.ts
./src/utils/supplierUtils.ts
./src/views/BarcodeScanStep.tsx
./src/views/CSVReconcileStep.tsx
./src/views/CSVUploadStep.tsx
./src/views/CadenceView.tsx
./src/views/ComposeEmail.tsx
./src/views/Dashboard.tsx
./src/views/IntegrationsStep.tsx
./src/views/InventoryView.tsx
./src/views/JourneyView.tsx
./src/views/LoginScreen.tsx
./src/views/MasterListStep.tsx
./src/views/MobileScanner.tsx
./src/views/OnboardingFlow.tsx
./src/views/OnboardingWelcomeStep.tsx
./src/views/PhotoCaptureStep.tsx
./src/views/SupplierSetup.tsx
./src/views/UrlScrapeStep.tsx
./src/views/__tests__/IntegrationsStep.test.tsx
./src/views/__tests__/InventoryView.test.tsx
./src/views/__tests__/MasterListStep.test.tsx
./src/views/__tests__/OnboardingFlow.test.tsx
./src/views/__tests__/SupplierSetup.test.tsx
./src/views/__tests__/UrlScrapeStep.test.tsx
./src/views/__tests__/supplierSetupUtils.test.ts
./src/views/supplierSetupUtils.ts
./tailwind.config.js
./tsconfig.app.json
./tsconfig.json
./tsconfig.node.json
./vercel.json
./vite.config.ts
./vitest.config.ts
```

---

## File Contents

> Every file below is reproduced **verbatim**. The file path is given as a heading,
> followed by the complete file contents in a fenced code block.
> Files containing triple-backtick characters use a higher-level fence (``````) to avoid conflicts.


### `.codex/environments/environment.toml`

```toml
# THIS IS AUTOGENERATED. DO NOT EDIT MANUALLY
version = 1
name = "order-pulse"

[setup]
script = ""

```

### `.env.example`

```
# OrderPulse Environment Variables
# Copy this file to .env and fill in your values

# =============================================================================
# REQUIRED FOR PRODUCTION
# =============================================================================

# Session secret - must be stable and secure in production
SESSION_SECRET=your-secure-session-secret-min-32-chars

# Google OAuth credentials for Gmail access
GOOGLE_CLIENT_ID=your-google-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Gemini API key for AI-assisted order inference
GEMINI_API_KEY=your-gemini-api-key

# Arda API credentials
ARDA_TENANT_ID=your-arda-tenant-id
ARDA_API_KEY=your-arda-api-key
ARDA_BASE_URL=https://prod.alpha001.io.arda.cards

# PostgreSQL connection string
DATABASE_URL=postgresql://user:password@localhost:5432/orderpulse

# Redis URL for session storage and job persistence
REDIS_URL=redis://localhost:6379

# Frontend and Backend URLs (for CORS and OAuth callbacks)
FRONTEND_URL=http://localhost:5173
BACKEND_URL=http://localhost:3001

# =============================================================================
# OPTIONAL
# =============================================================================

# Node environment
NODE_ENV=development

# Server port (defaults to 3001)
PORT=3001

# Sentry error monitoring
SENTRY_DSN=
SENTRY_TRACES_SAMPLE_RATE=0.1

# Rate limiting configuration
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX=120

# Cognito sync configuration
ENABLE_COGNITO_SYNC=false
COGNITO_SYNC_HOUR=2
GITHUB_COGNITO_TOKEN=

# Amazon Product API (for enriching Amazon orders)
AMAZON_ACCESS_KEY=
AMAZON_SECRET_KEY=
AMAZON_PARTNER_TAG=

# Accounting connector sync configuration
ENABLE_ACCOUNTING_CONNECTORS=false
ACCOUNTING_SYNC_INTERVAL_MINUTES=15
QUICKBOOKS_CLIENT_ID=
QUICKBOOKS_CLIENT_SECRET=
QUICKBOOKS_WEBHOOK_VERIFIER_TOKEN=
XERO_CLIENT_ID=
XERO_CLIENT_SECRET=

# Postmark inbound webhook auth + processing controls
POSTMARK_INBOUND_USERNAME=
POSTMARK_INBOUND_PASSWORD=
INBOUND_CONFIDENCE_THRESHOLD=0.78
INBOUND_PROCESS_BATCH_SIZE=10
INBOUND_MAX_RETRIES=5
INBOUND_RETENTION_DAYS=30

# Barcode product lookup (optional)
# If set, OrderPulse will use BarcodeLookup's product database for UPC/EAN/GTIN scans.
BARCODE_LOOKUP_API_KEY=
# Recommended by Open Food Facts (helps avoid rate limiting)
BARCODE_LOOKUP_USER_AGENT=OrderPulse/1.0 (barcode lookup)
#
# UPCitemdb paid plans (optional). If unset, OrderPulse uses the free /prod/trial endpoint.
UPCITEMDB_USER_KEY=
UPCITEMDB_KEY_TYPE=3scale

# =============================================================================
# FRONTEND (VITE)
# =============================================================================

# API base URL for frontend
VITE_API_URL=http://localhost:3001

```

### `.githooks/pre-commit`

```
#!/usr/bin/env bash
set -euo pipefail

branch="$(git branch --show-current)"
if [[ "$branch" == "main" && "${ALLOW_MAIN_COMMIT:-0}" != "1" ]]; then
  echo "Direct commits to main are blocked by default." >&2
  echo "Create a feature branch (recommended) or set ALLOW_MAIN_COMMIT=1 for an emergency commit." >&2
  exit 1
fi

```

### `.githooks/pre-push`

```
#!/usr/bin/env bash
set -euo pipefail

bash ./scripts/worktree-check-clean.sh >/dev/null

```

### `.github/workflows/railway-deploy.yml`

```yaml
name: Deploy API to Railway

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

env:
  NODE_VERSION: 20
  RAILWAY_PROJECT_ID: f7c96f7b-ed85-4ae9-9428-de3888942936
  RAILWAY_ENVIRONMENT: production
  RAILWAY_SERVICE: order-pulse-api

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install root deps
        run: npm ci

      - name: Lint frontend
        run: npm run lint

      - name: Test frontend (no coverage)
        run: npm test -- --coverage=false

      - name: Build frontend
        run: npm run build

      - name: Install server deps
        working-directory: server
        run: npm ci

      - name: Build server
        working-directory: server
        run: npm run build

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Railway CLI
        run: curl -fsSL https://railway.app/install.sh | sh

      - name: Deploy to Railway
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          NODE_VERSION: ${{ env.NODE_VERSION }}
          RAILWAY_PROJECT_ID: ${{ env.RAILWAY_PROJECT_ID }}
          RAILWAY_ENVIRONMENT: ${{ env.RAILWAY_ENVIRONMENT }}
          RAILWAY_SERVICE: ${{ env.RAILWAY_SERVICE }}
        working-directory: server
        run: |
          set -euo pipefail
          export PATH="$HOME/.railway/bin:$PATH"
          if [ -z "${RAILWAY_TOKEN:-}" ]; then
            echo "::error title=Missing RAILWAY_TOKEN secret::Add a valid Railway token to repo secrets as RAILWAY_TOKEN."
            exit 1
          fi

          railway --version

          LOG_FILE="$(mktemp)"
          if ! railway up --ci --project "$RAILWAY_PROJECT_ID" --environment "$RAILWAY_ENVIRONMENT" --service "$RAILWAY_SERVICE" 2>&1 | tee "$LOG_FILE"; then
            SUMMARY="$(tail -n 80 "$LOG_FILE" | tr '\n' ' ' | sed -e 's/%/%25/g' -e 's/\r/%0D/g')"
            echo "::error title=Railway deploy failed::$SUMMARY"
            exit 1
          fi

```

### `.gitignore`

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.env
server/.env
.vercel

```

### `.node-version`

```
20.20.0

```

### `.npmrc`

```
engine-strict=true

```

### `.nvmrc`

```
20

```

### `README.md`

````markdown
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

## Production deployment checklist

### Backend secrets & services
| Name | Description |
| --- | --- |
| `SESSION_SECRET` | Used to sign the Express session cookie. **Must** be stable in production; the server refuses to start when it is missing. |
| `GOOGLE_CLIENT_ID` / `GOOGLE_CLIENT_SECRET` | OAuth credentials for Gmail access. |
| `GEMINI_API_KEY` | API key used for AI-assisted order inference. |
| `ARDA_TENANT_ID` | Tenant ID for Arda API calls. |
| `DATABASE_URL` | Postgres connection string (`DATABASE_URL`) with TLS enabled in production. |
| `REDIS_URL` | Used for session storage, job persistence, and the distributed Cognito sync scheduler. Required in production. |
| `POSTMARK_INBOUND_USERNAME` / `POSTMARK_INBOUND_PASSWORD` | HTTP Basic Auth credentials for `/api/inbound/postmark` webhook requests. |
| `INBOUND_CONFIDENCE_THRESHOLD` | Confidence guardrail for auto-syncing forwarded receipts (default `0.78`). |
| `INBOUND_PROCESS_BATCH_SIZE` | Max inbound receipts claimed per worker tick (default `10`). |
| `INBOUND_MAX_RETRIES` | Max transient retry attempts for inbound processing (default `5`). |
| `INBOUND_RETENTION_DAYS` | Days to keep raw inbound email headers/bodies before purge (default `30`). |
| `ENABLE_ACCOUNTING_CONNECTORS` | Feature flag for QuickBooks/Xero integrations (`true` to enable API routes/UI controls). |
| `ACCOUNTING_SYNC_INTERVAL_MINUTES` | Scheduled incremental sync interval in minutes (default `15`). |
| `QUICKBOOKS_CLIENT_ID` / `QUICKBOOKS_CLIENT_SECRET` | OAuth credentials for QuickBooks Online. |
| `QUICKBOOKS_WEBHOOK_VERIFIER_TOKEN` | HMAC verifier used for `POST /api/integrations/webhooks/quickbooks` signature checks. |
| `XERO_CLIENT_ID` / `XERO_CLIENT_SECRET` | OAuth credentials for Xero. |
| `FRONTEND_URL` / `BACKEND_URL` | CORS origin and OAuth callback URL (set both on Vercel / Railway). |
| `SENTRY_DSN` (optional) | When provided, captured errors are sent to Sentry via `@sentry/node`. |
| `ENABLE_COGNITO_SYNC` | Set to `true` to enable the scheduled GitHub → Cognito sync. |
| `COGNITO_SYNC_HOUR` | Optional hour (UTC) at which the scheduled sync should run (default `2`). |

### Frontend environment
- `VITE_API_URL`: optional API base URL override. Leave unset in production so the app uses same-origin `/auth` and `/api` rewrites.

### Build & release
1. `npm run build` (frontend) – this runs `tsc -b` and `vite build`. Manual chunking is configured via `vite.config.ts` to keep the bundle sizes small.
2. `npm run build` (server) – compiles the Node API via `tsc` (the `start` script runs the emitted `dist/index.js`).

### Hosting notes (Vercel / Railway)
- Set `FRONTEND_URL` to the deployed Vercel domain so OAuth redirects and CORS match.
- Set `BACKEND_URL` for OAuth callbacks in `server/src/routes/auth.ts` and `server/src/routes/integrations.ts`.
- Store the Redis URL and Postgres `DATABASE_URL` in the platform secrets; both are required before deploying.
- If accounting connectors are enabled, configure QuickBooks webhook delivery to `POST /api/integrations/webhooks/quickbooks`.
- Ensure `ENABLE_COGNITO_SYNC` is `true` on the instance that should perform the nightly sync and that Redis is reachable so the distributed lock works.
- Keep Vercel rewrites for `/auth/*` and `/api/*` enabled so browser requests stay first-party.
- Runbook: if users hit onboarding errors like `Not authenticated`, first verify `VITE_API_URL` was not set to the Railway URL in Vercel.

### Monitoring & observability
- When `SENTRY_DSN` is set, Sentry picks up HTTP errors and uncaught exceptions automatically. The API logs the Cognito sync status on startup and reports Redis issues to the server logs.

## Worktree guardrails

Use these commands to avoid accidental dirty-state drift:

1. `npm run worktree:status`
2. `npm run worktree:check-clean`
3. `npm run worktree:backup-clean`
4. `npm run hooks:install`

Notes:
- `worktree:check-clean` fails if tracked or untracked files are present.
- `worktree:backup-clean` creates a local backup branch (`codex/wip-backup-<timestamp>`), commits all current changes, then resets and cleans the current branch.
- `hooks:install` configures `core.hooksPath=.githooks`.
- The repo hooks block direct commits to `main` by default and block push when the worktree is dirty.
- For emergency commits on `main`, set `ALLOW_MAIN_COMMIT=1` for that command only.

````

### `eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist', 'coverage', 'server/dist']),
  {
    files: ['src/**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
  {
    files: ['server/src/**/*.ts'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
    ],
    languageOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      globals: globals.node,
    },
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unsafe-function-type': 'off',
      '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_', varsIgnorePattern: '^_' }],
    },
  },
])

```

### `index.html`

```html
<!doctype html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OrderPulse - AI Supply Chain Intelligence</title>
    <meta
      name="description"
      content="AI-powered supply chain management. Analyze orders, invoices, and receipts from your inbox."
    />
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

```

### `package.json`

```json
{
  "name": "luminescent-coronal",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "packageManager": "npm@10.8.2",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "test": "vitest run",
    "lint": "eslint .",
    "preview": "vite preview",
    "worktree:status": "git status --short --branch",
    "worktree:check-clean": "bash ./scripts/worktree-check-clean.sh",
    "worktree:backup-clean": "bash ./scripts/worktree-backup-and-clean.sh",
    "hooks:install": "bash ./scripts/install-git-hooks.sh"
  },
  "engines": {
    "node": ">=20 <21"
  },
  "dependencies": {
    "@google/genai": "^1.0.0",
    "@zxing/browser": "^0.1.5",
    "@zxing/library": "^0.21.3",
    "ag-grid-community": "^35.1.0",
    "ag-grid-enterprise": "^35.1.0",
    "ag-grid-react": "^35.1.0",
    "compression": "^1.8.1",
    "express-rate-limit": "^8.2.1",
    "lucide-react": "^0.563.0",
    "pino": "^10.3.0",
    "pino-http": "^11.0.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-is": "^19.2.4",
    "recharts": "^3.7.0",
    "zod": "^4.3.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@testing-library/jest-dom": "^6.2.0",
    "@testing-library/react": "^16.3.2",
    "@testing-library/user-event": "^14.5.0",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^4.7.0",
    "@vitest/coverage-v8": "^4.0.18",
    "autoprefixer": "^10.4.23",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "jsdom": "^22.1.0",
    "pino-pretty": "^13.1.3",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.19",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^5.4.21",
    "vitest": "^4.0.18"
  }
}

```

### `postcss.config.cjs`

```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```

### `public/vite.svg`

```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
```

### `scripts/install-git-hooks.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
  echo "Not inside a git repository." >&2
  exit 1
fi

git config core.hooksPath .githooks
echo "Installed hooks path: .githooks"

```

### `scripts/worktree-backup-and-clean.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
  echo "Not inside a git repository." >&2
  exit 1
fi

current_branch="$(git branch --show-current)"
if [[ -z "$current_branch" ]]; then
  echo "Unable to determine current branch." >&2
  exit 1
fi

ts="$(date +%Y%m%d-%H%M%S)"
backup_branch="codex/wip-backup-${ts}"

if git show-ref --verify --quiet "refs/heads/${backup_branch}"; then
  echo "Backup branch already exists: ${backup_branch}" >&2
  exit 1
fi

if [[ -z "$(git status --porcelain --untracked-files=all)" ]]; then
  echo "Nothing to backup; working tree already clean." >&2
  exit 1
fi

echo "Creating backup branch: ${backup_branch}"
git switch -c "$backup_branch"
git add -A
git commit -m "chore: backup local WIP before cleanup"

echo "Returning to ${current_branch} and cleaning against origin/${current_branch}"
git switch "$current_branch"
git fetch origin
if git show-ref --verify --quiet "refs/remotes/origin/${current_branch}"; then
  git reset --hard "origin/${current_branch}"
else
  echo "Warning: origin/${current_branch} not found; leaving branch as-is before clean." >&2
fi

git clean -fd

echo
echo "Backup complete: ${backup_branch}"
git status --short --branch

```

### `scripts/worktree-check-clean.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
  echo "Not inside a git repository." >&2
  exit 1
fi

status="$(git status --porcelain --untracked-files=all)"
if [[ -n "$status" ]]; then
  echo "Working tree is dirty. Commit/stash/clean before proceeding." >&2
  echo >&2
  echo "$status" >&2
  exit 1
fi

echo "Working tree is clean."

```

### `server/.env.example`

```
# OrderPulse Server Environment Variables
# Copy this file to .env and fill in your values

# =============================================================================
# REQUIRED
# =============================================================================

# Session secret - must be stable and secure in production
SESSION_SECRET=your-secure-session-secret-min-32-chars

# Google OAuth credentials
GOOGLE_CLIENT_ID=your-google-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Gemini API key
GEMINI_API_KEY=your-gemini-api-key

# Arda API credentials
ARDA_TENANT_ID=your-arda-tenant-id
ARDA_API_KEY=your-arda-api-key
ARDA_BASE_URL=https://prod.alpha001.io.arda.cards

# PostgreSQL connection string
DATABASE_URL=postgresql://user:password@localhost:5432/orderpulse

# Redis URL (required for production session persistence)
REDIS_URL=redis://localhost:6379

# Allow in-memory fallback in production (set to true only for demos)
ALLOW_INMEMORY_STORAGE=false

# Frontend URL (for CORS)
FRONTEND_URL=http://localhost:5173
# Backend URL (for OAuth callbacks and redirects)
BACKEND_URL=http://localhost:3001

# Encryption key used for at-rest secrets (32+ characters in production)
ENCRYPTION_KEY=change-me-32-characters-minimum

# =============================================================================
# OPTIONAL
# =============================================================================

NODE_ENV=development
PORT=3001

# Sentry error monitoring
SENTRY_DSN=
SENTRY_TRACES_SAMPLE_RATE=0.1

# Rate limiting
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX=120

# Cognito sync
ENABLE_COGNITO_SYNC=false
COGNITO_SYNC_HOUR=2
GITHUB_COGNITO_TOKEN=

# Amazon Product API
AMAZON_ACCESS_KEY=
AMAZON_SECRET_KEY=
AMAZON_PARTNER_TAG=

# Barcode product lookup (optional)
# If set, OrderPulse will use BarcodeLookup's product database for UPC/EAN/GTIN scans.
BARCODE_LOOKUP_API_KEY=
# Recommended by Open Food Facts (helps avoid rate limiting)
BARCODE_LOOKUP_USER_AGENT=OrderPulse/1.0 (barcode lookup)
#
# UPCitemdb paid plans (optional). If unset, OrderPulse uses the free /prod/trial endpoint.
UPCITEMDB_USER_KEY=
UPCITEMDB_KEY_TYPE=3scale

# Cloudinary (for hosting user-captured photos)
# Sign up free at https://cloudinary.com/
CLOUDINARY_CLOUD_NAME=
CLOUDINARY_API_KEY=
CLOUDINARY_API_SECRET=

```

### `server/data/cognito_users.csv`

```csv
Email,Tenant,Name,Status,Enabled,Created,Modified,Sub,Role
Justin@stabbdesigns.com,7d6e8191-989e-4ebe-98d8-f0b83f942c5f,None,CONFIRMED,True,2025-12-15T13:39:57.108000+00:00,2025-12-15T13:40:01.125000+00:00,e4188408-a061-702a-e75c-64396dcc403a,User
khenson99@gmail.com,c35bb200-ce7f-4280-9108-f61227127a98,Kyle Henson,CONFIRMED,True,2025-09-04T15:20:22.828000+00:00,2025-11-11T14:25:47.871000+00:00,243804b8-d041-709b-25cb-81d1caa2fb01,None
customer-success+usoffsite@arda.cards,fbc86cb5-afdd-4abf-a225-49cd2a42eb20,None,CONFIRMED,True,2025-12-19T05:31:32.217000+00:00,2025-12-19T19:42:20.615000+00:00,a4283418-a0c1-709f-4495-7364dab0096f,User
customer-success+cheo@arda.cards,8bb65454-cddb-4665-b5d4-bad9f04f82af,None,CONFIRMED,True,2025-11-25T01:41:03.132000+00:00,2025-12-05T06:53:18.145000+00:00,041884f8-c091-7031-a056-d212506d33a7,User
e8e3bc8e-12a9-4438-9496-f44b3cfaefc4.bruno@arda.com,3981bfff-a9cc-4bd6-89da-b93097bf4f6e,Bruno Test e8e3bc8e-12a9-4438-9496-f44b3cfaefc4,CONFIRMED,True,2025-11-21T22:06:10.018000+00:00,2025-11-21T22:06:10.725000+00:00,c4281498-30b1-704e-39e2-58e2011d4a70,User
darren@luvaas.com,d4edf385-4a99-4e5b-b83a-9dab30a5a5cc,Darren Luvaas,CONFIRMED,True,2025-10-05T17:03:37.471000+00:00,2025-10-05T17:03:38.395000+00:00,a458e418-e031-706d-8c82-49984092b850,User
info@boostmanufacturing.com,4c8715ff-67ee-4d4d-a227-9feb2d14a8e7,thomas seaman,CONFIRMED,True,2025-11-12T21:14:57.411000+00:00,2025-11-12T21:14:59.814000+00:00,2468b478-70d1-7066-877d-9194e780a30e,User
abrock@northstarchemical.com,6fa02301-2cd9-4cfa-a258-40474b828945,Aaron,CONFIRMED,True,2025-11-18T00:23:43.351000+00:00,2025-11-18T00:23:45.527000+00:00,44884438-5081-7019-26a1-28eb5239329e,User
sam@austeremfg.com,8d53c9a0-3e9c-4f5a-9dbe-ad06b56bc3e4,Sam,CONFIRMED,True,2025-11-05T19:58:58.086000+00:00,2025-11-11T14:27:02.813000+00:00,34a82408-2061-703b-e826-c5c89909ea47,User
customer-success+shoptoolco@arda.cards,73951365-1cbe-46ac-9b80-6ac44982983b,None,CONFIRMED,True,2025-12-22T18:11:30.836000+00:00,2026-01-13T18:48:34.045000+00:00,e478b418-d051-70ea-2aeb-5d26cadb808a,User
bryan.crosbie@elliottequip.com,279ae256-3aef-413c-b735-73bacf172b7d,Bryan Crosbie,CONFIRMED,True,2025-11-18T21:09:34.773000+00:00,2025-11-19T16:08:09.174000+00:00,a4e88418-10d1-70ea-cb39-effb69ea8d75,User
myemail.brian@gmail.com,d7c3a99e-fc62-4214-b13e-343a0d838ad9,None,CONFIRMED,True,2025-12-08T08:08:04.966000+00:00,2025-12-10T06:48:15.424000+00:00,74c8d4a8-6091-704a-48d4-78c6369f60d3,User
Jeremy@titanap.com,9bd4adb9-e173-4a5b-8b5a-678c4502e673,None,CONFIRMED,True,2026-01-12T22:23:30.943000+00:00,2026-01-12T22:23:36.403000+00:00,24f81488-90c1-706a-034a-707e98bc6cac,User
office@thewoodworksny.com,f556bbb9-e9b6-4d57-929e-5e0bb7dac712,Casey Case,CONFIRMED,True,2025-11-11T16:41:54.772000+00:00,2025-11-11T16:58:33.426000+00:00,84f83498-70e1-70db-52c0-a958dda377ea,User
uriel@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,Uriel,CONFIRMED,True,2025-08-27T17:55:48.544000+00:00,2025-11-11T14:25:20.272000+00:00,14f8f4b8-f071-70f2-ae92-1fbf4bba71bd,User
graham@lightsoutmfg.com,baa1f883-ecfa-4912-b5be-d5784d8b96a4,Graham,CONFIRMED,True,2025-11-20T01:02:50.145000+00:00,2025-11-20T01:02:52.146000+00:00,44a8a4d8-f0f1-70a2-4e48-b9f6845340f9,User
mariamaier7908@gmail.com,7bf4ecac-f8dd-45ef-be63-9a0cbeb677c0,Nora ,CONFIRMED,True,2025-11-18T13:45:53.051000+00:00,2025-11-18T13:45:55.064000+00:00,149894e8-c0d1-708e-28ef-10f5e2ce38a8,User
Brad@momentumwoodworks.com,93cb3c74-750f-489d-9623-6d75858f64e2,Brad Rosenthal,CONFIRMED,True,2025-10-21T18:19:55.088000+00:00,2025-11-11T14:23:07.310000+00:00,04b82418-c021-7029-8807-dbfbbc331303,User
steven@shoptoolco.com,73951365-1cbe-46ac-9b80-6ac44982983b,None,CONFIRMED,True,2025-12-22T17:28:33.431000+00:00,2025-12-22T17:28:37.056000+00:00,64e82418-6011-7077-f05f-9e67a716de1e,User
test130@gh.com,981be746-9a00-4ad0-bab3-fa526f86b7a6,None,CONFIRMED,True,2026-01-19T11:16:54.950000+00:00,2026-01-19T11:16:58.880000+00:00,64d8e4a8-e0d1-708e-443e-93092cbee90a,User
steaven@studiorrd.com,bdf57d6c-aad3-40dc-a553-9eb09dbf108e,None,CONFIRMED,True,2026-01-20T20:55:49.383000+00:00,2026-01-20T23:04:40.901000+00:00,84b8f448-d0c1-7026-c522-0bdb17dd6f92,User
minnie@tenoneten.net,0e1ad78a-7403-4e8a-9be0-0560553cff62,Minnie Ingersoll,CONFIRMED,True,2025-10-21T20:13:45.630000+00:00,2025-11-11T14:26:33.407000+00:00,247864c8-f021-700e-a4a3-d8320eaf6f49,User
matt.hager12@gmail.com,9f6e996f-9510-4da2-bfb8-c28a46601bf9,Matt Hager,CONFIRMED,True,2025-10-14T23:07:28.229000+00:00,2025-10-23T18:33:06.672000+00:00,e48894b8-90a1-706a-2e23-16cc1bcc8f04,User
Zach.rose@traceaudio.com,75980a19-64ec-4f1a-a2ea-0446ea937b16,None,CONFIRMED,True,2026-01-09T07:10:20.744000+00:00,2026-01-09T07:37:28.776000+00:00,e4d8f458-a041-7094-626f-9d25bf8aab9c,User
customer-success+austere@arda.cards,f065cc32-6370-4e23-88a6-ee602638e89f,Customer Success - Austere Manufacturing,CONFIRMED,True,2025-11-03T01:59:41.114000+00:00,2025-11-05T17:08:30.897000+00:00,54281478-80f1-709c-07b3-82151e85d032,User
twilson@cheo.on.ca,8bb65454-cddb-4665-b5d4-bad9f04f82af,None,CONFIRMED,True,2025-11-25T13:34:34.434000+00:00,2025-11-25T13:34:38.057000+00:00,34e84478-b031-7011-1627-6fac509fb812,User
mgonzalez@parkerplastics.net,43effb1d-e6cb-466f-a82b-1a003bc9fffd,Parker Plastics Maryland,CONFIRMED,True,2025-11-13T22:15:22.079000+00:00,2025-11-13T22:15:24.422000+00:00,24f854c8-d041-7010-afad-e0d60cce25b2,User
deervalleymachineworks@gmail.com,331467a1-6c14-46e8-8398-f71465c2df62,None,CONFIRMED,True,2025-12-13T20:14:25.728000+00:00,2025-12-13T20:14:29.256000+00:00,e438f418-3081-70d6-6f8d-9d969a9b8a62,User
uriel@austeremfg.com,f065cc32-6370-4e23-88a6-ee602638e89f,Uriel,CONFIRMED,True,2025-11-04T23:31:23.495000+00:00,2025-11-04T23:31:23.937000+00:00,8418a488-d0c1-70d7-e707-f35cf89c94e3,User
customer-success+dallasmakerspace@arda.cards,d3600279-0bce-4dd6-9f4c-699ef9cc887d,Customer Success - Dallas Maker Space,CONFIRMED,True,2025-11-04T23:29:05.223000+00:00,2025-11-05T17:06:34.760000+00:00,94e81418-a011-7015-b68a-4623cd04fcc8,User
noah@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,Noah,CONFIRMED,True,2025-11-03T18:22:10.570000+00:00,2025-11-10T15:23:27.316000+00:00,64481448-5051-70e8-f58f-edfeb20d7fed,User
aaron@roamrig.com,3a1aa0ea-6611-477f-bb30-36058c40eee8,None,CONFIRMED,True,2025-12-05T04:45:16.947000+00:00,2025-12-05T04:45:20.500000+00:00,04284438-00c1-70e9-d0a7-9bd9df13f7ac,User
Connor.Wang@traceaudio.com,75980a19-64ec-4f1a-a2ea-0446ea937b16,None,CONFIRMED,True,2026-01-09T07:09:20.226000+00:00,2026-01-09T07:36:43.866000+00:00,5418f468-3001-707f-1658-a789bc7bba9c,User
customer-success+yardtruck@arda.cards,11fb8437-a70d-4ef3-8d24-7ec7453cd09c,None,CONFIRMED,True,2025-12-11T21:12:11.727000+00:00,2025-12-11T21:12:15.385000+00:00,64d88418-00d1-708b-1d69-b7a7d4db1069,User
will@reachable-tech.com,9db131b9-da94-4c20-bcab-0f70e079bd0d,None,CONFIRMED,True,2025-12-08T19:20:04.469000+00:00,2025-12-08T19:20:09.625000+00:00,44d8a468-40e1-700a-32f6-2ae6cdaf5ea5,User
Sam@austeremfg.com,40f933b7-eb84-4fbf-b7a7-8fb330116234,Sam,CONFIRMED,True,2025-11-05T00:14:01.231000+00:00,2025-11-05T00:14:03.354000+00:00,c40814a8-e0e1-70c2-f353-134da6410fa8,User
B@feldmantoolco.com,6c2ecae2-14f2-45ef-a5d0-202271f70bd5,None,CONFIRMED,True,2025-11-25T01:47:24.269000+00:00,2025-11-25T01:47:27.707000+00:00,648874f8-a031-7048-7a94-1b6662e2fef8,User
customer-success+gunnar@arda.cards,724ffc0f-ff6b-4e63-9e33-f6de613cc885,None,CONFIRMED,True,2025-12-24T16:19:14.837000+00:00,2025-12-24T22:33:37.307000+00:00,746844e8-6071-70d4-78e4-5beda1b6e988,User
demo2T1@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,demo2T1,CONFIRMED,True,2025-08-27T17:06:59.308000+00:00,2025-10-16T06:50:27.187000+00:00,1478c438-5041-7050-92e8-2c39b3039951,User
customer-success+titanap@arda.cards,9bd4adb9-e173-4a5b-8b5a-678c4502e673,None,CONFIRMED,True,2026-01-14T02:31:15.165000+00:00,2026-01-14T02:36:56.411000+00:00,84f85468-6061-7066-5880-14a10693862c,User
chu.daisy@me.com,5f0d4c40-1a78-4ff9-8366-d404eea27d6b,None,CONFIRMED,True,2026-01-14T20:34:34.531000+00:00,2026-01-14T20:34:38.371000+00:00,24e80448-f0b1-70f6-01d8-5a13091a5f2b,User
max@studiorrd.com,bdf57d6c-aad3-40dc-a553-9eb09dbf108e,None,CONFIRMED,True,2026-01-08T21:45:49.971000+00:00,2026-01-08T21:45:53.758000+00:00,44282408-7061-70b0-291e-14dd9e4fb45d,User
felip@felipsautoservice.com,5a944ca4-88f4-411b-af4c-b579276db05c,Felip's Auto Service,CONFIRMED,True,2025-10-29T16:38:16.034000+00:00,2025-10-31T16:33:12.354000+00:00,54e88448-5051-70ca-8095-d6f0250d3548,User
elizabeth@americancompletiontools.com,61cbcbe8-5db5-4c6d-b65c-3d338d00dae0,ELIZABETH EATON,CONFIRMED,True,2025-11-03T15:28:14.058000+00:00,2025-11-03T15:28:16.167000+00:00,6428d418-5041-703b-2774-28de418ed2c1,User
customer-success+gimbelgroup@arda.cards,9189acf9-4f89-46cd-9760-0d4933d58c67,Customer Success - Gimbel Group,CONFIRMED,True,2025-11-04T23:27:23.294000+00:00,2025-11-05T17:02:31.278000+00:00,e4c87478-d001-7004-cbfe-cac0371aaf59,User
customer-success+hartwig-exhibit@arda.cards,6548184b-6aad-4f29-a743-fd8d8b58da0b,None,CONFIRMED,True,2025-12-08T16:02:07.948000+00:00,2025-12-08T16:02:12.008000+00:00,24185458-d0f1-7099-7fdd-66a630e2e1f2,User
purchasing@usoffsite.com,fbc86cb5-afdd-4abf-a225-49cd2a42eb20,None,CONFIRMED,True,2025-12-09T14:27:35.633000+00:00,2025-12-09T14:27:39.392000+00:00,24c834f8-b001-70d1-1f11-797596243e09,User
ianwilson@dallasmakerspace.org,d3600279-0bce-4dd6-9f4c-699ef9cc887d,Ian Wilson,CONFIRMED,True,2025-10-21T19:57:22.692000+00:00,2025-10-21T19:57:24.758000+00:00,a4a894f8-4061-70d6-55fa-c86f0933acd4,User
em@studiorrd.com,bdf57d6c-aad3-40dc-a553-9eb09dbf108e,None,CONFIRMED,True,2026-01-20T20:55:37.626000+00:00,2026-01-26T17:24:18.565000+00:00,a4d86428-d011-705c-6723-8cb65c0a99f3,User
70268141-1cdc-4ea1-b056-c3129e375623.bruno@arda.com,c4fed3cf-48ef-4c0b-b4f1-ae8eb2164b3c,None,CONFIRMED,True,2025-11-21T22:06:02.121000+00:00,2025-11-21T22:06:03.078000+00:00,74081408-20d1-7023-77ca-0f327f8996bc,User
miguel@arda.cards,32e20356-c9a0-469d-816a-2f8d759a81af,Miguel,CONFIRMED,True,2025-10-27T21:41:37.949000+00:00,2025-10-27T21:41:40.106000+00:00,c4583468-70f1-706c-2d24-c7f0748c7a54,User
goran@hartwig-exhibit.com,fba0e961-8433-4c00-b42f-84e7b1dc822b,None,CONFIRMED,True,2025-12-06T03:15:57.658000+00:00,2025-12-06T03:16:01.261000+00:00,94c8a408-1061-7052-a7ef-291ec2e3fe93,User
mat+felipsautoservice@arda.cards,5a944ca4-88f4-411b-af4c-b579276db05c,Customer Success - FelipsAutoService,CONFIRMED,True,2025-10-31T17:05:52.517000+00:00,2025-10-31T19:32:28.212000+00:00,74b83468-d051-706a-8703-e86c0d0f7eb2,User
david@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,Dave,CONFIRMED,True,2025-08-27T14:41:59.131000+00:00,2025-11-11T14:24:28.878000+00:00,14a8e498-f0f1-7014-b450-02a3c2342cb1,User
luis.becerril@bellacanvas.com,82024bd8-6f95-49bd-a578-d0cdc47ea510,Luis Becerril,CONFIRMED,True,2025-11-19T12:46:12.258000+00:00,2025-11-19T12:46:14.346000+00:00,6458a488-e021-7021-3bf2-032b33f01556,User
e435ab39-bd63-4ded-a35f-69694c250d83.bruno@arda.com,None,None,CONFIRMED,True,2025-11-21T21:59:08.462000+00:00,2025-11-21T21:59:08.462000+00:00,04980458-b041-7031-d58e-15dfe1177243,None
customer-success+elliot@arda.cards,279ae256-3aef-413c-b735-73bacf172b7d,Customer Success - Elliott,CONFIRMED,True,2025-11-23T00:35:22.312000+00:00,2025-11-23T02:37:47.325000+00:00,f418e418-7021-70dc-1714-a920682404af,User
mat+momentumwoodworks@arda.cards,93cb3c74-750f-489d-9623-6d75858f64e2,Customer Success - Momentum Woodwoorks,CONFIRMED,True,2025-10-30T03:46:50.190000+00:00,2025-10-30T04:12:18.272000+00:00,f4187468-1071-705a-353d-89eb5c27df7d,User
yanni@callperfectcatch.com,d535ff7b-d278-4711-a94f-cd47b3c59596,yanni,CONFIRMED,True,2025-11-15T23:50:21.392000+00:00,2025-11-15T23:50:21.808000+00:00,f4e86448-f081-7044-974b-c4346ccb8515,User
mat@arda.cards,582e63e2-fe36-4e98-8e76-c64332071113,Mathew Hager,CONFIRMED,True,2025-09-10T17:12:18.518000+00:00,2025-11-11T14:24:59.602000+00:00,14e84458-8061-70ad-d18b-306117235cd2,User
Yanni@callperfectcatch.com,d535ff7b-d278-4711-a94f-cd47b3c59596,Yanni,CONFIRMED,True,2025-11-15T23:46:31.034000+00:00,2025-11-17T17:15:56.947000+00:00,94789448-d0a1-703b-19a8-0af727e8e85b,User
Tate.Bailey@traceaudio.com,75980a19-64ec-4f1a-a2ea-0446ea937b16,None,CONFIRMED,True,2026-01-09T07:08:44.874000+00:00,2026-01-09T07:36:04.646000+00:00,d4084478-6031-706c-5808-79ba11dbbff6,User
elisha@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,Elisha Eisen,CONFIRMED,True,2025-11-03T21:38:30.638000+00:00,2025-11-03T21:40:34.733000+00:00,8488e458-5021-708d-d7fc-c9f5f830d145,User
kanbunny1@gmail.com,7ca2dac5-2493-4dc4-b442-7b860079d853,Kyle Henson,CONFIRMED,True,2025-10-03T02:03:45.741000+00:00,2025-10-03T02:03:47.885000+00:00,b458b428-d091-70a8-7798-dd10d3347bf9,User
customer-success+smartcon@arda.cards,e24408eb-69b3-477d-9090-97e314113996,None,CONFIRMED,True,2026-01-07T20:34:01.351000+00:00,2026-01-07T20:52:54.424000+00:00,f40884d8-d091-7043-7731-1bcae40ff75f,User
jeniffer@arda.cards,7a0b8eb9-73a4-424a-8ccd-8d6401c9fdd8,Jeniffer,CONFIRMED,True,2025-09-04T22:25:39.676000+00:00,2026-01-09T19:06:38.400000+00:00,04682458-3001-70ef-4eaf-b1e03c956588,User
jparry@smartconsolutions.com,e24408eb-69b3-477d-9090-97e314113996,None,CONFIRMED,True,2026-01-06T17:04:12.781000+00:00,2026-01-06T17:04:16.893000+00:00,34a8e478-d0c1-7082-d95b-f4116933ef4c,User
adamkirkpatrick@winn-marion.com,7bb9f2ed-ef55-4303-b6ee-9ead660bbeed,Adam Kirkpatrick,CONFIRMED,True,2025-10-27T18:16:15.892000+00:00,2025-10-27T18:16:18.100000+00:00,9468e498-50a1-7080-2988-2c172522ef92,User
9984ff3d-7294-43eb-bfb6-d90f71d24aa5.bruno@arda.com,364a7226-ba2d-4554-937d-665f02b506ba,Bruno Test 9984ff3d-7294-43eb-bfb6-d90f71d24aa5,CONFIRMED,True,2025-11-21T22:05:49.426000+00:00,2025-11-21T22:05:54.860000+00:00,44183488-90e1-70d1-6238-5afb46b60634,User
calebd0716@icloud.com,f3691efa-7fc0-4007-99ce-8a37ed591153,None,CONFIRMED,True,2025-11-30T19:12:48.186000+00:00,2025-11-30T19:12:51.771000+00:00,8488a498-30b1-709d-8481-4a80d5f06b5b,User
office@landiselectrickc.com,6c792c85-161a-46a5-a127-90476daa2b20,Christopher Landis,CONFIRMED,True,2025-11-04T19:08:30.909000+00:00,2025-11-11T14:23:56.850000+00:00,14985458-c031-70b2-61cb-0575843c3dff,User
gunnar@nexgenmfg.net,724ffc0f-ff6b-4e63-9e33-f6de613cc885,None,CONFIRMED,True,2025-12-23T19:19:33.551000+00:00,2025-12-23T19:19:38.638000+00:00,2418f418-b051-7062-f053-0b92a7167145,User
customer-success+boostmanufacturing@arda.cards,4c8715ff-67ee-4d4d-a227-9feb2d14a8e7,None,CONFIRMED,True,2025-12-12T15:37:10.964000+00:00,2025-12-12T20:33:38.849000+00:00,249854f8-c021-70fc-582c-a44a5943e97e,User
mat+video@arda.cards,cafffb62-65e4-411a-98f9-513e1d39af47,Mat Hager,CONFIRMED,True,2025-11-05T01:56:07.407000+00:00,2025-11-05T01:56:09.446000+00:00,f468d488-e021-7094-eeb6-0e6d43743357,User
denis@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,Denis,CONFIRMED,True,2025-08-27T23:32:31.564000+00:00,2026-01-01T14:57:16.372000+00:00,34b84408-9061-7030-11fe-fb0281fa7489,User
fortitudeweldfab@outlook.com,4cd464c4-558b-499f-8185-c6683bfd5c29,None,CONFIRMED,True,2025-12-19T16:31:50.109000+00:00,2025-12-19T16:31:53.884000+00:00,34986418-b0c1-7044-00d3-6cb30bc05aee,User
darren@arda.cards,5ad129e2-889c-4748-ac5e-50308963f93e,Darren Luvaas,CONFIRMED,True,2025-10-05T16:58:02.802000+00:00,2025-11-11T14:22:02.333000+00:00,04583428-d0a1-7051-f326-50476c8ddc8f,User
ryan@bluewatersportfishingboats.com,2d7a820e-f4e4-48bc-8c6d-4307a151b5cc,None,CONFIRMED,True,2025-12-02T19:50:08.186000+00:00,2025-12-02T19:50:12.343000+00:00,9438b498-f081-703c-c04c-bab051040f1f,User
customer-success+thelabelfactory@arda.cards,21ee51b8-2ec8-4adc-879e-8f0cd3dd804a,Customer Success - The Label Factory,CONFIRMED,True,2025-11-19T00:29:18.842000+00:00,2025-11-19T00:35:44.028000+00:00,a4d804e8-10e1-70b0-0c76-68e24f1611de,User
arda@wilsonmanifolds.com,77b6d789-a446-4c10-8fd0-9ba32595a8bc,None,CONFIRMED,True,2026-01-06T16:05:50.129000+00:00,2026-01-06T16:05:54.073000+00:00,64a804d8-8061-7035-bd97-5bc2b5012326,User
matt@blackwellengineeringllc.com,b5ea0be9-ce18-4bf0-81c8-b5981a893189,Matt Blackwell,CONFIRMED,True,2025-10-03T02:30:40.056000+00:00,2025-10-03T02:30:42.309000+00:00,84f89448-7031-708e-f879-621f7ac4686c,User
customer-success+traceaudio@arda.cards,75980a19-64ec-4f1a-a2ea-0446ea937b16,None,CONFIRMED,True,2026-01-09T07:06:58.151000+00:00,2026-01-09T07:35:09.859000+00:00,64d82468-d0d1-70a8-7d6b-6a43b323599e,User
dan@foragercycles.com,dc517d59-0ba1-421f-9e0d-5aa5641862d0,Daniel Stranahan,CONFIRMED,True,2025-11-22T01:48:42.972000+00:00,2025-11-22T01:48:46.922000+00:00,94182458-6091-7099-3e2f-ad030d625cd8,User
office@caseconstruction.net,f556bbb9-e9b6-4d57-929e-5e0bb7dac712,Casey Case,CONFIRMED,True,2025-11-10T18:51:27.397000+00:00,2025-11-10T18:51:29.558000+00:00,c418c4c8-a051-70cc-ca41-80847ca6ad52,User
morgan@growthhit.com,60b05ded-492e-46d0-92ee-e9059421e1d1,Morgan,CONFIRMED,True,2025-10-22T16:11:54.255000+00:00,2025-10-22T16:11:56.525000+00:00,04f824e8-90c1-70c1-cab6-bbb5510d02b8,User
harriet@momentumwoodworks.com,93cb3c74-750f-489d-9623-6d75858f64e2,Harriet,CONFIRMED,True,2025-10-23T00:25:59.810000+00:00,2025-10-24T14:40:14.248000+00:00,e4f84448-8081-7085-cd5b-9c2144087b93,User
jay@capitalstainless.com,b4ec12e7-766d-499e-82a7-1b71aa84ceaf,Jay Olson,CONFIRMED,True,2025-11-20T22:29:45.406000+00:00,2025-11-20T22:29:47.510000+00:00,e4b85438-40b1-70cc-b1fa-2b095666b4d0,User
customer-success+winnmarion@arda.cards,7bb9f2ed-ef55-4303-b6ee-9ead660bbeed,Customer Success - Winn Marion,CONFIRMED,True,2025-11-04T23:25:29.617000+00:00,2025-11-05T17:00:59.341000+00:00,84082458-b091-702c-88db-271e5dacab06,User
devin@lichenprecision.com,6d81d80e-7010-468f-a191-f1dab4f4fc79,Devin Bodony,CONFIRMED,True,2025-10-15T14:24:17.548000+00:00,2025-11-11T15:22:37.710000+00:00,44c83428-e051-70b1-a4d1-4eab115580bb,User
Orders@traceaudio.com,75980a19-64ec-4f1a-a2ea-0446ea937b16,None,CONFIRMED,True,2026-01-09T07:11:11.704000+00:00,2026-01-09T07:37:04.063000+00:00,04482488-7061-70af-0bc1-0b5351ecc35a,User
customer-success+caliperstudios@arda.cards,0bf2aaf7-eeeb-4664-a25f-9945428941fd,Customer Success - Caliper Studios,CONFIRMED,True,2025-11-17T22:39:08.868000+00:00,2025-11-21T23:01:33.324000+00:00,24a844f8-20a1-70cb-472a-99c72db6360b,User
customer-success+americancompletiontools@arda.cards,61cbcbe8-5db5-4c6d-b65c-3d338d00dae0,Customer Success - American Completion Tools,CONFIRMED,True,2025-11-04T23:23:29.793000+00:00,2025-11-05T17:00:02.109000+00:00,8418c418-c081-7094-873a-151b2fe3c7cd,User
customer-success+studiordd@arda.cards,bdf57d6c-aad3-40dc-a553-9eb09dbf108e,None,CONFIRMED,True,2026-01-20T18:37:00.516000+00:00,2026-01-20T21:19:20.235000+00:00,3448c418-50c1-704a-9e9c-225700fdad68,User
Doug.Anderson@medela.com,a6867980-c285-4d1b-80fb-5df62f14a993,Douglas Anderson,CONFIRMED,True,2025-10-30T18:33:08.210000+00:00,2025-10-30T18:33:10.078000+00:00,d4e8a488-f011-702d-fdd9-76b952ebe1dd,User
customer-success+bellacanvas@arda.cards,82024bd8-6f95-49bd-a578-d0cdc47ea510,Customer Success - Bella Canvas,CONFIRMED,True,2025-11-23T00:37:17.002000+00:00,2025-11-23T02:38:41.750000+00:00,64189438-a021-70cc-464b-39707d776676,User
customer-success+motorolasolutions@arda.cards,39af20af-18ee-4985-9390-d037c0f994a1,Customer Success - Motorola Solutions,CONFIRMED,True,2025-11-04T23:53:10.907000+00:00,2025-11-05T17:12:20.606000+00:00,94c89408-00c1-70be-0896-dacfe7031c16,User
jeniffe+2@arda.cards,0bed19bf-3e07-46f2-89ab-04d1eebc0b74,None,CONFIRMED,True,2025-12-22T10:14:54.973000+00:00,2025-12-22T10:14:58.654000+00:00,a4f85428-20c1-70c7-5018-3112b8bb48fe,User
sales@thelabelfactory.com.au,21ee51b8-2ec8-4adc-879e-8f0cd3dd804a,Stuart Fsyh,CONFIRMED,True,2025-11-17T02:26:08.787000+00:00,2025-11-17T02:26:10.998000+00:00,2498d488-d0d1-70af-4772-ab390e578096,User
Brandon.boyd@elliottequip.com,279ae256-3aef-413c-b735-73bacf172b7d,Brandon,CONFIRMED,True,2025-11-18T21:11:00.427000+00:00,2025-11-19T16:08:48.467000+00:00,f4b85438-c081-701b-43b3-57c09280d0af,User
customer-success+texassidecar@arda.cards,1fa48bf2-3ef9-4d08-8858-29e71504a1ed,Customer Success - Texas Sidecar,CONFIRMED,True,2025-11-21T19:24:42.420000+00:00,2025-11-21T23:00:31.424000+00:00,a468e418-7021-70bb-bd3b-77a6f1c6ee93,User
customer-success+neffmachine@arda.cards,1193d42d-ef80-4bc8-ab11-84e5c8046892,Customer-Success - Neff Machine,CONFIRMED,True,2025-11-03T02:22:00.464000+00:00,2025-11-05T16:58:46.343000+00:00,84a86458-2011-7093-a38c-266bf45173fb,User
jovany.falcon@motorolasolutions.com,39af20af-18ee-4985-9390-d037c0f994a1,Jovany Falcon,CONFIRMED,True,2025-11-04T23:52:59.611000+00:00,2025-11-04T23:53:01.711000+00:00,54a89428-00d1-70db-eb9e-2b26cc541ef1,User
meg@roamrig.com,a9e3aef7-86aa-4199-bfa7-0e29d05b2774,Meg Myers,CONFIRMED,True,2025-11-05T23:03:48.682000+00:00,2025-11-11T15:23:20.596000+00:00,44d854e8-b051-701f-5f80-3809d676c37a,User
admin@traceaudio.com,75980a19-64ec-4f1a-a2ea-0446ea937b16,None,CONFIRMED,True,2026-01-09T07:11:51.370000+00:00,2026-01-09T07:37:47.216000+00:00,64b8e4d8-9081-702d-93a2-27a8b24b5856,User
ameyers@caliperstudio.com,0bf2aaf7-eeeb-4664-a25f-9945428941fd,Aaron Meyers,CONFIRMED,True,2025-11-05T21:46:25.684000+00:00,2025-11-14T16:34:08.057000+00:00,f4b82478-b001-7009-ba50-b76ce1d59eb9,User
u.buzzoff@gmail.com,ec5f2dd1-33a6-4b5d-95fd-d8fc13eae647,Uriel Personal test,CONFIRMED,True,2025-10-14T06:31:30.775000+00:00,2025-10-14T06:31:32.744000+00:00,b41834c8-c061-707a-5ae5-d0ed7ae8e28f,User
mike.lockhart@elliottequip.com,279ae256-3aef-413c-b735-73bacf172b7d,None,CONFIRMED,True,2026-01-09T17:43:01.036000+00:00,2026-01-27T22:50:24.596000+00:00,7468e488-9071-7034-f988-b3de527cc802,User
ty@neffmachine.com,1193d42d-ef80-4bc8-ab11-84e5c8046892,Ty,CONFIRMED,True,2025-10-28T03:25:14.106000+00:00,2025-10-28T03:25:16.068000+00:00,d4a86478-4061-7076-20dc-9f3667a01786,User
customer-success+c4mfg@arda.cards,6844ee44-149c-41fe-a9fa-b1b9d2411d62,None,CONFIRMED,True,2026-01-26T19:58:47.934000+00:00,2026-01-26T21:23:19.625000+00:00,14287488-00c1-7059-4346-b7d9f16053a2,User
shenson1161@gmail.com,c35bb200-ce7f-4280-9108-f61227127a98,Susan Henson,CONFIRMED,True,2025-09-04T15:18:53.555000+00:00,2025-10-16T06:54:55.660000+00:00,e4c8a498-b051-70c5-5577-189ffc92f269,None
ausgeknipst@gmail.com,d1b73191-9036-4fcd-a60b-0b2b2d700ca1,None,CONFIRMED,True,2025-12-09T14:04:20.183000+00:00,2025-12-09T14:04:24.099000+00:00,446844b8-7011-700b-5a53-04103697c296,User
oliviero@solstis.ai,6d75f348-65cd-4066-9174-879fad4e6bf1,Oliviero Pinotti,CONFIRMED,True,2025-11-02T19:00:43.065000+00:00,2025-11-11T15:23:58+00:00,5488a468-20b1-7078-5d3d-920b83c398fb,User
madi@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,Madi,CONFIRMED,True,2025-08-27T18:37:28.431000+00:00,2025-11-11T15:22:09.205000+00:00,34d8f448-f051-7056-e07b-b67783a0a9e5,None
info@texassidecars.com,1fa48bf2-3ef9-4d08-8858-29e71504a1ed,Kent Silk,CONFIRMED,True,2025-11-15T02:18:01.526000+00:00,2025-11-15T02:18:03.695000+00:00,f41834d8-60c1-7058-d326-7e43504a9a69,User
demo_t1_1@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,demo_t1_1,FORCE_CHANGE_PASSWORD,True,2025-08-26T17:45:58.239000+00:00,2025-10-16T06:54:25.459000+00:00,44783428-60c1-70ec-807a-0ecf670fba5c,User
zach.stowe@elliottequip.com,279ae256-3aef-413c-b735-73bacf172b7d,Zach Stowe,CONFIRMED,True,2025-11-18T19:57:27.895000+00:00,2025-11-18T19:57:29.882000+00:00,64286458-00a1-709d-6770-a52a9af38525,User
mat+demo2@arda.cards,1c75e6f7-bdd7-4678-a29e-62e2ffdb926f,Mat Hager,CONFIRMED,True,2025-11-21T19:29:59.194000+00:00,2026-01-27T18:55:10.655000+00:00,e49804d8-4061-7016-ac82-64428a86b8fe,User
ArdaDogfood@arda.cards,a8f3b977-fa1f-4938-bc59-861d3be0c419,Arda Dogfood,CONFIRMED,True,2025-11-03T01:51:41.382000+00:00,2025-11-03T01:51:43.624000+00:00,34d8d4a8-2031-704b-ceae-1ceaaafed56a,User
45d4e5e0-d703-45a6-b173-fc5a500881b4.bruno@arda.com,None,Bruno Test 45d4e5e0-d703-45a6-b173-fc5a500881b4,CONFIRMED,True,2025-11-21T21:59:02.967000+00:00,2025-11-21T21:59:02.967000+00:00,a49884e8-a051-700f-5e04-1576312a345e,None
customer-success+foragercycles@arda.cards,dc517d59-0ba1-421f-9e0d-5aa5641862d0,None,CONFIRMED,True,2025-12-10T18:09:42.108000+00:00,2025-12-10T22:46:35.539000+00:00,a4b83498-9071-708f-552c-3ffbb12aeb26,User
ben@traceaudio.com,75980a19-64ec-4f1a-a2ea-0446ea937b16,None,CONFIRMED,True,2026-01-02T19:01:09.847000+00:00,2026-01-02T19:01:13.590000+00:00,34c874e8-d0c1-706f-c0e3-6e9af39eb2d9,User
kyle@arda.cards,c35bb200-ce7f-4280-9108-f61227127a98,Kyle,CONFIRMED,True,2025-08-27T17:56:59.998000+00:00,2025-10-16T06:55:22.083000+00:00,f4d85438-6041-70f0-7996-604516b2a39a,User
mat+medala@arda.cards,a6867980-c285-4d1b-80fb-5df62f14a993,Customer Success - Medela,CONFIRMED,True,2025-10-30T03:38:05.577000+00:00,2025-10-31T06:03:39.977000+00:00,94f85468-d0f1-7081-9a5e-9eff6d432624,User
accounts@gimbel.group,9189acf9-4f89-46cd-9760-0d4933d58c67,Account at Gimbel Group,CONFIRMED,True,2025-10-28T03:32:51.898000+00:00,2025-10-28T03:32:54.028000+00:00,a458a4b8-8011-7096-4b6a-ac3522cddabd,User
customer-success+capitalstainless@arda.cards,b4ec12e7-766d-499e-82a7-1b71aa84ceaf,None,CONFIRMED,True,2025-12-03T21:12:30.437000+00:00,2025-12-09T01:16:22.649000+00:00,a4a80458-b001-7055-15b6-ef4b7096025c,User
chance@c4mfg.com,6844ee44-149c-41fe-a9fa-b1b9d2411d62,None,CONFIRMED,True,2026-01-23T23:09:02.494000+00:00,2026-01-27T18:46:45.655000+00:00,b428e4f8-f0d1-7097-00ca-62c540968715,User
1adc8cde-d729-4bd4-a101-ae45ea98fe0f.bruno@arda.com,909d4ef3-1fdb-4aad-87c3-a291eb3dc560,None,CONFIRMED,True,2025-11-21T22:06:11.949000+00:00,2025-11-21T22:06:13.439000+00:00,f4d834a8-e0e1-70fa-8531-ad479a8b2795,User

```

### `server/docs/cognito-provisioning.md`

````markdown
# Cognito User Provisioning (Order Pulse)

This doc covers how to ensure a Cognito user exists and is mapped to a tenant.

## Why this exists
Order Pulse resolves tenant + author data from Cognito for authenticated users. If a user email is missing from Cognito, Arda sync will fail with `TENANT_REQUIRED`.

The `create_new` tenant flow now auto-creates/updates the Cognito mapping, but you can also run it manually.

## Environment requirements
The backend uses AWS Cognito Admin APIs. These env vars must be set:

- `COGNITO_AWS_REGION` (or `AWS_REGION`)
- `COGNITO_USER_POOL_ID`
- `COGNITO_AWS_ACCESS_KEY_ID` / `COGNITO_AWS_SECRET_ACCESS_KEY`
  - or `AWS_ACCESS_KEY_ID` / `AWS_SECRET_ACCESS_KEY`

## Manual CLI (local)
From `/Users/kylehenson/order-pulse/server`:

```bash
npm run cognito:ensure-user -- --email user@example.com --tenant <tenantId> --role User --name "User Name"
```

Notes:
- `--role` defaults to `User`.
- Invite emails are suppressed by default. Add `--send-invite` to email the user.
- The command updates existing users (by email) or creates new ones.

## Automatic flow (backend)
When a user selects **Create New Tenant**, the backend will:
1. Provision the tenant in Arda.
2. Create/update the Cognito user for the logged-in email.

Code path:
- `/Users/kylehenson/order-pulse/server/src/routes/arda.ts` (create_new branch)
- `/Users/kylehenson/order-pulse/server/src/services/cognito.ts` (`ensureUserMappingForEmail`)

## Troubleshooting
- `UnrecognizedClientException`: invalid AWS credentials.
- `ResourceNotFoundException`: wrong `COGNITO_USER_POOL_ID` or region.
- No mapping after sync: confirm the Cognito user exists and has `custom:tenant` set.

````

### `server/package.json`

```json
{
  "name": "orderpulse-server",
  "version": "1.0.0",
  "type": "module",
  "description": "OrderPulse Backend API - Production-ready Gmail OAuth and Gemini AI proxy",
  "main": "dist/index.js",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "db:migrate": "tsx src/db/migrate.ts",
    "db:migrate:incremental": "tsx src/db/migrateIncremental.ts",
    "cognito:ensure-user": "tsx src/scripts/ensureCognitoUser.ts",
    "test": "vitest run"
  },
  "engines": {
    "node": ">=20"
  },
  "dependencies": {
    "@aws-sdk/client-cognito-identity-provider": "^3.992.0",
    "@google/generative-ai": "^0.21.0",
    "@sentry/node": "^10.38.0",
    "amazon-paapi": "^1.0.7",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^2.9.0",
    "compression": "^1.7.4",
    "connect-redis": "^7.1.1",
    "cors": "^2.8.5",
    "crypto-js": "^4.2.0",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "express-rate-limit": "^7.5.1",
    "express-session": "^1.18.0",
    "googleapis": "^140.0.1",
    "helmet": "^7.1.0",
    "ioredis": "^5.4.1",
    "pdf-parse": "^2.2.2",
    "pg": "^8.12.0",
    "pino": "^9.5.0",
    "pino-http": "^10.4.0",
    "playwright": "^1.58.2",
    "uuid": "^10.0.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/compression": "^1.8.1",
    "@types/connect-redis": "^0.0.23",
    "@types/cors": "^2.8.17",
    "@types/crypto-js": "^4.2.2",
    "@types/express": "^4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "^22.5.0",
    "@types/pg": "^8.11.6",
    "@types/uuid": "^10.0.0",
    "tsx": "^4.19.0",
    "typescript": "^5.5.4",
    "vitest": "^3.2.4"
  }
}

```

### `server/railway.json`

```json
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS",
    "buildCommand": "npm install && npm run build",
    "env": {
      "NIXPACKS_NODE_VERSION": "20"
    }
  },
  "deploy": {
    "startCommand": "npm start",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}

```

### `server/src/config.ts`

```typescript
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),
  PORT: z.coerce.number().optional(),
  FRONTEND_URL: z.string().url().optional(),
  BACKEND_URL: z.string().url().optional(),
  SESSION_SECRET: z.string().min(10).optional(),
  ENCRYPTION_KEY: z.string().min(16).optional(),
  GOOGLE_CLIENT_ID: z.string().optional(),
  GOOGLE_CLIENT_SECRET: z.string().optional(),
  GEMINI_API_KEY: z.string().optional(),
  ARDA_TENANT_ID: z.string().optional(),
  ARDA_API_KEY: z.string().optional(),
  ARDA_BASE_URL: z.string().url().optional(),
  ARDA_MOCK_MODE: z.enum(['true', 'false']).optional(),
  REDIS_URL: z.string().optional(),
  DATABASE_URL: z.string().optional(),
  SENTRY_DSN: z.string().optional(),
  SENTRY_TRACES_SAMPLE_RATE: z.coerce.number().optional(),
  RATE_LIMIT_WINDOW_MS: z.coerce.number().optional(),
  RATE_LIMIT_MAX: z.coerce.number().optional(),
  ENABLE_COGNITO_SYNC: z.enum(['true', 'false']).optional(),
  COGNITO_SYNC_HOUR: z.coerce.number().min(0).max(23).optional(),
  GITHUB_COGNITO_TOKEN: z.string().optional(),
  AMAZON_ACCESS_KEY: z.string().optional(),
  AMAZON_SECRET_KEY: z.string().optional(),
  AMAZON_PARTNER_TAG: z.string().optional(),
  POSTMARK_INBOUND_USERNAME: z.string().optional(),
  POSTMARK_INBOUND_PASSWORD: z.string().optional(),
  INBOUND_CONFIDENCE_THRESHOLD: z.coerce.number().min(0).max(1).optional(),
  INBOUND_PROCESS_BATCH_SIZE: z.coerce.number().min(1).max(100).optional(),
  INBOUND_MAX_RETRIES: z.coerce.number().min(1).max(20).optional(),
  INBOUND_RETENTION_DAYS: z.coerce.number().min(1).max(365).optional(),
  BARCODE_LOOKUP_API_KEY: z.string().optional(),
  BARCODE_LOOKUP_USER_AGENT: z.string().optional(),
  UPCITEMDB_USER_KEY: z.string().optional(),
  UPCITEMDB_KEY_TYPE: z.enum(['3scale', 'rapidapi', 'rapidapi-free']).optional(),
  ENABLE_ACCOUNTING_CONNECTORS: z.enum(['true', 'false']).optional(),
  ACCOUNTING_SYNC_INTERVAL_MINUTES: z.coerce.number().min(1).max(1440).optional(),
  QUICKBOOKS_CLIENT_ID: z.string().optional(),
  QUICKBOOKS_CLIENT_SECRET: z.string().optional(),
  QUICKBOOKS_WEBHOOK_VERIFIER_TOKEN: z.string().optional(),
  XERO_CLIENT_ID: z.string().optional(),
  XERO_CLIENT_SECRET: z.string().optional(),
});

const parsed = envSchema.safeParse(process.env);
if (!parsed.success) {
  console.error('❌ Invalid environment configuration', parsed.error.format());
  throw new Error('Invalid environment configuration');
}

export const env = parsed.data;
export const isProduction = env.NODE_ENV === 'production';
export const allowInMemoryStorage = env.NODE_ENV !== 'production' || process.env.ALLOW_INMEMORY_STORAGE === 'true';
export const port = env.PORT || 3001;

// CORS origin - require FRONTEND_URL in production, allow localhost only in development
export const corsOrigin = (() => {
  if (env.FRONTEND_URL) {
    return env.FRONTEND_URL;
  }
  if (isProduction) {
    console.warn('⚠️ FRONTEND_URL not set in production - CORS may block requests');
    // Return a permissive pattern for Vercel preview deployments
    return /^https:\/\/.*\.vercel\.app$|^https:\/\/order-pulse.*\.vercel\.app$/;
  }
  return 'http://localhost:5173';
})();

export const rateLimitConfig = {
  windowMs: env.RATE_LIMIT_WINDOW_MS ?? 60_000, // default 1 minute
  max: env.RATE_LIMIT_MAX ?? 120, // 120 req/min per IP
};

export const requireRedis = isProduction && !allowInMemoryStorage;
export const enableAccountingConnectors = env.ENABLE_ACCOUNTING_CONNECTORS === 'true';
export const accountingSyncIntervalMinutes = env.ACCOUNTING_SYNC_INTERVAL_MINUTES ?? 15;

```

### `server/src/db/index.ts`

```typescript
import pg, { QueryResultRow } from 'pg';
import dotenv from 'dotenv';

dotenv.config();

const { Pool } = pg;

export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});

// Test connection on startup
pool.query('SELECT NOW()')
  .then(() => console.log('✅ Database connected'))
  .catch((err) => console.error('❌ Database connection failed:', err.message));

export async function query<T extends QueryResultRow = QueryResultRow>(text: string, params?: any[]): Promise<pg.QueryResult<T>> {
  const start = Date.now();
  const result = await pool.query<T>(text, params);
  const duration = Date.now() - start;
  if (duration > 100) {
    console.log('Slow query:', { text: text.substring(0, 100), duration, rows: result.rowCount });
  }
  return result;
}

```

### `server/src/db/migrate.ts`

```typescript
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { pool } from './index.js';
import dotenv from 'dotenv';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function migrate() {
  console.log('🔄 Running database migrations...');
  
  const schemaPath = path.join(__dirname, 'schema.sql');
  const schema = fs.readFileSync(schemaPath, 'utf-8');
  
  try {
    await pool.query(schema);
    console.log('✅ Database migrations completed successfully');
  } catch (error) {
    console.error('❌ Migration failed:', error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

migrate();

```

### `server/src/db/schema.sql`

```sql
-- OrderPulse Database Schema
-- PostgreSQL

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  google_id VARCHAR(255) UNIQUE NOT NULL,
  email VARCHAR(255) NOT NULL,
  name VARCHAR(255),
  picture_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- OAuth tokens (encrypted at rest)
CREATE TABLE IF NOT EXISTS oauth_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  access_token_encrypted TEXT NOT NULL,
  refresh_token_encrypted TEXT NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id)
);

-- Extracted orders
CREATE TABLE IF NOT EXISTS orders (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  original_email_id VARCHAR(255),
  supplier VARCHAR(255),
  order_date DATE,
  total_amount DECIMAL(10,2),
  confidence DECIMAL(3,2),
  raw_data JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Order line items
CREATE TABLE IF NOT EXISTS order_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  order_id UUID REFERENCES orders(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  quantity INTEGER NOT NULL,
  unit VARCHAR(50),
  unit_price DECIMAL(10,2),
  total_price DECIMAL(10,2)
);

-- Indices for query performance
CREATE INDEX IF NOT EXISTS idx_users_google_id ON users(google_id);
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);
CREATE INDEX IF NOT EXISTS idx_orders_date ON orders(order_date);
CREATE INDEX IF NOT EXISTS idx_orders_supplier ON orders(supplier);
CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON order_items(order_id);
CREATE INDEX IF NOT EXISTS idx_tokens_user_id ON oauth_tokens(user_id);

-- Inbound forwarded receipt ingestion
CREATE TABLE IF NOT EXISTS inbound_receipts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider VARCHAR(50) NOT NULL DEFAULT 'postmark',
  provider_message_id TEXT,
  message_id TEXT,
  idempotency_key TEXT NOT NULL,
  from_email VARCHAR(320) NOT NULL,
  from_name TEXT,
  subject TEXT,
  source_recipient VARCHAR(320),
  email_date TIMESTAMP WITH TIME ZONE,
  raw_headers JSONB,
  raw_text_body TEXT,
  raw_html_body TEXT,
  content_hash TEXT NOT NULL,
  status VARCHAR(32) NOT NULL DEFAULT 'received' CHECK (status IN ('received', 'processing', 'retry', 'quarantined', 'synced', 'failed')),
  guardrail_reason TEXT,
  resolved_user_email VARCHAR(320),
  resolved_author TEXT,
  resolved_tenant_id TEXT,
  extracted_data JSONB,
  arda_order_record_id TEXT,
  arda_item_record_ids JSONB,
  duplicate_of_event_id UUID REFERENCES inbound_receipts(id),
  attempt_count INTEGER NOT NULL DEFAULT 0,
  next_attempt_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  last_error TEXT,
  processed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS inbound_receipt_attempts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  receipt_id UUID NOT NULL REFERENCES inbound_receipts(id) ON DELETE CASCADE,
  attempt_number INTEGER NOT NULL,
  status VARCHAR(32) NOT NULL CHECK (status IN ('processing', 'retry', 'quarantined', 'synced', 'failed')),
  error TEXT,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_inbound_receipts_idempotency_key ON inbound_receipts(idempotency_key);
CREATE UNIQUE INDEX IF NOT EXISTS idx_inbound_receipts_provider_message ON inbound_receipts(provider, provider_message_id) WHERE provider_message_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_inbound_receipts_status_next_attempt ON inbound_receipts(status, next_attempt_at);
CREATE INDEX IF NOT EXISTS idx_inbound_receipts_created_at ON inbound_receipts(created_at);
CREATE INDEX IF NOT EXISTS idx_inbound_receipts_resolved_message ON inbound_receipts(resolved_user_email, message_id) WHERE message_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_inbound_receipts_resolved_hash ON inbound_receipts(resolved_user_email, content_hash);
CREATE INDEX IF NOT EXISTS idx_inbound_receipt_attempts_receipt_id ON inbound_receipt_attempts(receipt_id);

-- Accounting provider integrations (QuickBooks / Xero)
CREATE TABLE IF NOT EXISTS provider_connections (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id TEXT NOT NULL,
  provider VARCHAR(32) NOT NULL CHECK (provider IN ('quickbooks', 'xero')),
  tenant_id TEXT NOT NULL,
  tenant_name TEXT,
  access_token_encrypted TEXT NOT NULL,
  refresh_token_encrypted TEXT NOT NULL,
  token_expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  scope TEXT,
  status VARCHAR(32) NOT NULL DEFAULT 'connected' CHECK (status IN ('connected', 'reauth_required', 'error', 'disconnected')),
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, provider)
);

CREATE TABLE IF NOT EXISTS provider_sync_state (
  connection_id UUID PRIMARY KEY REFERENCES provider_connections(id) ON DELETE CASCADE,
  backfill_started_at TIMESTAMP WITH TIME ZONE,
  backfill_completed_at TIMESTAMP WITH TIME ZONE,
  last_cursor_utc TIMESTAMP WITH TIME ZONE,
  cursor_payload JSONB,
  last_successful_sync_at TIMESTAMP WITH TIME ZONE,
  last_error TEXT,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS provider_sync_runs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  connection_id UUID NOT NULL REFERENCES provider_connections(id) ON DELETE CASCADE,
  "trigger" VARCHAR(32) NOT NULL CHECK ("trigger" IN ('manual', 'scheduled', 'webhook', 'backfill')),
  status VARCHAR(32) NOT NULL CHECK (status IN ('running', 'success', 'failed')),
  orders_upserted INTEGER NOT NULL DEFAULT 0,
  orders_deleted INTEGER NOT NULL DEFAULT 0,
  items_upserted INTEGER NOT NULL DEFAULT 0,
  api_calls INTEGER NOT NULL DEFAULT 0,
  started_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  finished_at TIMESTAMP WITH TIME ZONE,
  error TEXT
);

-- Backward compatibility for older installs that used run_trigger.
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'provider_sync_runs'
      AND column_name = 'run_trigger'
  ) AND NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'provider_sync_runs'
      AND column_name = 'trigger'
  ) THEN
    ALTER TABLE provider_sync_runs RENAME COLUMN run_trigger TO "trigger";
  END IF;
END;
$$;

CREATE TABLE IF NOT EXISTS provider_webhook_events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider VARCHAR(32) NOT NULL CHECK (provider IN ('quickbooks', 'xero')),
  provider_event_id TEXT NOT NULL,
  connection_id UUID REFERENCES provider_connections(id) ON DELETE SET NULL,
  signature_valid BOOLEAN NOT NULL DEFAULT false,
  payload JSONB NOT NULL,
  status VARCHAR(32) NOT NULL DEFAULT 'received' CHECK (status IN ('received', 'processed', 'ignored', 'failed')),
  received_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  processed_at TIMESTAMP WITH TIME ZONE
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_provider_connections_user_provider ON provider_connections(user_id, provider);
CREATE INDEX IF NOT EXISTS idx_provider_connections_provider_tenant ON provider_connections(provider, tenant_id);
CREATE INDEX IF NOT EXISTS idx_provider_sync_runs_connection_started ON provider_sync_runs(connection_id, started_at DESC);
CREATE INDEX IF NOT EXISTS idx_provider_sync_runs_status ON provider_sync_runs(status);
CREATE UNIQUE INDEX IF NOT EXISTS idx_provider_webhook_event_unique ON provider_webhook_events(provider, provider_event_id);
CREATE INDEX IF NOT EXISTS idx_provider_webhook_connection_status ON provider_webhook_events(connection_id, status);

-- Updated at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply trigger to users
DROP TRIGGER IF EXISTS update_users_updated_at ON users;
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to oauth_tokens
DROP TRIGGER IF EXISTS update_oauth_tokens_updated_at ON oauth_tokens;
CREATE TRIGGER update_oauth_tokens_updated_at
  BEFORE UPDATE ON oauth_tokens
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to inbound_receipts
DROP TRIGGER IF EXISTS update_inbound_receipts_updated_at ON inbound_receipts;
CREATE TRIGGER update_inbound_receipts_updated_at
  BEFORE UPDATE ON inbound_receipts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to provider_connections
DROP TRIGGER IF EXISTS update_provider_connections_updated_at ON provider_connections;
CREATE TRIGGER update_provider_connections_updated_at
  BEFORE UPDATE ON provider_connections
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to provider_sync_state
DROP TRIGGER IF EXISTS update_provider_sync_state_updated_at ON provider_sync_state;
CREATE TRIGGER update_provider_sync_state_updated_at
  BEFORE UPDATE ON provider_sync_state
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

```

### `server/src/index.ts`

```typescript
import './utils/loadEnv.js';
import express from 'express';
import cors from 'cors';
import session from 'express-session';
import RedisStore from 'connect-redis';
import * as Sentry from '@sentry/node';
import compression from 'compression';
import redisClient, { closeRedisClient } from './utils/redisClient.js';
import { authRouter } from './routes/auth.js';
import { gmailRouter } from './routes/gmail.js';
import { analysisRouter } from './routes/analysis.js';
import { ordersRouter } from './routes/orders.js';
import { jobsRouter } from './routes/jobs.js';
import { discoverRouter } from './routes/discover.js';
import { amazonRouter } from './routes/amazon.js';
import ardaRouter from './routes/arda.js';
import cognitoRouter from './routes/cognito.js';
import scanRouter from './routes/scan.js';
import photoRouter from './routes/photo.js';
import { urlIngestionRouter } from './routes/urlIngestion.js';
import { integrationsRouter } from './routes/integrations.js';
import { cognitoService } from './services/cognito.js';
import { initializeJobManager, shutdownJobManager } from './services/jobManager.js';
import { startCognitoSyncScheduler, stopCognitoSyncScheduler } from './services/cognitoScheduler.js';
import inboundEmailRouter from './routes/inboundEmail.js';
import { startInboundReceiptWorker, stopInboundReceiptWorker } from './services/inboundReceiptWorker.js';
import { startProviderSyncScheduler, stopProviderSyncScheduler } from './services/integrations/syncScheduler.js';
import { appLogger, requestLogger } from './middleware/requestLogger.js';
import { securityHeaders } from './middleware/securityHeaders.js';
import { defaultLimiter, authLimiter } from './middleware/rateLimiter.js';
import { errorHandler } from './middleware/errorHandler.js';
import { corsOrigin, isProduction, port, requireRedis } from './config.js';

// Debug: Log OAuth config status
console.log('🔐 OAuth Config:', {
  clientId: process.env.GOOGLE_CLIENT_ID ? `${process.env.GOOGLE_CLIENT_ID.substring(0, 20)}...` : '❌ MISSING',
  clientSecret: process.env.GOOGLE_CLIENT_SECRET ? '✓ Set' : '❌ MISSING',
  geminiKey: process.env.GEMINI_API_KEY ? '✓ Set' : '❌ MISSING',
  ardaTenant: process.env.ARDA_TENANT_ID ? '✓ Set' : '❌ MISSING',
});

const app = express();
let server: ReturnType<typeof app.listen> | null = null;
let isShuttingDown = false;
const sentryDsn = process.env.SENTRY_DSN;
if (sentryDsn) {
  Sentry.init({
    dsn: sentryDsn,
    environment: process.env.NODE_ENV || 'development',
    tracesSampleRate: Number(process.env.SENTRY_TRACES_SAMPLE_RATE) || 0.1,
  });
}
const PORT = port;
const requiredSecrets = [
  'SESSION_SECRET',
  'ENCRYPTION_KEY',
  'GOOGLE_CLIENT_ID',
  'GOOGLE_CLIENT_SECRET',
  'GEMINI_API_KEY',
  'ARDA_TENANT_ID',
  'ARDA_API_KEY',
  'DATABASE_URL',
  'BACKEND_URL',
  'FRONTEND_URL',
];
for (const key of requiredSecrets) {
  if (!process.env[key]) {
    const message = `${key} is recommended to run OrderPulse`;
    if (isProduction) {
      throw new Error(`${key} is required in production`);
    }
    console.warn(`⚠️ ${message}`);
  }
}
if (isProduction && !process.env.REDIS_URL) {
  console.warn('⚠️ REDIS_URL not set in production - sessions will not persist across restarts');
}

if (requireRedis && !redisClient) {
  throw new Error('REDIS_URL is required in production; in-memory storage is disabled');
}

// Trust proxy for Railway (required for secure cookies behind reverse proxy)
if (isProduction) {
  app.set('trust proxy', 1);
}

const sessionSecret = process.env.SESSION_SECRET || 'dev-secret-change-in-production';
// @ts-expect-error connect-redis types are slightly out of sync with express-session
const sessionStore = redisClient ? new RedisStore({ client: redisClient }) : undefined;

// Core middleware
app.use(requestLogger);
app.use(securityHeaders);
app.use(cors({
  origin: corsOrigin,
  credentials: true,
}));
app.use(compression());
// Increase body parser limit for large email payloads (500 emails can be ~10MB)
app.use(express.json({
  limit: '50mb',
  verify: (req, _res, buf) => {
    (req as any).rawBody = buf.toString('utf8');
  },
}));
app.use(express.urlencoded({ limit: '50mb', extended: true }));

// Session configuration
app.use(session({
  store: sessionStore,
  secret: sessionSecret,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: isProduction,
    httpOnly: true,
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    sameSite: isProduction ? 'none' : 'lax',
  },
}));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// API routes (rate-limited where appropriate)
app.use('/auth', authLimiter, authRouter);
app.use('/api/gmail', gmailRouter);
app.use('/api/analyze', analysisRouter);
app.use('/api/orders', ordersRouter);
app.use('/api/arda', ardaRouter);
app.use('/api/jobs', defaultLimiter, jobsRouter);
app.use('/api/cognito', cognitoRouter);
app.use('/api/discover', defaultLimiter, discoverRouter);
app.use('/api/amazon', amazonRouter);
app.use('/api/scan', scanRouter);
app.use('/api/barcode', scanRouter); // Also mount at /api/barcode for lookup endpoint
app.use('/api/photo', photoRouter);
app.use('/api/url-ingestion', defaultLimiter, urlIngestionRouter);
app.use('/api/inbound', inboundEmailRouter);
app.use('/api/integrations', defaultLimiter, integrationsRouter);

// Error handler
app.use(errorHandler);

async function shutdown(reason: string, exitCode = 0): Promise<void> {
  if (isShuttingDown) return;
  isShuttingDown = true;

  appLogger.warn({ reason }, '⚠️ Initiating graceful shutdown');

  stopCognitoSyncScheduler();
  stopInboundReceiptWorker();
  stopProviderSyncScheduler();
  shutdownJobManager();

  // Stop accepting new connections
  await new Promise<void>((resolve) => {
    if (server) {
      server.close(() => resolve());
    } else {
      resolve();
    }
  });

  await closeRedisClient();

  // Flush Sentry (if enabled)
  await Sentry.close(2000).catch(() => undefined);

  process.exit(exitCode);
}

async function startServer() {
  await initializeJobManager();

  server = app.listen(PORT, () => {
    appLogger.info(`🚀 OrderPulse API running on port ${PORT}`);
    appLogger.info(`📧 Frontend URL: ${process.env.FRONTEND_URL || '(not set - using fallback CORS)'}`);
    appLogger.info(`🌍 Environment: ${process.env.NODE_ENV || 'development'}`);
    
    startCognitoSyncScheduler();
    startInboundReceiptWorker();
    startProviderSyncScheduler();
    
    const status = cognitoService.getSyncStatus();
    appLogger.info(`👥 Cognito users: ${status.userCount} loaded`);
  });
}

startServer().catch((error) => {
  console.error('Failed to start OrderPulse API:', error);
  void shutdown('startup-failure', 1);
});

process.on('SIGTERM', () => { void shutdown('SIGTERM'); });
process.on('SIGINT', () => { void shutdown('SIGINT'); });
process.on('unhandledRejection', (reason) => {
  appLogger.error({ err: reason }, 'Unhandled promise rejection');
  void shutdown('unhandledRejection', 1);
});
process.on('uncaughtException', (error) => {
  appLogger.error({ err: error }, 'Uncaught exception');
  void shutdown('uncaughtException', 1);
});

export default app;

```

### `server/src/middleware/errorHandler.ts`

```typescript
import type { ErrorRequestHandler } from 'express';
import * as Sentry from '@sentry/node';
import { env } from '../config.js';
import { appLogger } from './requestLogger.js';

export const errorHandler: ErrorRequestHandler = (err, req, res, _next) => {
  const status = err.status || err.statusCode || 500;
  const message = status >= 500 ? 'Internal server error' : err.message || 'Request failed';

  appLogger.error({ err, path: req.path, status }, 'Request failed');
  if (env.SENTRY_DSN) {
    Sentry.captureException(err);
  }

  res.status(status).json({ error: message });
};

```

### `server/src/middleware/rateLimiter.ts`

```typescript
import rateLimit from 'express-rate-limit';
import { rateLimitConfig } from '../config.js';

export const defaultLimiter = rateLimit({
  windowMs: rateLimitConfig.windowMs,
  max: rateLimitConfig.max,
  standardHeaders: true,
  legacyHeaders: false,
});

export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 30,
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many authentication attempts. Please try again later.',
});

```

### `server/src/middleware/requestLogger.ts`

```typescript
import pino from 'pino';
import pinoHttpPkg from 'pino-http';
import { env } from '../config.js';

// Handle ESM/CJS interop
const pinoHttp = (pinoHttpPkg as any).default || pinoHttpPkg;

const logger = pino({
  level: env.NODE_ENV === 'production' ? 'info' : 'debug',
  transport: env.NODE_ENV === 'production' ? undefined : { target: 'pino-pretty' },
});

export const requestLogger = pinoHttp({
  logger,
  redact: ['req.headers.authorization', 'req.headers.cookie'],
  autoLogging: {
    ignorePaths: ['/health', '/ready'],
  },
});

export const appLogger = logger;

```

### `server/src/middleware/securityHeaders.ts`

```typescript
import helmet from 'helmet';

export const securityHeaders = helmet({
  contentSecurityPolicy: false, // disable strict CSP to avoid blocking inline styles in email processing; consider tightening later
  crossOriginEmbedderPolicy: false,
});

```

### `server/src/routes/amazon.ts`

```typescript
// Amazon Product Advertising API Routes
import { Router, Request, Response } from 'express';
import { amazonService } from '../services/amazon.js';

const router = Router();

// Middleware to require authentication
async function requireAuth(req: Request, res: Response, next: Function) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  next();
}

// Health check
router.get('/health', (req: Request, res: Response) => {
  res.json({ 
    status: 'ok', 
    router: 'amazon',
    timestamp: new Date().toISOString() 
  });
});

// Enrich a single ASIN
router.get('/item/:asin', requireAuth, async (req: Request, res: Response) => {
  try {
    const { asin } = req.params;
    
    if (!asin || !/^[A-Z0-9]{10}$/i.test(asin)) {
      return res.status(400).json({ error: 'Invalid ASIN format' });
    }
    
    console.log(`🛒 Enriching single ASIN: ${asin}`);
    const data = await amazonService.enrichItemWithAmazon(asin);
    
    if (!data) {
      return res.status(404).json({ error: 'Item not found' });
    }
    
    res.json({ item: data });
  } catch (error: any) {
    console.error('Amazon item fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch Amazon item' });
  }
});

// Batch enrich multiple ASINs
router.post('/items', requireAuth, async (req: Request, res: Response) => {
  try {
    const { asins } = req.body;
    
    if (!asins || !Array.isArray(asins)) {
      return res.status(400).json({ error: 'asins must be an array' });
    }
    
    // Validate and filter ASINs
    const validAsins = asins
      .filter((asin: string) => typeof asin === 'string' && /^[A-Z0-9]{10}$/i.test(asin))
      .slice(0, 50); // Limit to 50 items per request
    
    if (validAsins.length === 0) {
      return res.status(400).json({ error: 'No valid ASINs provided' });
    }
    
    console.log(`🛒 Batch enriching ${validAsins.length} ASINs`);
    const results = await amazonService.batchEnrichItems(validAsins);
    
    // Convert Map to object for JSON response
    const items: Record<string, any> = {};
    for (const [asin, data] of results) {
      items[asin] = data;
    }
    
    res.json({ 
      items,
      requested: validAsins.length,
      found: results.size,
    });
  } catch (error: any) {
    console.error('Amazon batch fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch Amazon items' });
  }
});

// Extract ASINs from text (for testing)
router.post('/extract-asins', requireAuth, async (req: Request, res: Response) => {
  try {
    const { text, subject } = req.body;
    
    if (!text) {
      return res.status(400).json({ error: 'text is required' });
    }
    
    const asins = amazonService.extractAsinsFromEmail(text, subject || '');
    
    res.json({ asins });
  } catch (error: any) {
    console.error('ASIN extraction error:', error);
    res.status(500).json({ error: 'Failed to extract ASINs' });
  }
});

export { router as amazonRouter };

```

### `server/src/routes/analysis.ts`

```typescript
import { Router, Request, Response } from 'express';
import {
  analyzeEmailWithRetry,
  createGeminiExtractionModel,
  delay,
  EmailExtractionInput,
} from '../services/emailExtraction.js';

const router = Router();

// Middleware to require authentication
function requireAuth(req: Request, res: Response, next: Function) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  next();
}

// Analyze email with Gemini AI
router.post('/', requireAuth, async (req: Request, res: Response) => {
  try {
    const { emails } = req.body;

    if (!Array.isArray(emails) || emails.length === 0) {
      return res.status(400).json({ error: 'Missing emails array' });
    }

    console.log(`🧠 Analyzing ${emails.length} emails with Gemini AI...`);

    const model = createGeminiExtractionModel();

    // Process emails sequentially to avoid rate limits
    const results: unknown[] = [];
    for (let i = 0; i < emails.length; i++) {
      const email = emails[i] as EmailExtractionInput;
      const result = await analyzeEmailWithRetry(model as any, email);
      results.push(result);

      // Small delay between requests to avoid rate limiting
      if (i < emails.length - 1) {
        await delay(100);
      }
    }

    console.log(`✅ Analyzed ${results.length} emails`);
    res.json({ results });
  } catch (error: any) {
    console.error('Gemini analysis error:', error);
    res.status(500).json({ error: 'Failed to analyze emails' });
  }
});

export { router as analysisRouter };

```

### `server/src/routes/arda.test.ts`

```typescript
import express from 'express';
import { AddressInfo } from 'node:net';
import type { Server } from 'node:http';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const originalEnv = process.env;

const mockGetUserEmail = vi.fn();
const mockGetUserByEmail = vi.fn();
const mockGetSyncStatus = vi.fn();
const mockFindTenantSuggestionForEmail = vi.fn();
const mockSyncUsersOnDemand = vi.fn();
const mockEnsureUserMappingForEmail = vi.fn();

const mockCreateItem = vi.fn();
const mockCreateKanbanCard = vi.fn();
const mockCreateOrder = vi.fn();
const mockCreateItemFromVelocity = vi.fn();
const mockNamedSyncVelocityToArda = vi.fn();
const mockServiceSyncVelocityToArda = vi.fn();
const mockProvisionUserForEmail = vi.fn();
const mockIsConfigured = vi.fn();

vi.mock('./auth.js', () => ({
  getUserEmail: mockGetUserEmail,
}));

vi.mock('../services/cognito.js', () => ({
  cognitoService: {
    getUserByEmail: mockGetUserByEmail,
    getSyncStatus: mockGetSyncStatus,
    findTenantSuggestionForEmail: mockFindTenantSuggestionForEmail,
    syncUsersOnDemand: mockSyncUsersOnDemand,
    ensureUserMappingForEmail: mockEnsureUserMappingForEmail,
  },
}));

vi.mock('../services/imageUpload.js', () => ({
  ensureHostedUrl: vi.fn(async (url: string) => url),
  isDataUrl: vi.fn(() => false),
}));

vi.mock('../services/arda.js', () => ({
  ardaService: {
    isConfigured: mockIsConfigured,
    getTenantByEmail: vi.fn(),
    createItem: mockCreateItem,
    createKanbanCard: mockCreateKanbanCard,
    createOrder: mockCreateOrder,
    syncVelocityToArda: mockServiceSyncVelocityToArda,
    provisionUserForEmail: mockProvisionUserForEmail,
  },
  createItemFromVelocity: mockCreateItemFromVelocity,
  syncVelocityToArda: mockNamedSyncVelocityToArda,
}));

async function startTestServer(sessionUserId?: string): Promise<{ server: Server; baseUrl: string }> {
  const { default: ardaRouter } = await import('./arda.js');

  const app = express();
  app.use(express.json());
  const sessionData = sessionUserId ? { userId: sessionUserId } : {};
  app.use((req, _res, next) => {
    (req as any).session = sessionData;
    next();
  });
  app.use('/api/arda', ardaRouter);

  const server = app.listen(0);
  await new Promise<void>((resolve) => server.once('listening', resolve));

  const address = server.address() as AddressInfo;
  return {
    server,
    baseUrl: `http://127.0.0.1:${address.port}`,
  };
}

describe('arda routes credential resolution', () => {
  let server: Server | null = null;
  let baseUrl = '';

  beforeEach(() => {
    vi.resetModules();
    vi.clearAllMocks();
    process.env = { ...originalEnv };

    mockGetSyncStatus.mockReturnValue({ userCount: 42, lastSync: '2026-02-17T00:00:00.000Z' });
    mockFindTenantSuggestionForEmail.mockReturnValue(null);
    mockSyncUsersOnDemand.mockResolvedValue(false);
    mockCreateItem.mockResolvedValue({ rId: 'record-1' });
    mockCreateKanbanCard.mockResolvedValue({ rId: 'record-2' });
    mockCreateOrder.mockResolvedValue({ rId: 'record-3' });
    mockCreateItemFromVelocity.mockResolvedValue({ rId: 'record-4' });
    mockNamedSyncVelocityToArda.mockResolvedValue([]);
    mockServiceSyncVelocityToArda.mockResolvedValue([]);
    mockProvisionUserForEmail.mockResolvedValue(null);
    mockIsConfigured.mockReturnValue(true);
    mockEnsureUserMappingForEmail.mockResolvedValue(true);
  });

  afterEach(async () => {
    process.env = originalEnv;
    if (server) {
      await new Promise<void>((resolve, reject) => {
        server?.close((err) => (err ? reject(err) : resolve()));
      });
      server = null;
    }
  });

  it('attempts auto-provision and returns TENANT_REQUIRED with auto-provision details when provisioning fails', async () => {
    mockGetUserEmail.mockResolvedValue('auth-user@example.com');
    mockGetUserByEmail.mockReturnValue(null);

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const response = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Filters', primarySupplier: 'Acme' }),
    });

    const data = await response.json() as {
      success?: boolean;
      code?: string;
      details?: {
        email?: string;
        canCreateTenant?: boolean;
        autoProvisionAttempted?: boolean;
        autoProvisionSucceeded?: boolean;
        autoProvisionError?: string;
      };
    };
    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.code).toBe('TENANT_REQUIRED');
    expect(data.details?.email).toBe('auth-user@example.com');
    expect(data.details?.canCreateTenant).toBe(true);
    expect(data.details?.autoProvisionAttempted).toBe(true);
    expect(data.details?.autoProvisionSucceeded).toBe(false);
    expect(data.details?.autoProvisionError).toContain('did not return tenant credentials');
    expect(mockCreateItem).not.toHaveBeenCalled();
    expect(mockProvisionUserForEmail).toHaveBeenCalledWith('auth-user@example.com');
    expect(mockGetUserByEmail).toHaveBeenCalledWith('auth-user@example.com');
  });

  it('auto-provisions tenant during authenticated write when mapping is missing', async () => {
    mockGetUserEmail.mockResolvedValue('new-user@example.com');
    mockGetUserByEmail.mockReturnValue(null);
    mockProvisionUserForEmail.mockResolvedValue({
      author: 'provisioned-sub',
      email: 'new-user@example.com',
      tenantId: 'provisioned-tenant',
    });

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const response = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Auto Item', primarySupplier: 'Auto Supplier' }),
    });

    expect(response.status).toBe(200);
    expect(mockProvisionUserForEmail).toHaveBeenCalledWith('new-user@example.com');
    expect(mockEnsureUserMappingForEmail).toHaveBeenCalledWith(
      'new-user@example.com',
      'provisioned-tenant',
      expect.objectContaining({ role: 'User', suppressMessage: true })
    );
    expect(mockCreateItem).toHaveBeenCalledWith(
      expect.objectContaining({ name: 'Auto Item', primarySupplier: 'Auto Supplier' }),
      {
        author: 'provisioned-sub',
        email: 'new-user@example.com',
        tenantId: 'provisioned-tenant',
      }
    );
  });

  it('refreshes Cognito mapping on-demand when tenant is missing', async () => {
    mockGetUserEmail.mockResolvedValue('mapped@example.com');
    mockGetUserByEmail
      .mockReturnValueOnce(null)
      .mockReturnValueOnce({ email: 'mapped@example.com', tenantId: 'tenant-123', sub: 'author-123' });
    mockSyncUsersOnDemand.mockResolvedValue(true);

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const response = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Towels', primarySupplier: 'Warehouse' }),
    });

    expect(response.status).toBe(200);
    expect(mockSyncUsersOnDemand).toHaveBeenCalledWith('missing-tenant');
    expect(mockCreateItem).toHaveBeenCalledWith(
      expect.objectContaining({ name: 'Towels', primarySupplier: 'Warehouse' }),
      { author: 'author-123', email: 'mapped@example.com', tenantId: 'tenant-123' }
    );
  });

  it('resolves tenant via create_new and reuses session override for subsequent writes', async () => {
    mockGetUserEmail.mockResolvedValue('new-user@example.com');
    mockGetUserByEmail.mockReturnValue(null);
    mockProvisionUserForEmail.mockResolvedValue({
      author: 'provisioned-sub',
      email: 'new-user@example.com',
      tenantId: 'provisioned-tenant',
    });

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const resolveResponse = await fetch(`${baseUrl}/api/arda/tenant/resolve`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'create_new' }),
    });
    const resolveData = await resolveResponse.json() as { success: boolean; tenantId?: string };

    expect(resolveResponse.status).toBe(200);
    expect(resolveData.success).toBe(true);
    expect(resolveData.tenantId).toBe('provisioned-tenant');
    expect(mockProvisionUserForEmail).toHaveBeenCalledWith('new-user@example.com');
    expect(mockEnsureUserMappingForEmail).toHaveBeenCalledWith(
      'new-user@example.com',
      'provisioned-tenant',
      expect.objectContaining({ role: 'User', suppressMessage: true })
    );

    const response = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Auto Item', primarySupplier: 'Auto Supplier' }),
    });

    expect(response.status).toBe(200);
    expect(mockCreateItem).toHaveBeenCalledWith(
      expect.objectContaining({ name: 'Auto Item', primarySupplier: 'Auto Supplier' }),
      {
        author: 'provisioned-sub',
        email: 'new-user@example.com',
        tenantId: 'provisioned-tenant',
      }
    );
  });

  it('returns ARDA_NOT_CONFIGURED when create_new is requested without API configuration', async () => {
    mockGetUserEmail.mockResolvedValue('new-user@example.com');
    mockGetUserByEmail.mockReturnValue(null);
    mockIsConfigured.mockReturnValue(false);

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const resolveResponse = await fetch(`${baseUrl}/api/arda/tenant/resolve`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'create_new' }),
    });
    const resolveData = await resolveResponse.json() as { success: boolean; code?: string; error?: string };

    expect(resolveResponse.status).toBe(503);
    expect(resolveData.success).toBe(false);
    expect(resolveData.code).toBe('ARDA_NOT_CONFIGURED');
    expect(resolveData.error).toContain('ARDA_API_KEY');
    expect(mockProvisionUserForEmail).not.toHaveBeenCalled();
  });

  it('returns TENANT_PROVISION_FAILED when create_new provisioning does not return tenant credentials', async () => {
    mockGetUserEmail.mockResolvedValue('new-user@example.com');
    mockGetUserByEmail.mockReturnValue(null);
    mockProvisionUserForEmail.mockResolvedValue(null);

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const resolveResponse = await fetch(`${baseUrl}/api/arda/tenant/resolve`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'create_new' }),
    });
    const resolveData = await resolveResponse.json() as {
      success: boolean;
      code?: string;
      details?: { email?: string };
    };

    expect(resolveResponse.status).toBe(502);
    expect(resolveData.success).toBe(false);
    expect(resolveData.code).toBe('TENANT_PROVISION_FAILED');
    expect(resolveData.details?.email).toBe('new-user@example.com');
  });

  it('returns suggested tenant details for non-public company domain', async () => {
    mockGetUserEmail.mockResolvedValue('new@acme.com');
    mockGetUserByEmail.mockReturnValue({ email: 'new@acme.com', tenantId: '', sub: 'author-123' });
    mockFindTenantSuggestionForEmail.mockReturnValue({
      tenantId: 'tenant-from-domain',
      matchedEmail: 'ops@acme.com',
      domain: 'acme.com',
      matchCount: 2,
    });

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const response = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Filters', primarySupplier: 'Acme' }),
    });
    const data = await response.json() as {
      code?: string;
      details?: { canUseSuggestedTenant?: boolean; suggestedTenant?: { tenantId?: string } };
    };

    expect(response.status).toBe(400);
    expect(data.code).toBe('TENANT_REQUIRED');
    expect(data.details?.canUseSuggestedTenant).toBe(true);
    expect(data.details?.suggestedTenant?.tenantId).toBe('tenant-from-domain');
  });

  it('applies suggested tenant override for the authenticated session', async () => {
    mockGetUserEmail.mockResolvedValue('new@acme.com');
    mockGetUserByEmail.mockReturnValue({ email: 'new@acme.com', tenantId: '', sub: 'author-123' });
    mockFindTenantSuggestionForEmail.mockReturnValue({
      tenantId: 'tenant-from-domain',
      matchedEmail: 'ops@acme.com',
      domain: 'acme.com',
      matchCount: 2,
    });

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const resolveResponse = await fetch(`${baseUrl}/api/arda/tenant/resolve`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'use_suggested' }),
    });

    expect(resolveResponse.status).toBe(200);

    const itemResponse = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Domain Item', primarySupplier: 'Acme' }),
    });

    expect(itemResponse.status).toBe(200);
    expect(mockCreateItem).toHaveBeenCalledWith(
      expect.objectContaining({ name: 'Domain Item', primarySupplier: 'Acme' }),
      {
        author: 'author-123',
        email: 'new@acme.com',
        tenantId: 'tenant-from-domain',
      }
    );
  });

  it('rejects unauthenticated writes', async () => {
    ({ server, baseUrl } = await startTestServer());

    const response = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Gloves', primarySupplier: 'SupplyCo' }),
    });

    const data = await response.json() as { error?: string };
    expect(response.status).toBe(401);
    expect(data.error).toContain('Authentication required');
    expect(mockCreateItem).not.toHaveBeenCalled();
  });

  it('uses authenticated user email mapping for actor credentials', async () => {
    mockGetUserEmail.mockResolvedValue('mapped@example.com');
    mockGetUserByEmail.mockReturnValue({ email: 'mapped@example.com', tenantId: 'tenant-123', sub: 'author-123' });

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const response = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Towels', primarySupplier: 'Warehouse' }),
    });

    expect(response.status).toBe(200);
    expect(mockCreateItem).toHaveBeenCalledWith(
      expect.objectContaining({ name: 'Towels', primarySupplier: 'Warehouse' }),
      { author: 'author-123', email: 'mapped@example.com', tenantId: 'tenant-123' }
    );
  });

  it('short-circuits create_new when tenant is already resolved', async () => {
    mockGetUserEmail.mockResolvedValue('mapped@example.com');
    mockGetUserByEmail.mockReturnValue({
      email: 'mapped@example.com',
      tenantId: 'tenant-123',
      sub: 'author-123',
    });

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const resolveResponse = await fetch(`${baseUrl}/api/arda/tenant/resolve`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'create_new' }),
    });
    const resolveData = await resolveResponse.json() as { success?: boolean; tenantId?: string };

    expect(resolveResponse.status).toBe(200);
    expect(resolveData.success).toBe(true);
    expect(resolveData.tenantId).toBe('tenant-123');
    expect(mockProvisionUserForEmail).not.toHaveBeenCalled();
    expect(mockSyncUsersOnDemand).not.toHaveBeenCalled();
  });

  it('rejects sync-velocity when provided author does not match authenticated author', async () => {
    mockGetUserEmail.mockResolvedValue('mapped@example.com');
    mockGetUserByEmail.mockReturnValue({
      email: 'mapped@example.com',
      tenantId: 'tenant-123',
      sub: 'author-123',
    });

    ({ server, baseUrl } = await startTestServer('session-user-id'));

    const response = await fetch(`${baseUrl}/api/arda/sync-velocity`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        author: 'different-author',
        profiles: [
          {
            displayName: 'AA Batteries',
            supplier: 'Warehouse',
            dailyBurnRate: 1,
            averageCadenceDays: 7,
            recommendedMin: 4,
            recommendedOrderQty: 12,
          },
        ],
      }),
    });

    expect(response.status).toBe(400);
    expect(mockNamedSyncVelocityToArda).not.toHaveBeenCalled();
  });

  it('returns recorded sync status after a successful write', async () => {
    mockGetUserEmail.mockResolvedValue('sync-status-success@example.com');
    mockGetUserByEmail.mockReturnValue({
      email: 'sync-status-success@example.com',
      tenantId: 'tenant-sync-status',
      sub: 'author-sync-status',
    });

    ({ server, baseUrl } = await startTestServer('sync-status-success-user'));

    const createResponse = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Tracked Item', primarySupplier: 'Supplier' }),
    });
    expect(createResponse.status).toBe(200);

    const statusResponse = await fetch(`${baseUrl}/api/arda/sync-status`);
    const statusData = await statusResponse.json() as {
      success: boolean;
      message: string;
      totalAttempts: number;
      successfulAttempts: number;
      failedAttempts: number;
      recent: Array<{ operation: string; success: boolean; requested: number }>;
    };

    expect(statusResponse.status).toBe(200);
    expect(statusData.success).toBe(true);
    expect(statusData.message).toBe('Sync status loaded');
    expect(statusData.totalAttempts).toBe(1);
    expect(statusData.successfulAttempts).toBe(1);
    expect(statusData.failedAttempts).toBe(0);
    expect(statusData.recent[0]?.operation).toBe('item_create');
    expect(statusData.recent[0]?.success).toBe(true);
    expect(statusData.recent[0]?.requested).toBe(1);
  });

  it('returns recorded sync status after a failed write', async () => {
    mockGetUserEmail.mockResolvedValue('sync-status-fail@example.com');
    mockGetUserByEmail.mockReturnValue(null);

    ({ server, baseUrl } = await startTestServer('sync-status-fail-user'));

    const createResponse = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Failing Item', primarySupplier: 'Supplier' }),
    });
    expect(createResponse.status).toBe(400);

    const statusResponse = await fetch(`${baseUrl}/api/arda/sync-status`);
    const statusData = await statusResponse.json() as {
      success: boolean;
      totalAttempts: number;
      successfulAttempts: number;
      failedAttempts: number;
      recent: Array<{ operation: string; success: boolean; error?: string }>;
    };

    expect(statusResponse.status).toBe(200);
    expect(statusData.success).toBe(true);
    expect(statusData.totalAttempts).toBe(1);
    expect(statusData.successfulAttempts).toBe(0);
    expect(statusData.failedAttempts).toBe(1);
    expect(statusData.recent[0]?.operation).toBe('item_create');
    expect(statusData.recent[0]?.success).toBe(false);
    expect(statusData.recent[0]?.error).toContain('Tenant required');
  });

  it('records provisioned tenant id in sync status events after auto-provisioned write', async () => {
    mockGetUserEmail.mockResolvedValue('status-provisioned@example.com');
    mockGetUserByEmail.mockReturnValue(null);
    mockProvisionUserForEmail.mockResolvedValue({
      author: 'status-provisioned-sub',
      email: 'status-provisioned@example.com',
      tenantId: 'tenant-from-provision',
    });

    ({ server, baseUrl } = await startTestServer('status-provisioned-user'));

    const createResponse = await fetch(`${baseUrl}/api/arda/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Provisioned Tracked Item', primarySupplier: 'Supplier' }),
    });
    expect(createResponse.status).toBe(200);

    const statusResponse = await fetch(`${baseUrl}/api/arda/sync-status`);
    const statusData = await statusResponse.json() as {
      success: boolean;
      recent: Array<{ success: boolean; tenantId?: string; email?: string }>;
    };

    expect(statusResponse.status).toBe(200);
    expect(statusData.success).toBe(true);
    expect(statusData.recent[0]?.success).toBe(true);
    expect(statusData.recent[0]?.tenantId).toBe('tenant-from-provision');
    expect(statusData.recent[0]?.email).toBe('status-provisioned@example.com');
  });
});

```

### `server/src/routes/arda.ts`

```typescript
// Arda API Routes - Proxy endpoints for frontend
import { Router, Request, Response } from 'express';
import { 
  ardaService, 
  ArdaActor,
  ItemInput, 
  KanbanCardInput, 
  OrderHeaderInput,
  createItemFromVelocity,
  syncVelocityToArda,
  ItemVelocityProfileInput
} from '../services/arda.js';
import { cognitoService, type TenantDomainSuggestion } from '../services/cognito.js';
import { getUserEmail } from './auth.js';
import { ensureHostedUrl, isDataUrl } from '../services/imageUpload.js';
import {
  getArdaSyncStatus,
  recordArdaSyncEvent,
  type ArdaSyncOperation,
} from '../services/ardaSyncStatus.js';

const router = Router();

// Extend session types
declare module 'express-session' {
  interface SessionData {
    userId: string;
    ardaTenantIdOverride?: string;
    ardaAuthorOverride?: string;
    authProvider?: 'google' | 'local';
  }
}

type TenantResolutionAction = 'create_new' | 'use_suggested';
type TenantResolutionMode = 'mapped' | 'override' | 'provisioned' | 'unresolved';

interface TenantResolutionDetails {
  canCreateTenant: boolean;
  suggestedTenant: TenantDomainSuggestion | null;
  autoProvisionAttempted?: boolean;
  autoProvisionSucceeded?: boolean;
  autoProvisionError?: string;
  resolutionMode?: TenantResolutionMode;
}

interface UserCredentials {
  email: string;
  tenantId: string | null;
  author: string | null;
  isAuthenticated: boolean;
  resolution: TenantResolutionDetails;
}

interface TrackArdaSyncInput {
  operation: ArdaSyncOperation;
  success: boolean;
  requested?: number;
  successful?: number;
  failed?: number;
  error?: string;
  actor?: ArdaActor;
}

interface ActorResolutionResult {
  credentials: UserCredentials;
  actor?: ArdaActor;
  error?: { status: number; body: unknown };
}

// Get user credentials from session - returns email, tenantId, and author (sub).
async function getUserCredentials(req: Request): Promise<UserCredentials> {
  const isAuthenticated = Boolean(req.session?.userId);
  let email = '';
  
  // Try to get from session first
  if (isAuthenticated) {
    const sessionEmail = await getUserEmail(req.session.userId!);
    if (sessionEmail) email = sessionEmail;
  }

  // Look up user in Cognito
  let cognitoUser = email ? cognitoService.getUserByEmail(email) : null;
  const sessionTenantOverride = req.session?.ardaTenantIdOverride || null;
  const sessionAuthorOverride = req.session?.ardaAuthorOverride || null;

  let tenantId = cognitoUser?.tenantId || sessionTenantOverride || null;
  let author = cognitoUser?.sub || sessionAuthorOverride || null;

  if (isAuthenticated && email && !tenantId) {
    const refreshed = await cognitoService.syncUsersOnDemand('missing-tenant');
    if (refreshed) {
      cognitoUser = cognitoService.getUserByEmail(email);
      tenantId = cognitoUser?.tenantId || sessionTenantOverride || null;
      author = cognitoUser?.sub || sessionAuthorOverride || null;
    }
  }

  const usingSessionOverride = (
    (!cognitoUser?.tenantId && Boolean(sessionTenantOverride))
    || (!cognitoUser?.sub && Boolean(sessionAuthorOverride))
  );
  const resolutionMode: TenantResolutionMode = (
    tenantId && author
      ? (usingSessionOverride ? 'override' : 'mapped')
      : 'unresolved'
  );

  const suggestedTenant = (
    isAuthenticated && email && !tenantId
      ? cognitoService.findTenantSuggestionForEmail(email)
      : null
  );
  
  return {
    email,
    tenantId,
    author,
    isAuthenticated,
    resolution: {
      canCreateTenant: isAuthenticated && Boolean(email),
      suggestedTenant,
      resolutionMode,
    },
  };
}

function updateCredentialResolution(
  credentials: UserCredentials,
  updates: Partial<TenantResolutionDetails>
): UserCredentials {
  return {
    ...credentials,
    resolution: {
      ...credentials.resolution,
      ...updates,
    },
  };
}

function credentialFailureResponse(credentials: UserCredentials) {
  const cognitoStatus = cognitoService.getSyncStatus();

  if (credentials.isAuthenticated) {
    const tenantRequired = !credentials.tenantId && !!credentials.email;
    const canUseSuggested = Boolean(credentials.author && credentials.resolution.suggestedTenant);
    const suggestionMessage = credentials.resolution.suggestedTenant
      ? `A tenant was found from your company domain (${credentials.resolution.suggestedTenant.domain}) via ${credentials.resolution.suggestedTenant.matchedEmail}.`
      : 'No same-domain tenant suggestion is available.';
    const emailMessage = credentials.email
      ? `No tenant mapping found for logged-in email ${credentials.email}.`
      : 'Authenticated session has no email. Re-authenticate with Google and retry.';

    return {
      status: 400,
      body: {
        success: false,
        code: tenantRequired ? 'TENANT_REQUIRED' : 'MISSING_COGNITO_CREDENTIALS',
        error: tenantRequired
          ? 'Tenant required for Arda sync'
          : 'Missing Cognito credentials for authenticated Arda sync',
        details: {
          email: credentials.email,
          authorFound: !!credentials.author,
          tenantIdFound: !!credentials.tenantId,
          cognitoUsersLoaded: cognitoStatus.userCount,
          canUseSuggestedTenant: canUseSuggested,
          canCreateTenant: credentials.resolution.canCreateTenant,
          suggestedTenant: credentials.resolution.suggestedTenant,
          autoProvisionAttempted: credentials.resolution.autoProvisionAttempted,
          autoProvisionSucceeded: credentials.resolution.autoProvisionSucceeded,
          autoProvisionError: credentials.resolution.autoProvisionError,
          resolutionMode: credentials.resolution.resolutionMode || 'unresolved',
          message: tenantRequired
            ? `${emailMessage} ${suggestionMessage}`
            : emailMessage,
        },
      },
    };
  }

  return {
    status: 401,
    body: {
      success: false,
      error: 'Authentication required for Arda sync',
      details: {
        email: credentials.email,
        authorFound: !!credentials.author,
        tenantIdFound: !!credentials.tenantId,
        cognitoUsersLoaded: cognitoStatus.userCount,
        message: 'Sign in and sync to your account tenant, or export items to CSV.',
      },
    },
  };
}

function buildActor(
  credentials: UserCredentials,
  providedAuthor?: string | null
): { actor?: ArdaActor; error?: { status: number; body: unknown } } {
  if (providedAuthor !== undefined && providedAuthor !== null && typeof providedAuthor !== 'string') {
    return {
      error: {
        status: 400,
        body: { success: false, error: 'author must be a string when provided' },
      },
    };
  }

  if (credentials.isAuthenticated) {
    if (!credentials.author || !credentials.tenantId || !credentials.email) {
      return { error: credentialFailureResponse(credentials) };
    }

    if (providedAuthor && providedAuthor !== credentials.author) {
      return {
        error: {
          status: 400,
          body: {
            success: false,
            error: 'Provided author does not match authenticated user',
            details: {
              providedAuthor,
              authenticatedAuthor: credentials.author,
              email: credentials.email,
            },
          },
        },
      };
    }

    return {
      actor: {
        author: credentials.author,
        email: credentials.email,
        tenantId: credentials.tenantId,
      },
    };
  }

  return { error: credentialFailureResponse(credentials) };
}

async function resolveActorForWrite(
  req: Request,
  providedAuthor?: string | null
): Promise<ActorResolutionResult> {
  const requestId = req.get('x-request-id') || 'n/a';
  let credentials = await getUserCredentials(req);

  if (providedAuthor !== undefined && providedAuthor !== null && typeof providedAuthor !== 'string') {
    return {
      credentials,
      error: {
        status: 400,
        body: { success: false, error: 'author must be a string when provided' },
      },
    };
  }

  let actorResult = buildActor(credentials, providedAuthor);
  if (actorResult.actor || !credentials.isAuthenticated || credentials.tenantId) {
    return {
      credentials,
      ...actorResult,
    };
  }

  if (!credentials.email || !credentials.resolution.canCreateTenant) {
    return {
      credentials,
      error: credentialFailureResponse(credentials),
    };
  }

  credentials = updateCredentialResolution(credentials, {
    autoProvisionAttempted: true,
    autoProvisionSucceeded: false,
    resolutionMode: 'unresolved',
  });

  console.info('Arda auto-provision attempt', {
    email: credentials.email,
    path: req.path,
    requestId,
  });

  if (!ardaService.isConfigured()) {
    const autoProvisionError = 'ARDA_API_KEY is not configured; auto-provisioning unavailable.';
    console.warn('Arda auto-provision failed', {
      email: credentials.email,
      path: req.path,
      requestId,
      reason: autoProvisionError,
      code: 'ARDA_NOT_CONFIGURED',
    });
    credentials = updateCredentialResolution(credentials, {
      autoProvisionSucceeded: false,
      autoProvisionError,
      resolutionMode: 'unresolved',
    });
    return {
      credentials,
      error: credentialFailureResponse(credentials),
    };
  }

  try {
    const provisioned = await ardaService.provisionUserForEmail(credentials.email);
    if (!provisioned?.tenantId || !provisioned.author) {
      const autoProvisionError = 'Automatic tenant provisioning did not return tenant credentials.';
      console.warn('Arda auto-provision failed', {
        email: credentials.email,
        path: req.path,
        requestId,
        reason: autoProvisionError,
        code: 'TENANT_PROVISION_FAILED',
      });
      credentials = updateCredentialResolution(credentials, {
        autoProvisionSucceeded: false,
        autoProvisionError,
        resolutionMode: 'unresolved',
      });
      return {
        credentials,
        error: credentialFailureResponse(credentials),
      };
    }

    req.session.ardaTenantIdOverride = provisioned.tenantId;
    req.session.ardaAuthorOverride = provisioned.author;

    console.info('Arda auto-provision success', {
      email: credentials.email,
      path: req.path,
      requestId,
      tenantId: provisioned.tenantId,
      authorSource: 'provisioned',
    });

    try {
      await cognitoService.ensureUserMappingForEmail(
        credentials.email,
        provisioned.tenantId,
        { role: 'User', suppressMessage: true }
      );
      console.info('Arda auto-provision Cognito mapping updated', {
        email: credentials.email,
        path: req.path,
        requestId,
        tenantId: provisioned.tenantId,
      });
    } catch (error) {
      console.warn('Arda auto-provision Cognito mapping update failed', {
        email: credentials.email,
        path: req.path,
        requestId,
        tenantId: provisioned.tenantId,
        reason: error instanceof Error ? error.message : String(error),
      });
    }

    credentials = updateCredentialResolution(
      {
        ...credentials,
        tenantId: provisioned.tenantId,
        author: provisioned.author,
      },
      {
        autoProvisionSucceeded: true,
        autoProvisionError: undefined,
        resolutionMode: 'provisioned',
      }
    );

    actorResult = buildActor(credentials, providedAuthor);
    return {
      credentials,
      ...actorResult,
    };
  } catch (error) {
    const autoProvisionError = error instanceof Error ? error.message : String(error);
    console.warn('Arda auto-provision failed', {
      email: credentials.email,
      path: req.path,
      requestId,
      reason: autoProvisionError,
      code: 'TENANT_PROVISION_FAILED',
    });
    credentials = updateCredentialResolution(credentials, {
      autoProvisionSucceeded: false,
      autoProvisionError,
      resolutionMode: 'unresolved',
    });
    return {
      credentials,
      error: credentialFailureResponse(credentials),
    };
  }
}

function getSyncStatusUserKey(req: Request, credentials?: UserCredentials): string {
  if (req.session?.userId) {
    return `user:${req.session.userId}`;
  }
  if (credentials?.email) {
    return `email:${credentials.email.toLowerCase()}`;
  }
  return 'anonymous';
}

function extractSyncErrorMessage(payload: unknown): string {
  if (typeof payload === 'string') {
    return payload;
  }

  if (!payload || typeof payload !== 'object') {
    return 'Unknown sync error';
  }

  const candidate = payload as {
    error?: unknown;
    code?: unknown;
    details?: { message?: unknown };
  };

  if (typeof candidate.error === 'string' && candidate.error.trim()) {
    return candidate.error;
  }

  if (typeof candidate.details?.message === 'string' && candidate.details.message.trim()) {
    return candidate.details.message;
  }

  if (typeof candidate.code === 'string' && candidate.code.trim()) {
    return candidate.code;
  }

  return 'Sync request failed';
}

async function trackArdaSync(
  req: Request,
  credentials: UserCredentials | undefined,
  input: TrackArdaSyncInput
): Promise<void> {
  try {
    await recordArdaSyncEvent(
      getSyncStatusUserKey(req, credentials),
      {
        ...input,
        email: input.actor?.email || credentials?.email || undefined,
        tenantId: input.actor?.tenantId || credentials?.tenantId || undefined,
      }
    );
  } catch (error) {
    console.warn('⚠️ Failed to record Arda sync status:', error);
  }
}

// Check if Arda is configured
router.get('/status', (req: Request, res: Response) => {
  res.json({
    configured: ardaService.isConfigured(),
    message: ardaService.isConfigured()
      ? 'Arda API is configured'
      : 'Missing ARDA_API_KEY environment variable',
  });
});

// Debug: Look up tenant ID from email (public for testing)
router.get('/lookup-tenant', async (req: Request, res: Response) => {
  try {
    // Accept email from query param or session
    let email = req.query.email as string;
    if (!email && req.session?.userId) {
      email = (await getUserCredentials(req)).email;
    }
    
    if (!email) {
      return res.status(400).json({
        success: false,
        error: 'Email required. Pass ?email=your@email.com'
      });
    }
    
    console.log(`🔍 Looking up tenant for email: ${email}`);
    
    const tenantId = await ardaService.getTenantByEmail(email);
    
    if (tenantId) {
      res.json({
        success: true,
        email,
        tenantId,
        message: `Found tenant ID for ${email}`
      });
    } else {
      res.json({
        success: false,
        email,
        tenantId: null,
        message: `No tenant found for email: ${email}. Make sure this email is registered in Arda.`
      });
    }
  } catch (error) {
    console.error('Tenant lookup error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to lookup tenant',
    });
  }
});

router.post('/tenant/resolve', async (req: Request, res: Response) => {
  try {
    const credentials = await getUserCredentials(req);
    if (!credentials.isAuthenticated || !credentials.email) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required to resolve tenant',
      });
    }

    const action = req.body?.action as TenantResolutionAction | undefined;
    if (action !== 'create_new' && action !== 'use_suggested') {
      return res.status(400).json({
        success: false,
        error: 'action must be one of: create_new, use_suggested',
      });
    }

    if (credentials.tenantId && credentials.author) {
      return res.json({
        success: true,
        action,
        tenantId: credentials.tenantId,
        author: credentials.author,
      });
    }

    if (action === 'create_new') {
      if (!ardaService.isConfigured()) {
        return res.status(503).json({
          success: false,
          code: 'ARDA_NOT_CONFIGURED',
          error: 'Tenant auto-provisioning is unavailable: ARDA_API_KEY is not configured.',
        });
      }

      const provisioned = await ardaService.provisionUserForEmail(credentials.email);
      if (!provisioned?.tenantId || !provisioned.author) {
        return res.status(502).json({
          success: false,
          code: 'TENANT_PROVISION_FAILED',
          error: 'Unable to create tenant for this email. Automatic provisioning failed; please contact support.',
          details: {
            email: credentials.email,
            message: 'Server logs contain endpoint/status details under "Auto-provision failed".',
          },
        });
      }

      try {
        await cognitoService.ensureUserMappingForEmail(
          credentials.email,
          provisioned.tenantId,
          { role: 'User', suppressMessage: true }
        );
      } catch (error) {
        console.warn(
          `⚠️ Failed to update Cognito mapping for ${credentials.email}:`,
          error instanceof Error ? error.message : error
        );
      }

      req.session.ardaTenantIdOverride = provisioned.tenantId;
      req.session.ardaAuthorOverride = provisioned.author;

      return res.json({
        success: true,
        action,
        tenantId: provisioned.tenantId,
        author: provisioned.author,
      });
    }

    const suggestion = cognitoService.findTenantSuggestionForEmail(credentials.email);
    if (!suggestion) {
      return res.status(404).json({
        success: false,
        error: 'No suggested tenant found for this email domain',
      });
    }

    if (!credentials.author) {
      return res.status(400).json({
        success: false,
        error: 'No Cognito author found for this email. Create a new tenant instead.',
      });
    }

    req.session.ardaTenantIdOverride = suggestion.tenantId;
    req.session.ardaAuthorOverride = credentials.author;

    return res.json({
      success: true,
      action,
      tenantId: suggestion.tenantId,
      author: credentials.author,
      suggestedTenant: suggestion,
    });
  } catch (error) {
    console.error('Arda tenant resolve error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to resolve tenant',
    });
  }
});

router.get('/tenant/status', async (req: Request, res: Response) => {
  try {
    const credentials = await getUserCredentials(req);
    if (!credentials.isAuthenticated) {
      const error = credentialFailureResponse(credentials);
      return res.status(error.status).json(error.body);
    }

    if (credentials.email && credentials.author && credentials.tenantId) {
      return res.json({
        success: true,
        resolved: true,
        details: {
          email: credentials.email,
          authorFound: true,
          tenantIdFound: true,
          tenantId: credentials.tenantId,
          resolutionMode: credentials.resolution.resolutionMode || 'mapped',
        },
      });
    }

    const error = credentialFailureResponse(credentials);
    return res.status(error.status).json({
      ...(error.body as Record<string, unknown>),
      resolved: false,
    });
  } catch (error) {
    console.error('Arda tenant status error:', error);
    return res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to check tenant status',
    });
  }
});

// Create item in Arda
router.post('/items', async (req: Request, res: Response) => {
  let credentials: UserCredentials | undefined;
  let actor: ArdaActor | undefined;
  try {
    const actorResult = await resolveActorForWrite(req);
    credentials = actorResult.credentials;
    if (actorResult.error) {
      await trackArdaSync(req, credentials, {
        operation: 'item_create',
        success: false,
        error: extractSyncErrorMessage(actorResult.error.body),
      });
      return res.status(actorResult.error.status).json(actorResult.error.body);
    }
    actor = actorResult.actor;

    const itemData: Omit<ItemInput, 'externalGuid'> = req.body;

    // Validate required fields
    if (!itemData.name || !itemData.primarySupplier) {
      await trackArdaSync(req, credentials, {
        operation: 'item_create',
        success: false,
        error: 'Missing required fields: name and primarySupplier are required',
      });
      return res.status(400).json({
        error: 'Missing required fields: name and primarySupplier are required',
      });
    }

    // If imageUrl is a data URL (base64), upload it to get a hosted URL
    let hostedImageUrl = itemData.imageUrl;
    if (itemData.imageUrl && isDataUrl(itemData.imageUrl)) {
      console.log('📸 Uploading captured photo to cloud storage...');
      hostedImageUrl = await ensureHostedUrl(itemData.imageUrl, 'order-pulse/items');
      if (hostedImageUrl) {
        console.log('✅ Photo uploaded:', hostedImageUrl);
      } else {
        console.warn('⚠️ Photo upload failed - image will be omitted from Arda');
      }
    }

    // Set defaults and pass all available fields
    const item: ItemInput = {
      name: itemData.name,
      description: (itemData as any).description,
      primarySupplier: itemData.primarySupplier,
      orderMechanism: itemData.orderMechanism || 'email',
      minQty: itemData.minQty || 1,
      minQtyUnit: itemData.minQtyUnit || 'EA',
      orderQty: itemData.orderQty || 1,
      orderQtyUnit: itemData.orderQtyUnit || 'EA',
      location: itemData.location,
      primarySupplierLink: itemData.primarySupplierLink,
      imageUrl: hostedImageUrl, // Use hosted URL instead of data URL
      sku: (itemData as any).sku || (itemData as any).barcode,
      color: (itemData as any).color,
    };

    const result = await ardaService.createItem(item, actor!);
    await trackArdaSync(req, credentials, {
      operation: 'item_create',
      success: true,
      requested: 1,
      successful: 1,
      failed: 0,
      actor,
    });
    res.json({ success: true, record: result });
  } catch (error) {
    console.error('Arda create item error:', error);
    await trackArdaSync(req, credentials, {
      operation: 'item_create',
      success: false,
      error: error instanceof Error ? error.message : 'Failed to create item in Arda',
      actor,
    });
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to create item in Arda',
    });
  }
});

// Create Kanban card in Arda
router.post('/kanban-cards', async (req: Request, res: Response) => {
  let credentials: UserCredentials | undefined;
  let actor: ArdaActor | undefined;
  try {
    const actorResult = await resolveActorForWrite(req);
    credentials = actorResult.credentials;
    if (actorResult.error) {
      await trackArdaSync(req, credentials, {
        operation: 'kanban_card_create',
        success: false,
        error: extractSyncErrorMessage(actorResult.error.body),
      });
      return res.status(actorResult.error.status).json(actorResult.error.body);
    }
    actor = actorResult.actor;

    const cardData: KanbanCardInput = req.body;

    // Validate required fields
    if (!cardData.item || !cardData.quantity) {
      await trackArdaSync(req, credentials, {
        operation: 'kanban_card_create',
        success: false,
        error: 'Missing required fields: item and quantity are required',
      });
      return res.status(400).json({
        error: 'Missing required fields: item and quantity are required',
      });
    }

    const result = await ardaService.createKanbanCard(cardData, actor!);
    await trackArdaSync(req, credentials, {
      operation: 'kanban_card_create',
      success: true,
      requested: 1,
      successful: 1,
      failed: 0,
      actor,
    });
    res.json({ success: true, record: result });
  } catch (error) {
    console.error('Arda create kanban card error:', error);
    await trackArdaSync(req, credentials, {
      operation: 'kanban_card_create',
      success: false,
      error: error instanceof Error ? error.message : 'Failed to create Kanban card in Arda',
      actor,
    });
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to create Kanban card in Arda',
    });
  }
});

// Create order in Arda
router.post('/orders', async (req: Request, res: Response) => {
  let credentials: UserCredentials | undefined;
  let actor: ArdaActor | undefined;
  try {
    const actorResult = await resolveActorForWrite(req);
    credentials = actorResult.credentials;
    if (actorResult.error) {
      await trackArdaSync(req, credentials, {
        operation: 'order_create',
        success: false,
        error: extractSyncErrorMessage(actorResult.error.body),
      });
      return res.status(actorResult.error.status).json(actorResult.error.body);
    }
    actor = actorResult.actor;

    const orderData = req.body;

    // Map OrderPulse order to Arda OrderHeaderInput
    const order: OrderHeaderInput = {
      orderDate: {
        utcTimestamp: orderData.orderDate
          ? new Date(orderData.orderDate).getTime()
          : Date.now(),
      },
      allowPartial: orderData.allowPartial ?? false,
      expedite: orderData.expedite ?? false,
      supplierName: orderData.supplier || orderData.supplierName,
      notes: orderData.notes,
      taxesAndFees: orderData.taxesAndFees || {},
    };

    if (orderData.deliverBy) {
      order.deliverBy = { utcTimestamp: new Date(orderData.deliverBy).getTime() };
    }

    const result = await ardaService.createOrder(order, actor!);
    await trackArdaSync(req, credentials, {
      operation: 'order_create',
      success: true,
      requested: 1,
      successful: 1,
      failed: 0,
      actor,
    });
    res.json({ success: true, record: result });
  } catch (error) {
    console.error('Arda create order error:', error);
    await trackArdaSync(req, credentials, {
      operation: 'order_create',
      success: false,
      error: error instanceof Error ? error.message : 'Failed to create order in Arda',
      actor,
    });
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to create order in Arda',
    });
  }
});

// Bulk sync items to Arda
router.post('/items/bulk', async (req: Request, res: Response) => {
  let credentials: UserCredentials | undefined;
  let actor: ArdaActor | undefined;
  try {
    const actorResult = await resolveActorForWrite(req);
    credentials = actorResult.credentials;
    if (actorResult.error) {
      await trackArdaSync(req, credentials, {
        operation: 'item_bulk_create',
        success: false,
        error: extractSyncErrorMessage(actorResult.error.body),
      });
      return res.status(actorResult.error.status).json(actorResult.error.body);
    }
    actor = actorResult.actor;

    const items: Array<Omit<ItemInput, 'externalGuid'>> = req.body.items;

    if (!Array.isArray(items) || items.length === 0) {
      await trackArdaSync(req, credentials, {
        operation: 'item_bulk_create',
        success: false,
        error: 'items array is required',
      });
      return res.status(400).json({ 
        success: false,
        error: 'items array is required',
        debug: { email: credentials.email }
      });
    }

    console.log(`📤 Syncing ${items.length} items to Arda for user ${credentials.email}`);
    console.log(`   Author: ${actor?.author}, Tenant: ${actor?.tenantId}`);

    // Sync each item with proper author from Cognito
    const results = await Promise.allSettled(
      items.map((item) => ardaService.createItem(item, actor!))
    );

    const successful = results.filter((r) => r.status === 'fulfilled').length;
    const failed = results.filter((r) => r.status === 'rejected').length;
    await trackArdaSync(req, credentials, {
      operation: 'item_bulk_create',
      success: failed === 0,
      requested: items.length,
      successful,
      failed,
      error: failed > 0 ? `${failed} items failed to sync` : undefined,
      actor,
    });

    res.json({
      success: failed === 0,
      credentials: {
        email: credentials.email,
        author: actor?.author,
        tenantId: actor?.tenantId || null,
      },
      summary: { total: items.length, successful, failed },
      results: results.map((r, i) => ({
        item: items[i].name,
        status: r.status,
        error: r.status === 'rejected' ? (r.reason as Error).message : undefined,
        record: r.status === 'fulfilled' ? (r as PromiseFulfilledResult<unknown>).value : undefined,
      })),
    });
  } catch (error) {
    console.error('Arda bulk sync error:', error);
    await trackArdaSync(req, credentials, {
      operation: 'item_bulk_create',
      success: false,
      error: error instanceof Error ? error.message : 'Failed to bulk sync items',
      actor,
    });
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to bulk sync items',
      stack: error instanceof Error ? error.stack : undefined,
    });
  }
});

// Sync velocity profiles to Arda
router.post('/sync-velocity', async (req: Request, res: Response) => {
  let credentials: UserCredentials | undefined;
  let actor: ArdaActor | undefined;
  try {
    credentials = await getUserCredentials(req);
    const { profiles, author } = req.body;

    // Validate request body
    if (!Array.isArray(profiles) || profiles.length === 0) {
      await trackArdaSync(req, credentials, {
        operation: 'velocity_sync',
        success: false,
        error: 'profiles array is required and must not be empty',
      });
      return res.status(400).json({
        error: 'profiles array is required and must not be empty',
      });
    }

    const actorResult = await resolveActorForWrite(req, author);
    credentials = actorResult.credentials;
    if (actorResult.error) {
      await trackArdaSync(req, credentials, {
        operation: 'velocity_sync',
        success: false,
        error: extractSyncErrorMessage(actorResult.error.body),
      });
      return res.status(actorResult.error.status).json(actorResult.error.body);
    }
    actor = actorResult.actor;

    // Validate each profile
    for (const profile of profiles) {
      if (!profile.displayName || !profile.supplier) {
        await trackArdaSync(req, credentials, {
          operation: 'velocity_sync',
          success: false,
          error: 'Each profile must have displayName and supplier',
        });
        return res.status(400).json({
          error: 'Each profile must have displayName and supplier',
        });
      }
    }

    console.log(`📤 Syncing ${profiles.length} velocity profiles to Arda for user ${credentials.email}`);

    const results = await syncVelocityToArda(profiles, actor!);
    const successful = results.filter((result) => result.success).length;
    const failed = results.length - successful;
    await trackArdaSync(req, credentials, {
      operation: 'velocity_sync',
      success: failed === 0,
      requested: profiles.length,
      successful,
      failed,
      error: failed > 0 ? `${failed} velocity profiles failed to sync` : undefined,
      actor,
    });

    res.json({ results });
  } catch (error) {
    console.error('Arda sync velocity error:', error);
    await trackArdaSync(req, credentials, {
      operation: 'velocity_sync',
      success: false,
      error: error instanceof Error ? error.message : 'Failed to sync velocity profiles to Arda',
      actor,
    });
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to sync velocity profiles to Arda',
    });
  }
});

// Push velocity items to Arda
router.post('/push-velocity', async (req: Request, res: Response) => {
  let credentials: UserCredentials | undefined;
  let actor: ArdaActor | undefined;
  try {
    const actorResult = await resolveActorForWrite(req);
    credentials = actorResult.credentials;
    if (actorResult.error) {
      await trackArdaSync(req, credentials, {
        operation: 'velocity_push',
        success: false,
        error: extractSyncErrorMessage(actorResult.error.body),
      });
      return res.status(actorResult.error.status).json(actorResult.error.body);
    }
    actor = actorResult.actor;

    const { items } = req.body;

    // Validate request body
    if (!Array.isArray(items) || items.length === 0) {
      await trackArdaSync(req, credentials, {
        operation: 'velocity_push',
        success: false,
        error: 'items array is required and must not be empty',
      });
      return res.status(400).json({
        success: false,
        error: 'items array is required and must not be empty',
      });
    }

    // Validate each item
    for (const item of items) {
      if (!item.displayName || !item.supplier) {
        await trackArdaSync(req, credentials, {
          operation: 'velocity_push',
          success: false,
          error: 'Each item must have displayName and supplier',
        });
        return res.status(400).json({
          success: false,
          error: 'Each item must have displayName and supplier',
        });
      }
    }

    console.log(`📤 Pushing ${items.length} velocity items to Arda for user ${credentials.email}`);
    console.log(`   Author: ${actor?.author}, Tenant: ${actor?.tenantId}`);

    const results = await ardaService.syncVelocityToArda(items, actor!);

    const successful = results.filter((r) => r.success).length;
    const failed = results.filter((r) => !r.success).length;
    await trackArdaSync(req, credentials, {
      operation: 'velocity_push',
      success: failed === 0,
      requested: items.length,
      successful,
      failed,
      error: failed > 0 ? `${failed} velocity items failed to sync` : undefined,
      actor,
    });

    res.json({
      success: failed === 0,
      summary: { total: items.length, successful, failed },
      results,
    });
  } catch (error) {
    console.error('Arda push velocity error:', error);
    await trackArdaSync(req, credentials, {
      operation: 'velocity_push',
      success: false,
      error: error instanceof Error ? error.message : 'Failed to push velocity items to Arda',
      actor,
    });
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to push velocity items to Arda',
      stack: error instanceof Error ? error.stack : undefined,
    });
  }
});

// Sync a single item from velocity data
router.post('/sync-item', async (req: Request, res: Response) => {
  let credentials: UserCredentials | undefined;
  let actor: ArdaActor | undefined;
  try {
    credentials = await getUserCredentials(req);
    const { author, ...profileData } = req.body;

    // Validate required fields
    if (!profileData.displayName || !profileData.supplier) {
      await trackArdaSync(req, credentials, {
        operation: 'velocity_item_sync',
        success: false,
        error: 'Missing required fields: displayName and supplier are required',
      });
      return res.status(400).json({
        error: 'Missing required fields: displayName and supplier are required',
      });
    }

    const actorResult = await resolveActorForWrite(req, author);
    credentials = actorResult.credentials;
    if (actorResult.error) {
      await trackArdaSync(req, credentials, {
        operation: 'velocity_item_sync',
        success: false,
        error: extractSyncErrorMessage(actorResult.error.body),
      });
      return res.status(actorResult.error.status).json(actorResult.error.body);
    }
    actor = actorResult.actor;

    console.log(`📤 Syncing item "${profileData.displayName}" to Arda for user ${credentials.email}`);

    const result = await createItemFromVelocity(profileData as ItemVelocityProfileInput, actor!);
    await trackArdaSync(req, credentials, {
      operation: 'velocity_item_sync',
      success: true,
      requested: 1,
      successful: 1,
      failed: 0,
      actor,
    });
    res.json({ success: true, record: result });
  } catch (error) {
    console.error('Arda sync item error:', error);
    await trackArdaSync(req, credentials, {
      operation: 'velocity_item_sync',
      success: false,
      error: error instanceof Error ? error.message : 'Failed to sync item from velocity data',
      actor,
    });
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to sync item from velocity data',
    });
  }
});

// Get sync status for the current authenticated user/session.
router.get('/sync-status', async (req: Request, res: Response) => {
  try {
    const credentials = await getUserCredentials(req);
    const status = await getArdaSyncStatus(getSyncStatusUserKey(req, credentials));
    const hasAttempts = status.totalAttempts > 0;

    res.json({
      success: true,
      message: hasAttempts
        ? 'Sync status loaded'
        : 'No Arda sync attempts have been recorded for this session yet',
      user: credentials.email,
      ardaConfigured: ardaService.isConfigured(),
      ...status,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Arda sync status error:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to get sync status',
    });
  }
});

export default router;

```

### `server/src/routes/auth.ts`

```typescript
import { Router, Request, Response } from 'express';
import { google } from 'googleapis';
import redisClient from '../utils/redisClient.js';
import { requireRedis } from '../config.js';
import bcrypt from 'bcryptjs';
import {
  saveUser,
  getUserById,
  getUserEmail as getUserEmailFromStore,
  getUserByEmail,
  getUserByGoogleId,
  mergeUsers,
  StoredUser,
} from '../services/userStore.js';

const router = Router();

// In-memory storage (for development without PostgreSQL)
const users = new Map<string, StoredUser>(); // local cache for dev

// Short-lived auth tokens for cross-origin authentication
// Token -> { userId, expiresAt }
const authTokens = new Map<string, { userId: string; expiresAt: Date }>();

function generateAuthToken(userId: string): string {
  const token = Math.random().toString(36).substring(2) + Date.now().toString(36);
  // Token expires in 60 seconds (just enough for the redirect)
  authTokens.set(token, { userId, expiresAt: new Date(Date.now() + 60000) });
  return token;
}

function consumeAuthToken(token: string): string | null {
  const data = authTokens.get(token);
  if (!data) return null;
  authTokens.delete(token); // One-time use
  if (data.expiresAt < new Date()) return null;
  return data.userId;
}

export async function getUserEmail(userId: string): Promise<string | null> {
  return getUserEmailFromStore(userId);
}

export async function getUserAuthProvider(userId: string): Promise<'google' | 'local' | null> {
  const user = await getUserById(userId);
  if (!user) return null;
  return user.googleId ? 'google' : user.passwordHash ? 'local' : null;
}

function ensureRedis(res: Response): boolean {
  if (requireRedis && !redisClient) {
    res.status(503).json({ error: 'Redis unavailable; authentication persistence is required in production' });
    return false;
  }
  return true;
}

// Create OAuth2 client lazily (after env vars are loaded)
function getOAuth2Client() {
  return new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    `${process.env.BACKEND_URL}/auth/google/callback`
  );
}

// Scopes for Gmail access
const SCOPES = [
  'https://www.googleapis.com/auth/gmail.readonly',
  'https://www.googleapis.com/auth/gmail.send',
  'https://www.googleapis.com/auth/userinfo.profile',
  'https://www.googleapis.com/auth/userinfo.email',
];

// Extend session type
declare module 'express-session' {
  interface SessionData {
    userId: string;
    authProvider?: 'google' | 'local';
  }
}

// Initiate Google OAuth flow
router.get('/google', (req: Request, res: Response) => {
  const oauth2Client = getOAuth2Client();
  const returnTo = typeof req.query.returnTo === 'string' ? req.query.returnTo : '';
  const authUrl = oauth2Client.generateAuthUrl({
    access_type: 'offline',
    scope: SCOPES,
    prompt: 'consent',
    state: returnTo || undefined,
  });
  console.log('🔗 Redirecting to:', authUrl.substring(0, 100) + '...');
  res.redirect(authUrl);
});

// OAuth callback handler
router.get('/google/callback', async (req: Request, res: Response) => {
  const { code, state } = req.query;
  
  if (!code || typeof code !== 'string') {
    return res.redirect(`${process.env.FRONTEND_URL}?error=no_code`);
  }

  try {
    if (!ensureRedis(res)) return;
    const oauth2Client = getOAuth2Client();
    
    // Exchange code for tokens
    const { tokens } = await oauth2Client.getToken(code);
    oauth2Client.setCredentials(tokens);

    // Get user info
    const oauth2 = google.oauth2({ version: 'v2', auth: oauth2Client });
    const { data: userInfo } = await oauth2.userinfo.get();

    if (!userInfo.id || !userInfo.email) {
      throw new Error('Missing user info from Google');
    }

    const returnTo = typeof state === 'string' && state.length > 0 ? state : '';

    const accessToken = tokens.access_token || '';
    const refreshToken = tokens.refresh_token || '';
    const expiresAt = tokens.expiry_date ? new Date(tokens.expiry_date) : new Date(Date.now() + 3600 * 1000);

    // If user already logged in, link Google account to existing user.
    if (req.session.userId) {
      const sessionUser = await getUserById(req.session.userId);
      if (!sessionUser) {
        return res.redirect(`${process.env.FRONTEND_URL}?error=auth_failed`);
      }

      if (sessionUser.googleId && sessionUser.googleId !== userInfo.id) {
        // User selected a different Google account than the one on the active session.
        // Reset the session and continue with a normal Google login to avoid auth loops.
        await new Promise<void>((resolve, reject) => {
          req.session.regenerate((err) => (err ? reject(err) : resolve()));
        });
      } else {
        const existingGoogleUser = await getUserByGoogleId(userInfo.id);
        if (existingGoogleUser && existingGoogleUser.id !== sessionUser.id) {
          await mergeUsers(existingGoogleUser.id, sessionUser.id);
        }

        const linkedUser: StoredUser = {
          ...sessionUser,
          googleId: userInfo.id,
          googleEmail: userInfo.email,
          accessToken,
          refreshToken: refreshToken || sessionUser.refreshToken,
          expiresAt,
          name: sessionUser.name || userInfo.name || '',
          picture: sessionUser.picture || userInfo.picture || '',
        };

        await saveUser(linkedUser);
        console.log(`✅ Gmail linked for user ${linkedUser.id} (${linkedUser.email})`);

        const authToken = generateAuthToken(linkedUser.id);
      req.session.userId = linkedUser.id;
      req.session.authProvider = linkedUser.googleId ? 'google' : 'local';

        const redirectTarget = `${process.env.FRONTEND_URL}?auth=success&token=${authToken}${returnTo ? `&returnTo=${encodeURIComponent(returnTo)}` : ''}`;
        return res.redirect(redirectTarget);
      }
    }

    // No existing session: login / create by Google account
    let user = await getUserByGoogleId(userInfo.id);
    if (!user) {
      const existingByEmail = await getUserByEmail(userInfo.email);
      if (existingByEmail) {
        user = {
          ...existingByEmail,
          googleId: userInfo.id,
          googleEmail: userInfo.email,
          accessToken,
          refreshToken: refreshToken || existingByEmail.refreshToken,
          expiresAt,
          name: existingByEmail.name || userInfo.name || '',
          picture: existingByEmail.picture || userInfo.picture || '',
        };
      } else {
        user = {
          id: userInfo.id,
          googleId: userInfo.id,
          googleEmail: userInfo.email,
          email: userInfo.email,
          name: userInfo.name || '',
          picture: userInfo.picture || '',
          accessToken,
          refreshToken,
          expiresAt,
        };
      }
    } else {
      user = {
        ...user,
        googleEmail: userInfo.email,
        accessToken,
        refreshToken: refreshToken || user.refreshToken,
        expiresAt,
        name: user.name || userInfo.name || '',
        picture: user.picture || userInfo.picture || '',
      };
    }

    await saveUser(user);
    console.log(`✅ User authenticated: ${user.name} (${user.email})`);

    // Generate a short-lived auth token for cross-origin cookie setting
    const authToken = generateAuthToken(user.id);

    // Set session (for same-origin requests)
    req.session.userId = user.id;
    req.session.authProvider = user.googleId ? 'google' : 'local';

    // Redirect to frontend with auth token
    const redirectTarget = `${process.env.FRONTEND_URL}?auth=success&token=${authToken}${returnTo ? `&returnTo=${encodeURIComponent(returnTo)}` : ''}`;
    res.redirect(redirectTarget);
  } catch (error) {
    console.error('OAuth callback error:', error);
    res.redirect(`${process.env.FRONTEND_URL}?error=auth_failed`);
  }
});

router.post('/local/signup', async (req: Request, res: Response) => {
  const { email, password, name } = req.body as { email?: string; password?: string; name?: string };

  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password are required' });
  }

  const normalizedEmail = email.trim().toLowerCase();

  try {
    if (!ensureRedis(res)) return;

    const existingUser = await getUserByEmail(normalizedEmail);
    if (existingUser && existingUser.passwordHash) {
      return res.status(409).json({ error: 'Account already exists' });
    }

    const passwordHash = await bcrypt.hash(password, 12);
    const userId = existingUser?.id || `local-${Math.random().toString(36).slice(2)}`;

    const userData: StoredUser = {
      id: userId,
      googleId: existingUser?.googleId || null,
      googleEmail: existingUser?.googleEmail || null,
      email: normalizedEmail,
      name: name || existingUser?.name || '',
      picture: existingUser?.picture || '',
      accessToken: existingUser?.accessToken || '',
      refreshToken: existingUser?.refreshToken || '',
      expiresAt: existingUser?.expiresAt || new Date(Date.now() + 3600 * 1000),
      passwordHash,
    };

    await saveUser(userData);
    req.session.userId = userId;
    req.session.authProvider = userData.googleId ? 'google' : 'local';

    res.json({
      success: true,
      user: {
        id: userData.id,
        email: userData.email,
        name: userData.name,
        picture_url: userData.picture,
      },
    });
  } catch (error) {
    console.error('Local signup error:', error);
    res.status(500).json({ error: 'Failed to create account' });
  }
});

router.post('/local/login', async (req: Request, res: Response) => {
  const { email, password } = req.body as { email?: string; password?: string };

  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password are required' });
  }

  const normalizedEmail = email.trim().toLowerCase();

  try {
    if (!ensureRedis(res)) return;

    const user = await getUserByEmail(normalizedEmail);
    if (!user || !user.passwordHash) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    const matches = await bcrypt.compare(password, user.passwordHash);
    if (!matches) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    req.session.userId = user.id;
    req.session.authProvider = user.googleId ? 'google' : 'local';

    res.json({
      success: true,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        picture_url: user.picture,
      },
    });
  } catch (error) {
    console.error('Local login error:', error);
    res.status(500).json({ error: 'Failed to sign in' });
  }
});

// Token exchange endpoint - converts short-lived token to session cookie
// This is called by the frontend to establish the session in a same-origin context
router.get('/token-exchange', async (req: Request, res: Response) => {
  const { token } = req.query;
  
  if (!token || typeof token !== 'string') {
    return res.status(400).json({ error: 'Missing token' });
  }

  const userId = consumeAuthToken(token);
  if (!userId) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
  try {
    const user = await getUserById(userId);
    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }

    // Set session
    req.session.userId = userId;
    req.session.authProvider = 'google';
    console.log(`🔄 Token exchange successful for ${user.email}`);

    res.json({
      success: true,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        picture_url: user.picture,
      }
    });
  } catch (error) {
    console.error('Token exchange error:', error);
    res.status(500).json({ error: 'Failed to establish session' });
  }
});

// Get current user
router.get('/me', async (req: Request, res: Response) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  try {
    const user = await getUserById(req.session.userId);
    if (!user) {
      req.session.destroy(() => {});
      return res.status(401).json({ error: 'User not found' });
    }

    res.json({
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        picture_url: user.picture,
      }
    });
  } catch (error) {
    console.error('Auth me error:', error);
    res.status(500).json({ error: 'Failed to fetch current user' });
  }
});

// Logout
router.post('/logout', async (req: Request, res: Response) => {
  if (req.session.userId) {
    users.delete(req.session.userId);
    req.session.destroy((err) => {
      if (err) {
        console.error('Session destroy error:', err);
      }
    });
  }
  res.json({ success: true });
});

// Get valid access token (with auto-refresh)
export async function getValidAccessToken(userId: string): Promise<string | null> {
  const user = await getUserById(userId);
  if (!user) {
    return null;
  }

  // Check if token is expired (with 5 min buffer)
  const isExpired = user.expiresAt.getTime() < Date.now() + 5 * 60 * 1000;

  if (!isExpired) {
    return user.accessToken;
  }

  // Refresh the token
  try {
    const oauth2Client = getOAuth2Client();
    oauth2Client.setCredentials({ refresh_token: user.refreshToken });
    const { credentials } = await oauth2Client.refreshAccessToken();

    // Update stored tokens
    user.accessToken = credentials.access_token || '';
    user.expiresAt = credentials.expiry_date 
      ? new Date(credentials.expiry_date) 
      : new Date(Date.now() + 3600 * 1000);

    console.log(`🔄 Token refreshed for ${user.email}`);
    return user.accessToken;
  } catch (error) {
    console.error('Token refresh error:', error);
    return null;
  }
}

export { router as authRouter };

```

### `server/src/routes/cognito.ts`

```typescript
// Cognito API Routes - User lookup and sync endpoints
import { Router, Request, Response } from 'express';
import { cognitoService } from '../services/cognito.js';

const router = Router();

// Get sync status
router.get('/status', (req: Request, res: Response) => {
  const status = cognitoService.getSyncStatus();
  res.json({
    success: true,
    ...status,
    message: status.userCount > 0 
      ? `${status.userCount} users loaded` 
      : 'No users loaded - run sync',
  });
});

// Look up user by email
router.get('/lookup', (req: Request, res: Response) => {
  const email = req.query.email as string;
  
  if (!email) {
    return res.status(400).json({ 
      success: false, 
      error: 'Email query parameter required' 
    });
  }
  
  const user = cognitoService.getUserByEmail(email);
  
  if (user) {
    res.json({
      success: true,
      user: {
        email: user.email,
        tenantId: user.tenantId,
        author: user.sub,
        name: user.name,
        role: user.role,
      },
    });
  } else {
    res.json({
      success: false,
      message: `No user found for email: ${email}`,
    });
  }
});

// Trigger manual sync from GitHub
router.post('/sync', async (req: Request, res: Response) => {
  try {
    console.log('📡 Manual Cognito sync triggered');
    const success = await cognitoService.syncUsersFromGitHub();
    
    if (success) {
      const status = cognitoService.getSyncStatus();
      res.json({
        success: true,
        message: `Sync completed. ${status.userCount} users loaded.`,
        ...status,
      });
    } else {
      res.status(500).json({
        success: false,
        error: 'Sync failed - check server logs',
      });
    }
  } catch (error) {
    console.error('Cognito sync error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Sync failed',
    });
  }
});

// Reload from local file (without triggering GitHub workflow)
router.post('/reload', (req: Request, res: Response) => {
  try {
    cognitoService.loadUsersFromFile();
    const status = cognitoService.getSyncStatus();
    res.json({
      success: true,
      message: `Reloaded ${status.userCount} users from file`,
      ...status,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Reload failed',
    });
  }
});

// List all users (admin endpoint)
router.get('/users', (req: Request, res: Response) => {
  const users = cognitoService.getAllUsers();
  res.json({
    success: true,
    count: users.length,
    users: users.map(u => ({
      email: u.email,
      tenantId: u.tenantId,
      author: u.sub,
      name: u.name,
      role: u.role,
    })),
  });
});

export default router;

```

### `server/src/routes/discover.ts`

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import { google } from 'googleapis';
import { getValidAccessToken } from './auth.js';

const router = Router();

const discoverLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 5,
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    res.status(429).json({
      error: 'Too many discovery requests. Please wait a minute before retrying.',
    });
  },
});

// Health check for this router (no auth required)
router.get('/health', (req: Request, res: Response) => {
  res.json({ 
    status: 'ok', 
    router: 'discover',
    timestamp: new Date().toISOString() 
  });
});

// Middleware to require authentication
async function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  next();
}

// Known supplier patterns for categorization
const SUPPLIER_PATTERNS: Record<string, { category: string; keywords: string[] }> = {
  // Industrial
  'mcmaster.com': { category: 'industrial', keywords: ['mcmaster', 'carr'] },
  'mcmaster-carr.com': { category: 'industrial', keywords: ['mcmaster', 'carr'] },
  'grainger.com': { category: 'industrial', keywords: ['grainger'] },
  'uline.com': { category: 'industrial', keywords: ['uline'] },
  'fastenal.com': { category: 'industrial', keywords: ['fastenal'] },
  'mscdirect.com': { category: 'industrial', keywords: ['msc', 'industrial'] },
  'globalindustrial.com': { category: 'industrial', keywords: ['global', 'industrial'] },
  'zoro.com': { category: 'industrial', keywords: ['zoro'] },
  'automationdirect.com': { category: 'industrial', keywords: ['automation'] },
  'misumi.com': { category: 'industrial', keywords: ['misumi'] },
  'misumiusa.com': { category: 'industrial', keywords: ['misumi'] },
  'applied.com': { category: 'industrial', keywords: ['applied'] },
  'motion.com': { category: 'industrial', keywords: ['motion'] },
  
  // Electronics
  'digikey.com': { category: 'electronics', keywords: ['digikey'] },
  'mouser.com': { category: 'electronics', keywords: ['mouser'] },
  'newark.com': { category: 'electronics', keywords: ['newark'] },
  'alliedelec.com': { category: 'electronics', keywords: ['allied'] },
  'newegg.com': { category: 'electronics', keywords: ['newegg'] },
  'bhphotovideo.com': { category: 'electronics', keywords: ['b&h', 'photo'] },
  'adorama.com': { category: 'electronics', keywords: ['adorama'] },
  'monoprice.com': { category: 'electronics', keywords: ['monoprice'] },
  'sweetwater.com': { category: 'electronics', keywords: ['sweetwater'] },
  
  // Retail
  'amazon.com': { category: 'retail', keywords: ['amazon'] },
  'costco.com': { category: 'retail', keywords: ['costco'] },
  'walmart.com': { category: 'retail', keywords: ['walmart'] },
  'target.com': { category: 'retail', keywords: ['target'] },
  'homedepot.com': { category: 'retail', keywords: ['home depot'] },
  'lowes.com': { category: 'retail', keywords: ['lowes'] },
  'bestbuy.com': { category: 'retail', keywords: ['best buy'] },
  'samsclub.com': { category: 'retail', keywords: ['sams', 'club'] },
  
  // Office
  'staples.com': { category: 'office', keywords: ['staples'] },
  'officedepot.com': { category: 'office', keywords: ['office depot'] },
  
  // Food
  'sysco.com': { category: 'food', keywords: ['sysco'] },
  'usfoods.com': { category: 'food', keywords: ['us foods'] },
  'webstaurantstore.com': { category: 'food', keywords: ['webstaurant'] },
};

// Domains to EXCLUDE (SaaS, financial, tech, etc.)
const EXCLUDED_DOMAINS = new Set([
  'google.com', 'googleapis.com', 'gmail.com',
  'cursor.com', 'cursor.sh',
  'mercury.com', 'stripe.com', 'paypal.com', 'venmo.com',
  'chase.com', 'bankofamerica.com', 'wellsfargo.com', 'citi.com', 'capitalone.com', 'americanexpress.com',
  'vercel.com', 'heroku.com', 'netlify.com', 'railway.app',
  'github.com', 'gitlab.com', 'bitbucket.org',
  'digitalocean.com', 'aws.amazon.com', 'cloud.google.com', 'azure.microsoft.com',
  'slack.com', 'zoom.us', 'dropbox.com', 'notion.so', 'figma.com', 'canva.com',
  'adobe.com', 'atlassian.com', 'atlassian.net', 'asana.com', 'monday.com',
  'hubspot.com', 'salesforce.com', 'zendesk.com', 'intercom.com',
  'twilio.com', 'sendgrid.com', 'mailchimp.com', 'klaviyo.com',
  'shopify.com', 'squarespace.com', 'wix.com', 'godaddy.com', 'namecheap.com', 'cloudflare.com',
  'linkedin.com', 'twitter.com', 'facebook.com', 'instagram.com',
  'youtube.com', 'spotify.com', 'netflix.com', 'hulu.com',
  'uber.com', 'lyft.com', 'doordash.com', 'grubhub.com', 'postmates.com',
  'apple.com', 'microsoft.com',
]);

// Order-related keywords for scoring
const ORDER_KEYWORDS = [
  'order', 'invoice', 'receipt', 'shipped', 'shipping', 'delivered', 'delivery',
  'confirmation', 'purchase', 'transaction', 'payment', 'thank you for your order',
];

interface SupplierData {
  domain: string;
  displayName: string;
  emails: { subject: string; date: string }[];
  score: number;
  category: string;
}

function extractDomain(email: string): string | null {
  const match = email.match(/@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
  if (!match) return null;
  
  let domain = match[1].toLowerCase();
  
  // Normalize subdomains
  const parts = domain.split('.');
  if (parts.length > 2) {
    // Keep last two parts for most domains, but handle special cases
    const tld = parts.slice(-2).join('.');
    if (['co.uk', 'com.au', 'co.jp'].includes(tld)) {
      domain = parts.slice(-3).join('.');
    } else {
      domain = parts.slice(-2).join('.');
    }
  }
  
  return domain;
}

function extractDisplayName(fromHeader: string): string {
  // Extract name from "Name <email>" format
  const match = fromHeader.match(/^"?([^"<]+)"?\s*</);
  if (match) {
    return match[1].trim();
  }
  
  // Extract from email domain
  const domain = extractDomain(fromHeader);
  if (domain) {
    const name = domain.split('.')[0];
    return name.charAt(0).toUpperCase() + name.slice(1);
  }
  
  return fromHeader;
}

function categorizeSupplier(domain: string): string {
  // Check known patterns
  for (const [pattern, info] of Object.entries(SUPPLIER_PATTERNS)) {
    if (domain.includes(pattern.split('.')[0])) {
      return info.category;
    }
  }
  return 'unknown';
}

function scoreSupplier(data: SupplierData): number {
  let score = 0;
  
  // Base score from email count (max 30 points)
  score += Math.min(data.emails.length * 5, 30);
  
  // Known supplier bonus (30 points)
  if (data.category !== 'unknown') {
    score += 30;
  }
  
  // Keyword matches in subjects (max 40 points)
  let keywordMatches = 0;
  for (const email of data.emails) {
    const subjectLower = email.subject.toLowerCase();
    for (const keyword of ORDER_KEYWORDS) {
      if (subjectLower.includes(keyword)) {
        keywordMatches++;
        break; // Only count once per email
      }
    }
  }
  score += Math.min(keywordMatches * 10, 40);
  
  return Math.min(score, 100);
}

// Discover suppliers from email headers
router.get('/discover-suppliers', discoverLimiter, requireAuth, async (req: Request, res: Response) => {
  try {
    console.log(`🔍 Discover request from user: ${req.session.userId}`);
    
    const accessToken = await getValidAccessToken(req.session.userId!);
    
    if (!accessToken) {
      console.error(`❌ No access token for user ${req.session.userId}`);
      return res.status(401).json({ 
        error: 'Session expired. Please log out and log back in.',
        code: 'TOKEN_EXPIRED'
      });
    }
    
    console.log(`✅ Got access token for discover`);


    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({ access_token: accessToken });

    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });

    // Broad query to find potential order emails
    const query = `subject:(order OR invoice OR receipt OR shipped OR confirmation OR "thank you") newer_than:6m`;
    
    console.log(`🔍 Discovering suppliers with query: "${query}"`);

    // List messages matching query (headers only for efficiency)
    const listResponse = await gmail.users.messages.list({
      userId: 'me',
      q: query,
      maxResults: 500,
    });

    const messages = listResponse.data.messages || [];
    console.log(`📬 Found ${messages.length} potential order emails`);

    // Fetch headers only (not full body)
    const supplierMap = new Map<string, SupplierData>();

    for (const msg of messages) {
      try {
        const fullMsg = await gmail.users.messages.get({
          userId: 'me',
          id: msg.id!,
          format: 'metadata',
          metadataHeaders: ['From', 'Subject', 'Date'],
        });

        const headers = fullMsg.data.payload?.headers || [];
        const getHeader = (name: string) =>
          headers.find(h => h.name?.toLowerCase() === name.toLowerCase())?.value || '';

        const from = getHeader('From');
        const subject = getHeader('Subject');
        const date = getHeader('Date');

        const domain = extractDomain(from);
        if (!domain || EXCLUDED_DOMAINS.has(domain)) {
          continue;
        }

        if (!supplierMap.has(domain)) {
          supplierMap.set(domain, {
            domain,
            displayName: extractDisplayName(from),
            emails: [],
            score: 0,
            category: categorizeSupplier(domain),
          });
        }

        supplierMap.get(domain)!.emails.push({ subject, date });
      } catch (err) {
        // Skip individual message errors
        console.error(`Error fetching message ${msg.id}:`, err);
      }
    }

    // Calculate scores and build response
    const suppliers = Array.from(supplierMap.values())
      .map(data => {
        data.score = scoreSupplier(data);
        return {
          domain: data.domain,
          displayName: data.displayName,
          emailCount: data.emails.length,
          score: data.score,
          category: data.category as 'industrial' | 'retail' | 'office' | 'food' | 'electronics' | 'unknown',
          sampleSubjects: data.emails.slice(0, 3).map(e => e.subject),
          isRecommended: data.score >= 50 || data.category !== 'unknown',
        };
      })
      .filter(s => s.emailCount >= 1) // At least 1 email
      .sort((a, b) => b.score - a.score) // Sort by score
      .slice(0, 20); // Top 20

    console.log(`✅ Discovered ${suppliers.length} potential suppliers`);
    
    res.json({ suppliers });
  } catch (error: any) {
    console.error('Discover suppliers error:', error);
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      status: error.status,
      stack: error.stack?.split('\n').slice(0, 5),
    });
    
    // Handle specific Gmail API errors
    if (error.code === 401 || error.message?.includes('invalid_grant')) {
      return res.status(401).json({ error: 'Token expired, please re-authenticate' });
    }
    if (error.code === 403) {
      return res.status(403).json({ error: 'Gmail access denied. Please grant email permissions.' });
    }
    
    res.status(500).json({ 
      error: 'Failed to discover suppliers',
      details: error.message || 'Unknown error'
    });
  }
});

export { router as discoverRouter };

```

### `server/src/routes/gmail.ts`

```typescript
import { Router, Request, Response } from 'express';
import { google } from 'googleapis';
import { getValidAccessToken } from './auth.js';

const router = Router();

// Middleware to require authentication
async function requireAuth(req: Request, res: Response, next: Function) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  next();
}

// Fetch Gmail messages
router.get('/messages', requireAuth, async (req: Request, res: Response) => {
  try {
    const accessToken = await getValidAccessToken(req.session.userId!);
    
    if (!accessToken) {
      return res.status(401).json({ error: 'Token expired, please re-authenticate' });
    }

    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({ access_token: accessToken });

    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });



    // Search parameters - focus on PHYSICAL products: industrial, office supplies, food, retail
    // Excludes: SaaS, financial institutions, tech companies
    const defaultQuery = `(
      from:(
        @mcmaster.com OR @mcmaster-carr.com OR
        @uline.com OR
        @grainger.com OR
        @fastenal.com OR
        @delcity.net OR @delcity.com OR
        @mscdirect.com OR
        @globalindustrial.com OR
        @zoro.com OR
        @applied.com OR
        @motion.com OR
        @digikey.com OR
        @mouser.com OR
        @newark.com OR
        @element14.com OR
        @alliedelec.com OR
        @automationdirect.com OR
        @misumiusa.com OR @misumi.com OR
        @rs-online.com OR @rsonline.com OR @rsdelivers.com OR
        @amazon.com OR @amazon.business OR
        @costco.com OR
        @homedepot.com OR
        @lowes.com OR
        @staples.com OR
        @officedepot.com OR @officedepot.com OR
        @webstaurantstore.com OR
        @sysco.com OR
        @usfoods.com OR
        @samsclub.com OR
        @walmart.com OR
        @target.com OR
        @bestbuy.com OR
        @newegg.com OR
        @bhphotovideo.com OR
        @adorama.com OR
        @monoprice.com OR
        @cableorganizer.com OR
        @crutchfield.com OR
        @sweetwater.com
      )
      subject:(invoice OR receipt OR "order confirmation" OR "order acknowledgment" OR "thank you for your order" OR "order number" OR "shipped")
    ) OR (
      from:(@ups.com OR @fedex.com OR @dhl.com OR @usps.com) (invoice OR charges OR receipt OR "delivery")
    )
    -from:(@google.com OR @cursor.com OR @cursor.sh OR @mercury.com OR @stripe.com OR @paypal.com OR @venmo.com OR @chase.com OR @bankofamerica.com OR @wellsfargo.com OR @citi.com OR @capitalone.com OR @amex.com OR @vercel.com OR @heroku.com OR @netlify.com OR @github.com OR @gitlab.com OR @digitalocean.com OR @aws.amazon.com OR @cloud.google.com OR @azure.com OR @slack.com OR @zoom.com OR @dropbox.com OR @notion.so OR @figma.com OR @canva.com OR @adobe.com OR @atlassian.com OR @jira.com OR @asana.com OR @monday.com OR @hubspot.com OR @salesforce.com OR @zendesk.com OR @intercom.com OR @twilio.com OR @sendgrid.com OR @mailchimp.com OR @klaviyo.com OR @shopify.com OR @squarespace.com OR @wix.com OR @godaddy.com OR @namecheap.com OR @cloudflare.com)`;
    const baseQuery = req.query.q as string || defaultQuery;
    const query = `${baseQuery} newer_than:6m`;
    const maxResults = parseInt(req.query.maxResults as string) || 500; // Increased default

    console.log(`📧 Searching Gmail with query: "${query}" (max: ${maxResults})`);

    // List messages matching query
    const listResponse = await gmail.users.messages.list({
      userId: 'me',
      q: query,
      maxResults,
    });

    const messages = listResponse.data.messages || [];
    console.log(`📬 Found ${messages.length} messages matching query`);


    // Fetch full message details
    const fullMessages = await Promise.all(
      messages.map(async (msg) => {
        const fullMsg = await gmail.users.messages.get({
          userId: 'me',
          id: msg.id!,
          format: 'full',
        });
        
        const headers = fullMsg.data.payload?.headers || [];
        const getHeader = (name: string) => 
          headers.find(h => h.name?.toLowerCase() === name.toLowerCase())?.value || '';

        // Extract body
        let body = '';
        const parts = fullMsg.data.payload?.parts || [];
        
        if (fullMsg.data.payload?.body?.data) {
          body = Buffer.from(fullMsg.data.payload.body.data, 'base64').toString('utf-8');
        } else {
          for (const part of parts) {
            if (part.mimeType === 'text/plain' && part.body?.data) {
              body = Buffer.from(part.body.data, 'base64').toString('utf-8');
              break;
            } else if (part.mimeType === 'text/html' && part.body?.data) {
              body = Buffer.from(part.body.data, 'base64').toString('utf-8');
            }
          }
        }

        return {
          id: msg.id,
          subject: getHeader('Subject'),
          sender: getHeader('From'),
          date: getHeader('Date'),
          snippet: fullMsg.data.snippet || '',
          body,
        };
      })
    );

    res.json({ 
      messages: fullMessages,
      total: listResponse.data.resultSizeEstimate || messages.length,
    });
  } catch (error: any) {
    console.error('Gmail fetch error:', error);
    
    if (error.code === 401) {
      return res.status(401).json({ error: 'Token expired, please re-authenticate' });
    }
    
    res.status(500).json({ error: 'Failed to fetch emails' });
  }
});

// Send email
router.post('/send', requireAuth, async (req: Request, res: Response) => {
  try {
    const { to, subject, body } = req.body;

    if (!to || !subject || !body) {
      return res.status(400).json({ error: 'Missing required fields: to, subject, body' });
    }

    const accessToken = await getValidAccessToken(req.session.userId!);
    
    if (!accessToken) {
      return res.status(401).json({ error: 'Token expired, please re-authenticate' });
    }

    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({ access_token: accessToken });

    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });

    // Create email
    const emailLines = [
      `To: ${to}`,
      `Subject: ${subject}`,
      'Content-Type: text/html; charset=utf-8',
      '',
      body,
    ];
    const email = emailLines.join('\r\n');
    const encodedEmail = Buffer.from(email).toString('base64url');

    // Send email
    const result = await gmail.users.messages.send({
      userId: 'me',
      requestBody: {
        raw: encodedEmail,
      },
    });

    res.json({ success: true, messageId: result.data.id });
  } catch (error: any) {
    console.error('Gmail send error:', error);
    res.status(500).json({ error: 'Failed to send email' });
  }
});

export { router as gmailRouter };

```

### `server/src/routes/inboundEmail.test.ts`

```typescript
import express from 'express';
import { AddressInfo } from 'node:net';
import type { Server } from 'node:http';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const mockEnqueuePostmarkInboundReceipt = vi.fn();
const mockGetInboundReceiptStatus = vi.fn();

vi.mock('../services/inboundReceiptWorker.js', () => ({
  enqueuePostmarkInboundReceipt: mockEnqueuePostmarkInboundReceipt,
  getInboundReceiptStatus: mockGetInboundReceiptStatus,
}));

const originalEnv = process.env;

function basicAuthHeader(username: string, password: string): string {
  const token = Buffer.from(`${username}:${password}`).toString('base64');
  return `Basic ${token}`;
}

async function startServer(): Promise<{ server: Server; baseUrl: string }> {
  const { default: inboundEmailRouter } = await import('./inboundEmail.js');
  const app = express();
  app.use(express.json());
  app.use('/api/inbound', inboundEmailRouter);
  const server = app.listen(0);
  await new Promise<void>((resolve) => server.once('listening', resolve));
  const address = server.address() as AddressInfo;
  return { server, baseUrl: `http://127.0.0.1:${address.port}` };
}

describe('inboundEmail routes', () => {
  let server: Server | null = null;
  let baseUrl = '';

  beforeEach(async () => {
    vi.resetModules();
    vi.clearAllMocks();
    process.env = {
      ...originalEnv,
      POSTMARK_INBOUND_USERNAME: 'postmark-user',
      POSTMARK_INBOUND_PASSWORD: 'postmark-pass',
    };
    ({ server, baseUrl } = await startServer());
  });

  afterEach(async () => {
    process.env = originalEnv;
    if (server) {
      await new Promise<void>((resolve, reject) => {
        server?.close((err) => (err ? reject(err) : resolve()));
      });
      server = null;
    }
  });

  it('rejects webhook requests with missing auth', async () => {
    const response = await fetch(`${baseUrl}/api/inbound/postmark`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({}),
    });

    expect(response.status).toBe(401);
    expect(mockEnqueuePostmarkInboundReceipt).not.toHaveBeenCalled();
  });

  it('rejects webhook requests with invalid auth', async () => {
    const response = await fetch(`${baseUrl}/api/inbound/postmark`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        authorization: basicAuthHeader('wrong', 'creds'),
      },
      body: JSON.stringify({}),
    });

    expect(response.status).toBe(401);
    expect(mockEnqueuePostmarkInboundReceipt).not.toHaveBeenCalled();
  });

  it('accepts valid postmark payloads and enqueues processing', async () => {
    mockEnqueuePostmarkInboundReceipt.mockResolvedValue({
      eventId: 'evt-1',
      duplicate: false,
      status: 'received',
    });

    const response = await fetch(`${baseUrl}/api/inbound/postmark`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        authorization: basicAuthHeader('postmark-user', 'postmark-pass'),
      },
      body: JSON.stringify({
        MessageID: '<abc123@example.com>',
        Subject: 'Receipt',
        FromFull: { Email: 'sender@example.com', Name: 'Sender' },
        TextBody: 'Thanks for your order',
      }),
    });

    expect(response.status).toBe(202);
    expect(mockEnqueuePostmarkInboundReceipt).toHaveBeenCalledTimes(1);
    const body = await response.json() as { accepted: boolean; eventId: string };
    expect(body.accepted).toBe(true);
    expect(body.eventId).toBe('evt-1');
  });

  it('returns 404 for unknown inbound status event', async () => {
    mockGetInboundReceiptStatus.mockResolvedValue(null);

    const response = await fetch(`${baseUrl}/api/inbound/status/missing-id`, {
      headers: {
        authorization: basicAuthHeader('postmark-user', 'postmark-pass'),
      },
    });

    expect(response.status).toBe(404);
  });
});

```

### `server/src/routes/inboundEmail.ts`

```typescript
import { Request, Response, Router } from 'express';
import rateLimit from 'express-rate-limit';
import {
  enqueuePostmarkInboundReceipt,
  getInboundReceiptStatus,
  PostmarkInboundPayload,
} from '../services/inboundReceiptWorker.js';

const router = Router();

const inboundLimiter = rateLimit({
  windowMs: 60_000,
  max: 120,
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many inbound requests. Please retry shortly.' },
});

function parseBasicAuthHeader(authHeader: string): { username: string; password: string } | null {
  if (!authHeader.startsWith('Basic ')) return null;
  const encoded = authHeader.slice('Basic '.length);
  try {
    const decoded = Buffer.from(encoded, 'base64').toString('utf-8');
    const separator = decoded.indexOf(':');
    if (separator === -1) return null;
    return {
      username: decoded.slice(0, separator),
      password: decoded.slice(separator + 1),
    };
  } catch {
    return null;
  }
}

function requireInboundAuth(req: Request, res: Response, next: () => void): void {
  const expectedUsername = process.env.POSTMARK_INBOUND_USERNAME;
  const expectedPassword = process.env.POSTMARK_INBOUND_PASSWORD;

  if (!expectedUsername || !expectedPassword) {
    res.status(503).json({ error: 'Inbound webhook credentials are not configured' });
    return;
  }

  const authHeader = req.headers.authorization || '';
  const parsed = parseBasicAuthHeader(authHeader);
  if (!parsed || parsed.username !== expectedUsername || parsed.password !== expectedPassword) {
    res.setHeader('WWW-Authenticate', 'Basic realm="orderpulse-inbound"');
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
}

router.post('/postmark', inboundLimiter, requireInboundAuth, async (req: Request, res: Response) => {
  try {
    const payload = req.body as PostmarkInboundPayload;
    if (!payload || typeof payload !== 'object') {
      return res.status(400).json({ error: 'Invalid payload' });
    }

    const result = await enqueuePostmarkInboundReceipt(payload);
    res.status(202).json({
      accepted: true,
      eventId: result.eventId,
      duplicate: result.duplicate,
      status: result.status,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Failed to enqueue inbound receipt';
    if (message.toLowerCase().includes('invalid postmark payload')) {
      return res.status(400).json({ error: message });
    }
    console.error('Inbound webhook error:', error);
    res.status(500).json({ error: 'Failed to process inbound webhook' });
  }
});

router.get('/status/:eventId', requireInboundAuth, async (req: Request, res: Response) => {
  try {
    const status = await getInboundReceiptStatus(req.params.eventId);
    if (!status) {
      return res.status(404).json({ error: 'Inbound event not found' });
    }
    res.json(status);
  } catch (error) {
    console.error('Inbound status lookup error:', error);
    res.status(500).json({ error: 'Failed to load inbound event status' });
  }
});

export default router;

```

### `server/src/routes/integrations.test.ts`

```typescript
import express from 'express';
import { createHmac } from 'node:crypto';
import { AddressInfo } from 'node:net';
import type { Server } from 'node:http';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const mocks = vi.hoisted(() => ({
  buildQuickBooksAuthUrl: vi.fn(),
  exchangeQuickBooksCodeForTokens: vi.fn(),
  fetchQuickBooksCompanyName: vi.fn(),
  revokeQuickBooksToken: vi.fn(),
  buildXeroAuthUrl: vi.fn(),
  exchangeXeroCodeForTokens: vi.fn(),
  fetchXeroTenants: vi.fn(),
  fetchXeroOrganizationName: vi.fn(),
  revokeXeroConnection: vi.fn(),
  upsertProviderConnection: vi.fn(),
  listProviderConnectionsForUser: vi.fn(),
  deleteProviderConnectionForUser: vi.fn(),
  listProviderSyncRunsForConnection: vi.fn(),
  insertWebhookEvent: vi.fn(),
  markWebhookEventProcessed: vi.fn(),
  getProviderConnectionByIdForUser: vi.fn(),
  getProviderConnectionByProviderTenant: vi.fn(),
  enqueueProviderSync: vi.fn(),
  enqueueProviderSyncByTenant: vi.fn(),
}));

vi.mock('../config.js', () => ({
  enableAccountingConnectors: true,
}));

vi.mock('../services/integrations/quickbooksOAuth.js', () => ({
  buildQuickBooksAuthUrl: mocks.buildQuickBooksAuthUrl,
  exchangeQuickBooksCodeForTokens: mocks.exchangeQuickBooksCodeForTokens,
  fetchQuickBooksCompanyName: mocks.fetchQuickBooksCompanyName,
  revokeQuickBooksToken: mocks.revokeQuickBooksToken,
}));

vi.mock('../services/integrations/xeroOAuth.js', () => ({
  buildXeroAuthUrl: mocks.buildXeroAuthUrl,
  exchangeXeroCodeForTokens: mocks.exchangeXeroCodeForTokens,
  fetchXeroTenants: mocks.fetchXeroTenants,
  fetchXeroOrganizationName: mocks.fetchXeroOrganizationName,
  revokeXeroConnection: mocks.revokeXeroConnection,
}));

vi.mock('../services/integrations/store.js', () => ({
  upsertProviderConnection: mocks.upsertProviderConnection,
  listProviderConnectionsForUser: mocks.listProviderConnectionsForUser,
  deleteProviderConnectionForUser: mocks.deleteProviderConnectionForUser,
  listProviderSyncRunsForConnection: mocks.listProviderSyncRunsForConnection,
  insertWebhookEvent: mocks.insertWebhookEvent,
  markWebhookEventProcessed: mocks.markWebhookEventProcessed,
  getProviderConnectionByIdForUser: mocks.getProviderConnectionByIdForUser,
  getProviderConnectionByProviderTenant: mocks.getProviderConnectionByProviderTenant,
}));

vi.mock('../services/integrations/syncOrchestrator.js', () => ({
  enqueueProviderSync: mocks.enqueueProviderSync,
  enqueueProviderSyncByTenant: mocks.enqueueProviderSyncByTenant,
}));

async function startServer(authenticated = true): Promise<{ server: Server; baseUrl: string }> {
  const { integrationsRouter } = await import('./integrations.js');
  const app = express();
  app.use(express.json({
    verify: (req, _res, buf) => {
      (req as any).rawBody = buf.toString('utf8');
    },
  }));
  app.use((req, _res, next) => {
    (req as any).session = authenticated ? { userId: 'user-1' } : {};
    next();
  });
  app.use('/api/integrations', integrationsRouter);

  const server = app.listen(0);
  await new Promise<void>((resolve) => server.once('listening', resolve));
  const address = server.address() as AddressInfo;

  return {
    server,
    baseUrl: `http://127.0.0.1:${address.port}`,
  };
}

describe('integrations routes', () => {
  let server: Server | null = null;
  let baseUrl = '';

  beforeEach(async () => {
    vi.resetModules();
    vi.clearAllMocks();

    process.env.FRONTEND_URL = 'http://localhost:5173';
    process.env.QUICKBOOKS_WEBHOOK_VERIFIER_TOKEN = 'test-webhook-secret';

    mocks.buildQuickBooksAuthUrl.mockImplementation((state: string) => `https://qbo.example/connect?state=${state}`);
    mocks.exchangeQuickBooksCodeForTokens.mockResolvedValue({
      accessToken: 'access-token',
      refreshToken: 'refresh-token',
      tokenExpiresAt: new Date('2026-12-01T00:00:00Z'),
      scope: 'com.intuit.quickbooks.accounting',
    });
    mocks.fetchQuickBooksCompanyName.mockResolvedValue('Acme Inc');
    mocks.upsertProviderConnection.mockResolvedValue({ id: 'conn-1' });
    mocks.enqueueProviderSync.mockResolvedValue({ runId: 'run-1' });
    mocks.listProviderConnectionsForUser.mockResolvedValue([
      { id: 'conn-1', provider: 'quickbooks', status: 'connected' },
    ]);
    mocks.listProviderSyncRunsForConnection.mockResolvedValue([
      { id: 'run-1', status: 'success', trigger: 'manual' },
    ]);

    mocks.getProviderConnectionByProviderTenant.mockResolvedValue({ id: 'conn-1' });
    mocks.insertWebhookEvent.mockResolvedValue({ inserted: true, eventId: 'evt-1' });
    mocks.markWebhookEventProcessed.mockResolvedValue(undefined);
    mocks.enqueueProviderSyncByTenant.mockResolvedValue({ runId: 'run-2' });
    mocks.getProviderConnectionByIdForUser.mockResolvedValue({
      id: 'conn-1',
      provider: 'quickbooks',
      refreshTokenEncrypted: 'encrypted-refresh',
      accessTokenEncrypted: 'encrypted-access',
      metadata: {},
    });
    mocks.deleteProviderConnectionForUser.mockResolvedValue(true);
    mocks.revokeQuickBooksToken.mockResolvedValue(undefined);
    mocks.revokeXeroConnection.mockResolvedValue(undefined);

    ({ server, baseUrl } = await startServer(true));
  });

  afterEach(async () => {
    if (server) {
      await new Promise<void>((resolve, reject) => {
        server?.close((err) => (err ? reject(err) : resolve()));
      });
      server = null;
    }
  });

  it('requires authentication for connect endpoint', async () => {
    if (server) {
      await new Promise<void>((resolve, reject) => {
        server?.close((err) => (err ? reject(err) : resolve()));
      });
      server = null;
    }

    ({ server, baseUrl } = await startServer(false));

    const response = await fetch(`${baseUrl}/api/integrations/quickbooks/connect`, {
      method: 'POST',
    });

    expect(response.status).toBe(401);
  });

  it('connect + callback stores QuickBooks connection and enqueues backfill', async () => {
    const connectResponse = await fetch(`${baseUrl}/api/integrations/quickbooks/connect`, {
      method: 'POST',
    });

    expect(connectResponse.status).toBe(200);
    const connectPayload = await connectResponse.json() as { authUrl: string };
    const authUrl = new URL(connectPayload.authUrl);
    const state = authUrl.searchParams.get('state');
    expect(state).toBeTruthy();

    const callbackResponse = await fetch(
      `${baseUrl}/api/integrations/quickbooks/callback?code=abc123&state=${encodeURIComponent(state!)}&realmId=123456`,
      { redirect: 'manual' },
    );

    expect(callbackResponse.status).toBe(302);
    expect(mocks.exchangeQuickBooksCodeForTokens).toHaveBeenCalledWith('abc123');
    expect(mocks.upsertProviderConnection).toHaveBeenCalledTimes(1);
    expect(mocks.enqueueProviderSync).toHaveBeenCalledWith('conn-1', 'user-1', 'backfill');
  });

  it('starts manual sync and returns run id', async () => {
    const response = await fetch(`${baseUrl}/api/integrations/connections/conn-1/sync`, {
      method: 'POST',
    });

    expect(response.status).toBe(202);
    const payload = await response.json() as { runId: string };
    expect(payload.runId).toBe('run-1');
    expect(mocks.enqueueProviderSync).toHaveBeenCalledWith('conn-1', 'user-1', 'manual');
  });

  it('returns 404 when manual sync connection is not found', async () => {
    mocks.enqueueProviderSync.mockRejectedValueOnce(new Error('Provider connection not found.'));

    const response = await fetch(`${baseUrl}/api/integrations/connections/missing/sync`, {
      method: 'POST',
    });

    expect(response.status).toBe(404);
    const payload = await response.json() as { error: string };
    expect(payload.error).toContain('Provider connection not found');
  });

  it('lists provider connections for authenticated user', async () => {
    const response = await fetch(`${baseUrl}/api/integrations/connections`);

    expect(response.status).toBe(200);
    const payload = await response.json() as { connections: Array<{ id: string }> };
    expect(payload.connections).toHaveLength(1);
    expect(payload.connections[0].id).toBe('conn-1');
    expect(mocks.listProviderConnectionsForUser).toHaveBeenCalledWith('user-1');
  });

  it('lists sync runs for authenticated user connection', async () => {
    const response = await fetch(`${baseUrl}/api/integrations/connections/conn-1/runs`);

    expect(response.status).toBe(200);
    const payload = await response.json() as { runs: Array<{ id: string }> };
    expect(payload.runs).toHaveLength(1);
    expect(payload.runs[0].id).toBe('run-1');
    expect(mocks.listProviderSyncRunsForConnection).toHaveBeenCalledWith('conn-1', 'user-1');
  });

  it('disconnects QuickBooks connection and attempts token revoke', async () => {
    const response = await fetch(`${baseUrl}/api/integrations/connections/conn-1`, {
      method: 'DELETE',
    });

    expect(response.status).toBe(200);
    expect(mocks.getProviderConnectionByIdForUser).toHaveBeenCalledWith('conn-1', 'user-1');
    expect(mocks.deleteProviderConnectionForUser).toHaveBeenCalledWith('conn-1', 'user-1');
  });

  it('accepts QuickBooks webhook, validates signature, and enqueues sync by tenant', async () => {
    const payload = {
      eventNotifications: [
        {
          realmId: 'realm-1',
          dataChangeEvent: {
            entities: [
              {
                name: 'PurchaseOrder',
                id: 'po-100',
                operation: 'Update',
                lastUpdated: '2026-02-17T10:00:00Z',
              },
            ],
          },
        },
      ],
    };

    const rawBody = JSON.stringify(payload);
    const signature = createHmac('sha256', process.env.QUICKBOOKS_WEBHOOK_VERIFIER_TOKEN!).update(rawBody).digest('base64');

    const response = await fetch(`${baseUrl}/api/integrations/webhooks/quickbooks`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'intuit-signature': signature,
      },
      body: rawBody,
    });

    expect(response.status).toBe(202);
    const responsePayload = await response.json() as { accepted: boolean; signatureValid: boolean };
    expect(responsePayload.accepted).toBe(true);
    expect(responsePayload.signatureValid).toBe(true);

    expect(mocks.insertWebhookEvent).toHaveBeenCalledTimes(1);
    expect(mocks.enqueueProviderSyncByTenant).toHaveBeenCalledWith(
      'quickbooks',
      'realm-1',
      'webhook',
      { externalIds: ['po-100'] },
    );
    expect(mocks.markWebhookEventProcessed).toHaveBeenCalledWith('evt-1', 'processed');
  });

  it('marks webhook events ignored when no matching realm connection exists', async () => {
    mocks.getProviderConnectionByProviderTenant.mockResolvedValueOnce(null);

    const payload = {
      eventNotifications: [
        {
          realmId: 'realm-missing',
          dataChangeEvent: {
            entities: [
              {
                name: 'PurchaseOrder',
                id: 'po-200',
                operation: 'Update',
                lastUpdated: '2026-02-17T10:00:00Z',
              },
            ],
          },
        },
      ],
    };

    const rawBody = JSON.stringify(payload);
    const signature = createHmac('sha256', process.env.QUICKBOOKS_WEBHOOK_VERIFIER_TOKEN!).update(rawBody).digest('base64');

    const response = await fetch(`${baseUrl}/api/integrations/webhooks/quickbooks`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'intuit-signature': signature,
      },
      body: rawBody,
    });

    expect(response.status).toBe(202);
    expect(mocks.markWebhookEventProcessed).toHaveBeenCalledWith('evt-1', 'ignored');
    expect(mocks.enqueueProviderSyncByTenant).not.toHaveBeenCalled();
  });

  it('ignores webhook events with invalid signature', async () => {
    const payload = {
      eventNotifications: [
        {
          realmId: 'realm-1',
          dataChangeEvent: {
            entities: [
              {
                name: 'PurchaseOrder',
                id: 'po-333',
                operation: 'Update',
                lastUpdated: '2026-02-17T10:00:00Z',
              },
            ],
          },
        },
      ],
    };

    const response = await fetch(`${baseUrl}/api/integrations/webhooks/quickbooks`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'intuit-signature': 'invalid-signature',
      },
      body: JSON.stringify(payload),
    });

    expect(response.status).toBe(202);
    const responsePayload = await response.json() as { signatureValid: boolean };
    expect(responsePayload.signatureValid).toBe(false);
    expect(mocks.markWebhookEventProcessed).toHaveBeenCalledWith('evt-1', 'ignored');
    expect(mocks.enqueueProviderSyncByTenant).not.toHaveBeenCalled();
  });

  it('requires auth for runs endpoint', async () => {
    if (server) {
      await new Promise<void>((resolve, reject) => {
        server?.close((err) => (err ? reject(err) : resolve()));
      });
      server = null;
    }

    ({ server, baseUrl } = await startServer(false));

    const response = await fetch(`${baseUrl}/api/integrations/connections/conn-1/runs`);
    expect(response.status).toBe(401);
  });
});

```

### `server/src/routes/integrations.ts`

```typescript
import { createHmac, randomBytes, timingSafeEqual } from 'node:crypto';
import { Request, Response, Router } from 'express';
import { decrypt, encrypt } from '../utils/encryption.js';
import {
  buildQuickBooksAuthUrl,
  exchangeQuickBooksCodeForTokens,
  fetchQuickBooksCompanyName,
  revokeQuickBooksToken,
} from '../services/integrations/quickbooksOAuth.js';
import {
  buildXeroAuthUrl,
  exchangeXeroCodeForTokens,
  fetchXeroOrganizationName,
  fetchXeroTenants,
  revokeXeroConnection,
} from '../services/integrations/xeroOAuth.js';
import {
  deleteProviderConnectionForUser,
  getProviderConnectionByIdForUser,
  getProviderConnectionByProviderTenant,
  insertWebhookEvent,
  listProviderConnectionsForUser,
  listProviderSyncRunsForConnection,
  markWebhookEventProcessed,
  upsertProviderConnection,
} from '../services/integrations/store.js';
import { IntegrationProvider } from '../services/integrations/types.js';
import { enqueueProviderSync, enqueueProviderSyncByTenant } from '../services/integrations/syncOrchestrator.js';
import { enableAccountingConnectors } from '../config.js';

const router = Router();
const OAUTH_STATE_TTL_MS = 10 * 60 * 1000;

const oauthStateStore = new Map<string, { userId: string; provider: IntegrationProvider; expiresAt: number }>();

function isSupportedProvider(value: string): value is IntegrationProvider {
  return value === 'quickbooks' || value === 'xero';
}

function requireAuth(req: Request, res: Response, next: () => void): void {
  if (!req.session?.userId) {
    res.status(401).json({ error: 'Not authenticated' });
    return;
  }
  next();
}

function requireConnectorsEnabled(res: Response): boolean {
  if (!enableAccountingConnectors) {
    res.status(404).json({ error: 'Accounting connectors are disabled' });
    return false;
  }
  return true;
}

function pruneOauthStateStore(now = Date.now()): void {
  for (const [key, value] of oauthStateStore.entries()) {
    if (value.expiresAt <= now) {
      oauthStateStore.delete(key);
    }
  }
}

function createOauthState(userId: string, provider: IntegrationProvider): string {
  const state = randomBytes(18).toString('hex');
  oauthStateStore.set(state, {
    userId,
    provider,
    expiresAt: Date.now() + OAUTH_STATE_TTL_MS,
  });
  pruneOauthStateStore();
  return state;
}

function consumeOauthState(state: string): { userId: string; provider: IntegrationProvider } | null {
  const value = oauthStateStore.get(state);
  if (!value) return null;
  oauthStateStore.delete(state);
  if (value.expiresAt < Date.now()) return null;
  return {
    userId: value.userId,
    provider: value.provider,
  };
}

function frontendRedirectUrl(provider: IntegrationProvider, status: 'connected' | 'error', reason?: string): string {
  const base = process.env.FRONTEND_URL || 'http://localhost:5173';
  const url = new URL(base);
  url.searchParams.set('integration_provider', provider);
  url.searchParams.set('integration_status', status);
  if (reason) {
    url.searchParams.set('integration_reason', reason);
  }
  return url.toString();
}

router.post('/:provider/connect', requireAuth, async (req: Request, res: Response) => {
  if (!requireConnectorsEnabled(res)) return;

  const provider = req.params.provider;
  if (!isSupportedProvider(provider)) {
    return res.status(400).json({ error: 'provider must be quickbooks or xero' });
  }

  try {
    const state = createOauthState(req.session.userId!, provider);
    const authUrl = provider === 'quickbooks'
      ? buildQuickBooksAuthUrl(state)
      : buildXeroAuthUrl(state);

    res.json({ authUrl });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Failed to build connect URL';
    res.status(500).json({ error: message });
  }
});

router.get('/:provider/callback', async (req: Request, res: Response) => {
  if (!requireConnectorsEnabled(res)) return;

  const provider = req.params.provider;
  if (!isSupportedProvider(provider)) {
    return res.status(400).json({ error: 'provider must be quickbooks or xero' });
  }

  const code = typeof req.query.code === 'string' ? req.query.code : '';
  const state = typeof req.query.state === 'string' ? req.query.state : '';

  if (!code || !state) {
    return res.redirect(frontendRedirectUrl(provider, 'error', 'missing_code_or_state'));
  }

  const consumedState = consumeOauthState(state);
  if (!consumedState || consumedState.provider !== provider) {
    return res.redirect(frontendRedirectUrl(provider, 'error', 'invalid_state'));
  }

  if (!req.session?.userId || req.session.userId !== consumedState.userId) {
    return res.redirect(frontendRedirectUrl(provider, 'error', 'not_authenticated'));
  }

  try {
    if (provider === 'quickbooks') {
      const realmId = typeof req.query.realmId === 'string' ? req.query.realmId : '';
      if (!realmId) {
        return res.redirect(frontendRedirectUrl(provider, 'error', 'missing_realm_id'));
      }

      const tokens = await exchangeQuickBooksCodeForTokens(code);
      const tenantName = await fetchQuickBooksCompanyName(realmId, tokens.accessToken);

      const connection = await upsertProviderConnection({
        userId: consumedState.userId,
        provider,
        tenantId: realmId,
        tenantName,
        accessTokenEncrypted: encrypt(tokens.accessToken),
        refreshTokenEncrypted: encrypt(tokens.refreshToken),
        tokenExpiresAt: tokens.tokenExpiresAt,
        scope: tokens.scope,
        metadata: {
          realmId,
        },
      });

      await enqueueProviderSync(connection.id, consumedState.userId, 'backfill');
      return res.redirect(frontendRedirectUrl(provider, 'connected'));
    }

    const tokens = await exchangeXeroCodeForTokens(code);
    const tenants = await fetchXeroTenants(tokens.accessToken);
    if (!tenants.length) {
      return res.redirect(frontendRedirectUrl(provider, 'error', 'no_tenants'));
    }

    const requestedTenantId = typeof req.query.tenantId === 'string' ? req.query.tenantId : '';
    const selectedTenant = requestedTenantId
      ? tenants.find((tenant) => tenant.tenantId === requestedTenantId)
      : tenants[0];

    if (!selectedTenant) {
      return res.redirect(frontendRedirectUrl(provider, 'error', 'tenant_not_found'));
    }

    const tenantName = await fetchXeroOrganizationName(selectedTenant.tenantId, tokens.accessToken)
      || selectedTenant.tenantName;

    const connection = await upsertProviderConnection({
      userId: consumedState.userId,
      provider,
      tenantId: selectedTenant.tenantId,
      tenantName,
      accessTokenEncrypted: encrypt(tokens.accessToken),
      refreshTokenEncrypted: encrypt(tokens.refreshToken),
      tokenExpiresAt: tokens.tokenExpiresAt,
      scope: tokens.scope,
      metadata: {
        tenantType: selectedTenant.tenantType,
        candidateTenantCount: tenants.length,
        xeroConnectionId: selectedTenant.id,
      },
    });

    await enqueueProviderSync(connection.id, consumedState.userId, 'backfill');
    return res.redirect(frontendRedirectUrl(provider, 'connected'));
  } catch (error) {
    const reason = error instanceof Error ? error.message : 'oauth_failure';
    return res.redirect(frontendRedirectUrl(provider, 'error', reason.slice(0, 120)));
  }
});

router.get('/connections', requireAuth, async (req: Request, res: Response) => {
  if (!requireConnectorsEnabled(res)) return;

  try {
    const connections = await listProviderConnectionsForUser(req.session.userId!);
    res.json({ connections });
  } catch (error) {
    res.status(500).json({ error: 'Failed to load integration connections' });
  }
});

router.delete('/connections/:connectionId', requireAuth, async (req: Request, res: Response) => {
  if (!requireConnectorsEnabled(res)) return;

  try {
    const connection = await getProviderConnectionByIdForUser(req.params.connectionId, req.session.userId!);
    if (!connection) {
      return res.status(404).json({ error: 'Connection not found' });
    }

    try {
      if (connection.provider === 'quickbooks') {
        const token = decrypt(connection.refreshTokenEncrypted) || decrypt(connection.accessTokenEncrypted);
        if (token) {
          await revokeQuickBooksToken(token);
        }
      } else {
        const accessToken = decrypt(connection.accessTokenEncrypted);
        const xeroConnectionId = (connection.metadata as Record<string, unknown> | undefined)?.xeroConnectionId;
        if (accessToken && typeof xeroConnectionId === 'string') {
          await revokeXeroConnection(xeroConnectionId, accessToken);
        }
      }
    } catch (error) {
      console.warn('Provider revoke failed during disconnect', {
        connectionId: connection.id,
        provider: connection.provider,
        error: error instanceof Error ? error.message : error,
      });
    }

    const deleted = await deleteProviderConnectionForUser(req.params.connectionId, req.session.userId!);
    if (!deleted) {
      return res.status(404).json({ error: 'Connection not found' });
    }
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to disconnect provider' });
  }
});

router.post('/connections/:connectionId/sync', requireAuth, async (req: Request, res: Response) => {
  if (!requireConnectorsEnabled(res)) return;

  try {
    const result = await enqueueProviderSync(req.params.connectionId, req.session.userId!, 'manual');
    res.status(202).json({ success: true, runId: result.runId });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Failed to start sync';
    const statusCode = message.includes('not found') ? 404 : 500;
    res.status(statusCode).json({ error: message });
  }
});

router.get('/connections/:connectionId/runs', requireAuth, async (req: Request, res: Response) => {
  if (!requireConnectorsEnabled(res)) return;

  try {
    const runs = await listProviderSyncRunsForConnection(req.params.connectionId, req.session.userId!);
    res.json({ runs });
  } catch (error) {
    res.status(500).json({ error: 'Failed to load sync runs' });
  }
});

function verifyQuickBooksWebhookSignature(payload: string, signatureHeader?: string): boolean {
  const verifier = process.env.QUICKBOOKS_WEBHOOK_VERIFIER_TOKEN;
  if (!verifier) return true;
  if (!signatureHeader) return false;

  const computed = createHmac('sha256', verifier).update(payload).digest('base64');

  const expected = Buffer.from(computed);
  const provided = Buffer.from(signatureHeader);

  if (expected.length !== provided.length) {
    return false;
  }

  return timingSafeEqual(expected, provided);
}

interface QuickBooksWebhookEntity {
  name?: string;
  id?: string;
  operation?: string;
  lastUpdated?: string;
}

router.post('/webhooks/quickbooks', async (req: Request, res: Response) => {
  if (!requireConnectorsEnabled(res)) return;

  const rawBody = (req as Request & { rawBody?: string }).rawBody || JSON.stringify(req.body || {});
  const signatureHeader = typeof req.headers['intuit-signature'] === 'string'
    ? req.headers['intuit-signature']
    : undefined;

  const signatureValid = verifyQuickBooksWebhookSignature(rawBody, signatureHeader);

  const notifications = Array.isArray(req.body?.eventNotifications)
    ? req.body.eventNotifications
    : [];

  const syncByRealm = new Map<string, Set<string>>();

  for (let i = 0; i < notifications.length; i += 1) {
    const notification = notifications[i] as Record<string, unknown>;
    const realmId = String(notification.realmId || '');
    const entities = Array.isArray((notification.dataChangeEvent as Record<string, unknown> | undefined)?.entities)
      ? ((notification.dataChangeEvent as Record<string, unknown>).entities as QuickBooksWebhookEntity[])
      : [];

    for (let j = 0; j < entities.length; j += 1) {
      const entity = entities[j];
      if (String(entity.name || '').toLowerCase() !== 'purchaseorder') continue;
      if (!entity.id || !realmId) continue;

      const providerEventId = `${realmId}:${entity.id}:${entity.lastUpdated || i + '-' + j}`;
      const connection = await getProviderConnectionByProviderTenant('quickbooks', realmId);

      const inserted = await insertWebhookEvent(
        'quickbooks',
        providerEventId,
        {
          realmId,
          entity,
          notification,
        },
        connection?.id || null,
        signatureValid,
      );

      if (!inserted.inserted || !inserted.eventId) {
        continue;
      }

      if (!signatureValid) {
        await markWebhookEventProcessed(inserted.eventId, 'ignored');
        continue;
      }

      if (!connection) {
        await markWebhookEventProcessed(inserted.eventId, 'ignored');
        continue;
      }

      const existing = syncByRealm.get(realmId) || new Set<string>();
      existing.add(String(entity.id));
      syncByRealm.set(realmId, existing);
      await markWebhookEventProcessed(inserted.eventId, 'processed');
    }
  }

  if (signatureValid) {
    for (const [realmId, ids] of syncByRealm.entries()) {
      await enqueueProviderSyncByTenant('quickbooks', realmId, 'webhook', {
        externalIds: Array.from(ids),
      });
    }
  }

  res.status(202).json({ accepted: true, signatureValid, notifications: notifications.length });
});

export { router as integrationsRouter };

```

### `server/src/routes/jobs.ts`

```typescript
// Jobs API - Background email processing
import { Router, Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import { google } from 'googleapis';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { getValidAccessToken } from './auth.js';
import { 
  jobManager,
  Job,
  ProcessedOrder,
} from '../services/jobManager.js';
import { 
  extractAsinsFromEmail, 
  getAmazonItemDetails 
} from '../services/amazon.js';
import {
  consolidateOrders,
  detectEmailType,
  extractOrderNumber,
  normalizeItemName,
  logConsolidationSummary,
  RawOrderData,
} from '../utils/orderConsolidation.js';
import {
  buildSupplierJobQuery,
  expandPrioritySupplierDomains,
  getSupplierLookbackMonths,
  sanitizeSupplierDomains,
} from './jobsQueryUtils.js';
import {
  buildFinalOrderSnapshot,
  buildLiveOrderSnapshot,
} from './jobsProcessingUtils.js';
import {
  analyzeEmailWithRetry as analyzeEmailWithRetryShared,
  createGeminiExtractionModel,
  normalizeOrderDate as normalizeExtractionOrderDate,
} from '../services/emailExtraction.js';
import {
  extractImageUrlsFromHtml,
  extractUrlsFromHtml,
  extractUrlsFromText,
  isJunkUrl,
  pickBestImageUrlForItem,
  pickBestProductUrlForItem,
  uniqueStrings,
} from '../utils/urlExtraction.js';

const router = Router();

// Rate limiters - more permissive to allow page refreshes
const jobsLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 15, // Allow more requests for page refreshes
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many job requests. Please wait a moment and try again.' },
  keyGenerator: (req: Request) => req.session?.userId || req.ip || 'anonymous',
});

const amazonLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 15, // Allow more requests for retries and refreshes
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many Amazon processing requests. Please wait a moment and try again.' },
  keyGenerator: (req: Request) => req.session?.userId || req.ip || 'anonymous',
});

function parseEmailDate(dateHeader?: string): string | null {
  if (!dateHeader) return null;
  const parsed = new Date(dateHeader);
  if (isNaN(parsed.getTime())) return null;
  return parsed.toISOString().split('T')[0];
}

function normalizeOrderDate(orderDate?: string, fallbackDate?: string): string {
  const candidates = [orderDate, fallbackDate];
  for (const candidate of candidates) {
    if (!candidate) continue;
    const parsed = new Date(candidate);
    if (!isNaN(parsed.getTime())) {
      return parsed.toISOString().split('T')[0];
    }
  }
  return new Date().toISOString().split('T')[0];
}

// Extract text from PDF attachments
async function extractPdfText(gmail: any, messageId: string, attachmentId: string): Promise<string> {
  try {
    const attachment = await gmail.users.messages.attachments.get({
      userId: 'me',
      messageId: messageId,
      id: attachmentId,
    });
    
    if (!attachment.data.data) {
      return '';
    }
    
    const buffer = Buffer.from(attachment.data.data, 'base64');
    
    // Dynamic import to handle ESM/CJS compatibility
    const pdfParseModule = await import('pdf-parse') as any;
    const pdfParse = pdfParseModule.default || pdfParseModule;
    const pdfData = await pdfParse(buffer);
    return pdfData.text;
  } catch (error) {
    console.error(`Failed to extract PDF text from attachment ${attachmentId}:`, error);
    return '';
  }
}

// Extract attachment info from email parts recursively
function findAttachments(parts: any[], attachments: Array<{ filename: string; attachmentId: string; mimeType: string }> = []): Array<{ filename: string; attachmentId: string; mimeType: string }> {
  for (const part of parts) {
    if (part.filename && part.body?.attachmentId) {
      attachments.push({
        filename: part.filename,
        attachmentId: part.body.attachmentId,
        mimeType: part.mimeType || '',
      });
    }
    if (part.parts) {
      findAttachments(part.parts, attachments);
    }
  }
  return attachments;
}

// Initialize Gemini AI client
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

const EXTRACTION_PROMPT = `You are an order extraction AI. Extract purchase data from emails.

CRITICAL: EXTRACT ACTUAL ITEM NAMES FROM THE EMAIL BODY
DO NOT use placeholders, generic descriptions, or the email subject as item names.
Look for REAL product names, SKUs, and part numbers in the email content.

ITEM EXTRACTION RULES:
1. Find the EXACT product name/description as written in the email
2. Include part numbers/SKUs when present (e.g., "S-1234 Industrial Tape" or "McMaster #91251A540")
3. Extract ALL items - emails often contain multiple line items
4. Look for item tables, order summaries, and line-by-line breakdowns
5. If you cannot find specific item names, set items to an EMPTY array []

AMAZON-SPECIFIC RULES:
- For Amazon orders, ALWAYS extract the ASIN (10-character code starting with B0 or 10 digits)
- Find ASINs in product URLs like amazon.com/dp/B08N5WRWNW or amazon.com/gp/product/B08N5WRWNW
- Also look for ASINs in image URLs or product links
- Set the "asin" field for each Amazon item

WHERE TO FIND ITEMS:
- Order confirmation tables
- Invoice line items
- "Items in your order" sections
- Shipping manifests
- Product name + quantity + price patterns

SUPPLIER RECOGNITION (these are ALWAYS orders):
- Industrial: McMaster-Carr, Grainger, Fastenal, ULine, MSC, Global Industrial, Zoro, Motion
- Electronics: DigiKey, Mouser, Newark, Allied, AutomationDirect, Misumi, RS Components
- General: Amazon, Costco, Home Depot, Lowes
- Shipping: FedEx, UPS, DHL invoices

Return JSON:
{
  "isOrder": true,
  "supplier": "Exact Company Name",
  "orderDate": "YYYY-MM-DD",
  "totalAmount": 123.45,
  "items": [
    {"name": "ACTUAL product name from email", "quantity": 2, "unit": "ea", "unitPrice": 10.50, "partNumber": "ABC-123", "asin": null},
    {"name": "Amazon Product Name", "quantity": 1, "unit": "ea", "unitPrice": 25.00, "partNumber": null, "asin": "B08N5WRWNW"}
  ],
  "confidence": 0.9
}

ONLY set isOrder: false for pure marketing, password resets, or newsletters.
If it's an order but you can't find specific items, still mark isOrder: true with items: []

If you cannot find an order date in the email body, use the email Date header (provided below).

EMAIL:
`;

// Prompt for humanizing Amazon product names into shop-floor friendly names
const NAME_HUMANIZATION_PROMPT = `You are a product naming assistant for a manufacturing shop floor. 
Convert verbose Amazon product names into short, practical names that workers would use.

RULES:
1. Keep the brand name if it's a recognized brand (DeWalt, Anker, 3M, etc.)
2. Keep the most important product descriptor (cable, drill, tape, etc.)
3. Keep critical specs like size/length if relevant (10ft, 1/4", 20V, etc.)
4. Remove marketing language, model numbers, compatibility lists, and color unless essential
5. Maximum 40 characters
6. Use Title Case

Examples:
- "Anker USB C Cable, PowerLine III USB A to USB C Charger Cable (10 ft), Premium Nylon USB A to USB Type C Cable for Samsung Galaxy S21, S10, Note 10, LG V20 G7 G6 and More" → "Anker USB-C Cable 10ft"
- "DEWALT 20V MAX XR Impact Driver Kit, Brushless, 1/4-Inch, 3-Speed (DCF887D2)" → "DeWalt 20V Impact Driver"
- "3M 2090 ScotchBlue Original Multi-Surface Painter's Tape, 1.88 inches x 60 yards, 2090, 1 Roll" → "3M Blue Painter's Tape 2in"
- "Amazon Basics AA 1.5 Volt Performance Alkaline Batteries - Pack of 48" → "Amazon Basics AA Batteries 48pk"

Return ONLY the shortened name, nothing else.

Product name to simplify:
`;

// Helper function to delay execution
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Simple fallback name shortening without AI
function shortenNameFallback(name: string): string {
  if (!name || name.length <= 40) return name;
  
  // Try to get meaningful first part
  let shortened = name.split(',')[0].trim();
  
  // If still too long, try splitting by common separators
  if (shortened.length > 40) {
    shortened = name.split(' - ')[0].trim();
  }
  if (shortened.length > 40) {
    shortened = name.split('|')[0].trim();
  }
  
  // Final truncation if needed
  if (shortened.length > 40) {
    shortened = shortened.substring(0, 37) + '...';
  }
  
  return shortened;
}

// Humanize a batch of product names using Gemini
async function humanizeProductNames(
  names: string[]
): Promise<Map<string, string>> {
  const results = new Map<string, string>();
  
  if (names.length === 0) {
    return results;
  }
  
  const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
  
  // Track if we hit rate limit - stop trying if so
  let rateLimitHit = false;
  let successCount = 0;
  
  // Process in batches of 5 to be more conservative with rate limits
  const batchSize = 5;
  
  for (let i = 0; i < names.length; i += batchSize) {
    const batch = names.slice(i, i + batchSize);
    
    // Process each name in the batch
    for (const name of batch) {
      // Skip if already short enough or empty
      if (!name || name.length <= 40) {
        results.set(name, name);
        continue;
      }
      
      // If we hit rate limit, use fallback for all remaining
      if (rateLimitHit) {
        results.set(name, shortenNameFallback(name));
        continue;
      }
      
      try {
        const result = await model.generateContent(NAME_HUMANIZATION_PROMPT + name);
        const response = result.response;
        const humanized = response.text().trim();
        
        // Validate the response - should be short and not contain weird characters
        if (humanized && humanized.length <= 50 && !humanized.includes('\n')) {
          results.set(name, humanized);
          successCount++;
          console.log(`  📝 "${name.substring(0, 40)}..." → "${humanized}"`);
        } else {
          // Fallback: truncate and clean up
          results.set(name, shortenNameFallback(name));
        }
      } catch (error: any) {
        // Check if it's a rate limit error
        if (error?.status === 429 || error?.message?.includes('429') || error?.message?.includes('quota')) {
          console.warn(`⚠️ Gemini rate limit hit after ${successCount} names - using fallback for remaining ${names.length - i} items`);
          rateLimitHit = true;
          results.set(name, shortenNameFallback(name));
        } else {
          console.error(`Failed to humanize "${name.substring(0, 30)}...":`, error?.message || error);
          results.set(name, shortenNameFallback(name));
        }
      }
      
      // Delay between requests to avoid rate limits
      await delay(200);
    }
    
    // Longer delay between batches
    if (i + batchSize < names.length && !rateLimitHit) {
      await delay(1000);
    }
  }
  
  console.log(`📝 Humanized ${successCount}/${names.length} names with AI, ${names.length - successCount} used fallback`);
  
  return results;
}

// Recursively extract text from email parts
function extractBodiesFromParts(parts: any[] | undefined): { html: string; plain: string } {
  let html = '';
  let plain = '';

  if (!parts) return { html, plain };

  for (const part of parts) {
    if (part.mimeType === 'text/plain' && part.body?.data) {
      const decoded = Buffer.from(part.body.data, 'base64').toString('utf-8');
      if (decoded.length > plain.length) {
        plain = decoded;
      }
    } else if (part.mimeType === 'text/html' && part.body?.data) {
      const decoded = Buffer.from(part.body.data, 'base64').toString('utf-8');
      if (decoded.length > html.length) {
        html = decoded;
      }
    } else if (part.parts) {
      const nested = extractBodiesFromParts(part.parts);
      if (nested.plain.length > plain.length) {
        plain = nested.plain;
      }
      if (nested.html.length > html.length) {
        html = nested.html;
      }
    }
  }

  return { html, plain };
}

function _extractTextFromParts(parts: any[]): string {
  let text = '';
  
  for (const part of parts) {
    if (part.mimeType === 'text/plain' && part.body?.data) {
      const decoded = Buffer.from(part.body.data, 'base64').toString('utf-8');
      if (decoded.length > text.length) {
        text = decoded;
      }
    } else if (part.mimeType === 'text/html' && part.body?.data && text.length === 0) {
      // Only use HTML if we don't have plain text
      text = Buffer.from(part.body.data, 'base64').toString('utf-8');
    } else if (part.parts) {
      // Recursively check nested parts
      const nestedText = _extractTextFromParts(part.parts);
      if (nestedText.length > text.length) {
        text = nestedText;
      }
    }
  }
  
  return text;
}

// Strip HTML tags for cleaner analysis - preserves table structure
function stripHtml(html: string): string {
  return html
    // Remove style and script tags entirely
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    .replace(/<head[^>]*>[\s\S]*?<\/head>/gi, '')
    // Convert table structure to readable format
    .replace(/<\/tr>/gi, '\n')
    .replace(/<\/td>/gi, ' | ')
    .replace(/<\/th>/gi, ' | ')
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<\/p>/gi, '\n')
    .replace(/<\/div>/gi, '\n')
    .replace(/<\/li>/gi, '\n')
    .replace(/<hr[^>]*>/gi, '\n---\n')
    // Remove remaining HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&dollar;/g, '$')
    .replace(/&#36;/g, '$')
    // Clean up whitespace while preserving line structure
    .replace(/[ \t]+/g, ' ')
    .replace(/\n\s*\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

// Analyze a single email with retry logic
async function analyzeEmailWithRetry(
  model: any,
  email: { id: string; subject: string; sender: string; body: string; date?: string },
  maxRetries: number = 3
): Promise<any> {
  // Clean the body - strip HTML if needed
  let cleanBody = email.body;
  if (cleanBody.includes('<html') || cleanBody.includes('<div') || cleanBody.includes('<table')) {
    cleanBody = stripHtml(cleanBody);
  }
  
  const emailContent = `
Subject: ${email.subject}
From: ${email.sender}
Date: ${email.date || 'Unknown'}
Content:
${cleanBody.substring(0, 8000)}
`;

  // Debug: log what we're analyzing
  console.log(`🔍 Analyzing: "${email.subject}" from ${email.sender}`);
  console.log(`   Body length: ${cleanBody.length} chars (original: ${email.body.length})`);
  if (cleanBody.length < 50) {
    console.log(`   ⚠️ Very short body: "${cleanBody.substring(0, 100)}"`);
  }

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const result = await model.generateContent(EXTRACTION_PROMPT + emailContent);
      const response = result.response;
      const text = response.text();
      
      // Debug: log raw response
      console.log(`   Gemini response (${text.length} chars): ${text.substring(0, 200)}...`);
      
      // Parse JSON from response
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        console.log(`   ❌ No JSON found in response`);
        // Fallback: check for order keywords in the original email
        const fallbackResult = keywordFallbackDetection(email, cleanBody);
        if (fallbackResult.isOrder) {
          console.log(`   🔄 Keyword fallback triggered: detected as order`);
          return fallbackResult;
        }
        return { emailId: email.id, isOrder: false, items: [], confidence: 0 };
      }
      
      let parsed = JSON.parse(jsonMatch[0]);
      
      // FALLBACK 1: If Gemini says not an order but we see clear signals, override
      if (!parsed.isOrder) {
        const fallbackResult = keywordFallbackDetection(email, cleanBody);
        if (fallbackResult.isOrder) {
          console.log(`   🔄 Keyword fallback OVERRIDE: Gemini said no order but keywords detected`);
          parsed = { ...parsed, ...fallbackResult };
        }
      }
      
      // FALLBACK 2: If Gemini says it IS an order but returns no items, try extracting ourselves
      if (parsed.isOrder && (!parsed.items || parsed.items.length === 0)) {
        console.log(`   ⚠️ Gemini returned order with no items, trying regex extraction...`);
        const extractedItems = extractItemsFromBody(cleanBody);
        if (extractedItems.length > 0) {
          console.log(`   ✅ Regex extraction found ${extractedItems.length} items`);
          parsed.items = extractedItems;
          parsed.totalAmount = extractedItems.reduce((sum: number, item: any) => 
            sum + (item.totalPrice || item.unitPrice || 0), 0);
        }
      }

      // Normalize order date (prefer email header date if missing/invalid)
      parsed.orderDate = normalizeOrderDate(parsed.orderDate, email.date);
      
      console.log(`   Result: isOrder=${parsed.isOrder}, items=${parsed.items?.length || 0}, supplier=${parsed.supplier}`);
      
      return {
        emailId: email.id,
        ...parsed,
      };
    } catch (error: any) {
      const isRateLimit = error.status === 429 || error.status === 403;
      const isLastAttempt = attempt === maxRetries - 1;
      
      if (isRateLimit && !isLastAttempt) {
        // Exponential backoff: 2s, 4s, 8s...
        const waitTime = Math.pow(2, attempt + 1) * 1000;
        console.log(`   ⏳ Rate limited, waiting ${waitTime/1000}s...`);
        await delay(waitTime);
        continue;
      }
      
      console.error(`   ❌ Parse error for email ${email.id}:`, error.message || error);
      // Try keyword fallback on error too
      const fallbackResult = keywordFallbackDetection(email, cleanBody);
      if (fallbackResult.isOrder) {
        console.log(`   🔄 Error recovery: keyword fallback detected order`);
        return fallbackResult;
      }
      return { emailId: email.id, isOrder: false, items: [], confidence: 0 };
    }
  }
  
  return { emailId: email.id, isOrder: false, items: [], confidence: 0 };
}

// Extract items from email body using regex patterns
function extractItemsFromBody(body: string): any[] {
  const items: any[] = [];
  const seenNames = new Set<string>();
  
  // Pattern 1: "Product Name" followed by price like "$XX.XX"
  // e.g., "Anker USB-C Cable $12.99"
  const priceLinePattern = /([A-Z][^$\n]{5,60})\s*\$(\d+\.?\d*)/gi;
  let match;
  while ((match = priceLinePattern.exec(body)) !== null) {
    const name = match[1].trim();
    const price = parseFloat(match[2]);
    // Skip if looks like totals or if already seen
    if (!name.toLowerCase().includes('total') && 
        !name.toLowerCase().includes('subtotal') && 
        !name.toLowerCase().includes('shipping') &&
        !name.toLowerCase().includes('tax') &&
        !seenNames.has(name.toLowerCase())) {
      seenNames.add(name.toLowerCase());
      items.push({
        name,
        normalizedName: name.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim(),
        quantity: 1,
        unit: 'ea',
        unitPrice: price,
        totalPrice: price
      });
    }
  }
  
  // Pattern 2: "Item # XXXXX" followed by product name and price
  // e.g., Costco format: "Item # 1732381 $19.99"
  const itemNumberPattern = /Item\s*#?\s*:?\s*(\d+)[^$]*\$(\d+\.?\d*)/gi;
  while ((match = itemNumberPattern.exec(body)) !== null) {
    const sku = match[1];
    const price = parseFloat(match[2]);
    // Try to get the product name before "Item #"
    const beforeMatch = body.substring(Math.max(0, match.index - 100), match.index);
    const lines = beforeMatch.split('\n').filter(l => l.trim().length > 10);
    const productName = lines[lines.length - 1]?.trim() || `Item ${sku}`;
    
    if (!seenNames.has(productName.toLowerCase()) && price > 0) {
      seenNames.add(productName.toLowerCase());
      items.push({
        name: productName,
        normalizedName: productName.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim(),
        sku,
        quantity: 1,
        unit: 'ea',
        unitPrice: price,
        totalPrice: price
      });
    }
  }
  
  // Pattern 3: Qty/Quantity followed by a number
  // e.g., "Qty: 2" or "Quantity 3"
  const qtyPattern = /([A-Za-z][^|\n]{5,60})\s*(?:Qty|Quantity)\s*:?\s*(\d+)\s*[|\s]*\$?(\d+\.?\d*)?/gi;
  while ((match = qtyPattern.exec(body)) !== null) {
    const name = match[1].trim();
    const qty = parseInt(match[2], 10);
    const price = match[3] ? parseFloat(match[3]) : 0;
    
    if (!seenNames.has(name.toLowerCase()) && qty > 0) {
      seenNames.add(name.toLowerCase());
      items.push({
        name,
        normalizedName: name.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim(),
        quantity: qty,
        unit: 'ea',
        unitPrice: price || null,
        totalPrice: price ? price * qty : null
      });
    }
  }
  
  return items.slice(0, 20); // Limit to 20 items
}

// Keyword-based fallback detection when Gemini fails
function keywordFallbackDetection(
  email: { id: string; subject: string; sender: string; date?: string },
  body: string
): { emailId: string; isOrder: boolean; supplier: string | null; items: any[]; confidence: number; orderDate: string; totalAmount: number } {
  const combined = `${email.subject} ${email.sender} ${body}`.toLowerCase();
  const emailDate = parseEmailDate(email.date) || new Date().toISOString().split('T')[0];
  
  // Strong order signal keywords
  const orderKeywords = [
    'order confirmation', 'order #', 'order number', 'order placed',
    'invoice', 'receipt', 'payment received', 'payment confirmation',
    'your order', 'purchase', 'transaction', 'shipped', 'shipment',
    'tracking number', 'delivered', 'out for delivery',
    'qty', 'quantity', 'subtotal', 'total:', 'grand total', 'amount due'
  ];
  
  // Known supplier domains/names
  const knownSuppliers: Record<string, string> = {
    'amazon': 'Amazon',
    'costco': 'Costco',
    'walmart': 'Walmart',
    'target': 'Target',
    'uline': 'Uline',
    'grainger': 'Grainger',
    'fastenal': 'Fastenal',
    'mcmaster': 'McMaster-Carr',
    'msc': 'MSC Industrial',
    'homedepot': 'Home Depot',
    'lowes': 'Lowes',
    'sysco': 'Sysco',
    'usfoods': 'US Foods',
    'zoro': 'Zoro',
    'staples': 'Staples',
    'officedepot': 'Office Depot',
    'newegg': 'Newegg',
    'chewy': 'Chewy',
    'ebay': 'eBay',
    'fedex': 'FedEx',
    'ups': 'UPS',
    'usps': 'USPS'
  };
  
  // Check for keywords
  const hasOrderKeyword = orderKeywords.some(kw => combined.includes(kw));
  
  // Check for dollar amounts
  const hasDollarAmount = /\$\d+\.?\d*/i.test(combined);
  
  // Detect supplier
  let detectedSupplier: string | null = null;
  for (const [key, name] of Object.entries(knownSuppliers)) {
    if (combined.includes(key)) {
      detectedSupplier = name;
      break;
    }
  }
  
  // If we have strong signals, try to extract items
  if ((hasOrderKeyword && hasDollarAmount) || (detectedSupplier && hasDollarAmount)) {
    const extractedItems = extractItemsFromBody(body);
    const totalAmount = extractedItems.reduce((sum, item) => sum + (item.totalPrice || item.unitPrice || 0), 0);
    
    console.log(`   📋 Fallback extracted ${extractedItems.length} items from ${detectedSupplier || 'email'}`);
    
    return {
      emailId: email.id,
      isOrder: true,
      supplier: detectedSupplier || extractSupplierFromSender(email.sender),
      items: extractedItems,
      confidence: extractedItems.length > 0 ? 0.7 : 0.5,
      orderDate: emailDate,
      totalAmount
    };
  }
  
  return {
    emailId: email.id,
    isOrder: false,
    supplier: null,
    items: [],
    confidence: 0,
    orderDate: emailDate,
    totalAmount: 0
  };
}

// Extract supplier name from email sender
function extractSupplierFromSender(sender: string): string {
  // Try to extract domain or name from sender
  const emailMatch = sender.match(/@([^.]+)/);
  if (emailMatch) {
    return emailMatch[1].charAt(0).toUpperCase() + emailMatch[1].slice(1);
  }
  // Try to extract name before email
  const nameMatch = sender.match(/^([^<]+)/);
  if (nameMatch) {
    return nameMatch[1].trim();
  }
  return 'Unknown Supplier';
}

// Run the actual processing in the background
async function processEmailsInBackground(
  jobId: string,
  userId: string,
  accessToken: string,
  supplierDomains: string[],
  jobType: string,
) {
  const job = jobManager.getJob(jobId);
  if (!job) return;

  try {
    // Update job status
    jobManager.updateJob(jobId, { status: 'running' });
    jobManager.addJobLog(jobId, '📧 Fetching emails from Gmail...');
    jobManager.updateJobProgress(jobId, { currentTask: 'Fetching emails...' });

    // Fetch Gmail messages
    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({ access_token: accessToken });
    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });

    // Build query - ONLY for selected suppliers, EXCLUDING Amazon (handled separately)
    // Remove any Amazon domains from the list since Amazon is processed separately
    const nonAmazonDomains = supplierDomains.filter(d =>
      !d.toLowerCase().includes('amazon')
    );
    
    if (nonAmazonDomains.length === 0) {
      jobManager.addJobLog(jobId, '⚠️ No non-Amazon suppliers selected');
      jobManager.updateJob(jobId, { status: 'completed' });
      return;
    }

    const lookbackMonths = getSupplierLookbackMonths(jobType);
    const strictQuery = buildSupplierJobQuery({
      supplierDomains: nonAmazonDomains,
      jobType,
      mode: 'strict',
    });

    jobManager.addJobLog(
      jobId,
      `🔍 Processing ${nonAmazonDomains.length} suppliers: ${nonAmazonDomains.slice(0, 5).join(', ')}${nonAmazonDomains.length > 5 ? '...' : ''}`,
    );
    jobManager.addJobLog(jobId, `🧭 Query mode=strict, lookback=${lookbackMonths} months`);

    let queryMode: 'strict' | 'fallback' = 'strict';
    let messageIds: Array<{ id?: string | null }> = [];

    const strictResponse = await gmail.users.messages.list({
      userId: 'me',
      q: strictQuery,
      maxResults: 200,
    });
    messageIds = strictResponse.data.messages || [];
    jobManager.addJobLog(jobId, `📬 Strict query found ${messageIds.length} matching emails`);

    if (jobType === 'priority' && messageIds.length === 0) {
      const fallbackQuery = buildSupplierJobQuery({
        supplierDomains: nonAmazonDomains,
        jobType,
        mode: 'fallback',
      });
      queryMode = 'fallback';
      jobManager.addJobLog(jobId, '🔁 Strict query returned 0, retrying fallback query without subject filter');

      const fallbackResponse = await gmail.users.messages.list({
        userId: 'me',
        q: fallbackQuery,
        maxResults: 200,
      });
      messageIds = fallbackResponse.data.messages || [];
      jobManager.addJobLog(jobId, `📬 Fallback query found ${messageIds.length} matching emails`);
    }

    jobManager.addJobLog(jobId, `🧪 Effective query mode: ${queryMode}`);

    if (messageIds.length === 0) {
      jobManager.addJobLog(jobId, `⚠️ No order-related emails found in the last ${lookbackMonths} months`);
      jobManager.updateJob(jobId, { status: 'completed' });
      return;
    }

    // STEP 1: Fetch headers for ALL emails to sort by vendor
    jobManager.updateJobProgress(jobId, { 
      total: messageIds.length,
      currentTask: 'Fetching email headers to group by vendor...' 
    });
    
    interface EmailInfo {
      id: string;
      subject: string;
      sender: string;
      vendorDomain: string;
      date: string;
    }
    
    const emailInfos: EmailInfo[] = [];
    
    for (let i = 0; i < messageIds.length; i++) {
      const msg = messageIds[i];
      try {
        const metaMsg = await gmail.users.messages.get({
          userId: 'me',
          id: msg.id!,
          format: 'metadata',
          metadataHeaders: ['From', 'Subject', 'Date'],
        });
        
        const headers = metaMsg.data.payload?.headers || [];
        const sender = headers.find(h => h.name === 'From')?.value || '';
        const subject = headers.find(h => h.name === 'Subject')?.value || '';
        const date = headers.find(h => h.name === 'Date')?.value || '';
        
        // Extract domain from sender
        const domainMatch = sender.match(/@([a-zA-Z0-9.-]+)/);
        const vendorDomain = domainMatch ? domainMatch[1].toLowerCase() : 'unknown';
        
        emailInfos.push({ id: msg.id!, subject, sender, vendorDomain, date });
      } catch (error) {
        console.error(`Error fetching metadata for ${msg.id}:`, error);
      }
      
      if (i % 20 === 0) {
        jobManager.updateJobProgress(jobId, { 
          processed: i,
          currentTask: `Indexing emails ${i}/${messageIds.length}...` 
        });
      }
    }
    
    // STEP 2: Group and sort by vendor domain
    const emailsByVendor = new Map<string, EmailInfo[]>();
    for (const email of emailInfos) {
      const existing = emailsByVendor.get(email.vendorDomain) || [];
      existing.push(email);
      emailsByVendor.set(email.vendorDomain, existing);
    }
    
    // Sort vendors by email count (most emails first) and create ordered list
    const sortedVendors = Array.from(emailsByVendor.entries())
      .sort((a, b) => b[1].length - a[1].length);
    
    jobManager.addJobLog(jobId, `📊 Grouped into ${sortedVendors.length} vendors`);
    for (const [vendor, emails] of sortedVendors.slice(0, 5)) {
      jobManager.addJobLog(jobId, `   • ${vendor}: ${emails.length} emails`);
    }

    // Initialize Gemini model upfront
    const model = createGeminiExtractionModel();

    // STEP 3: Process vendor by vendor and collect raw orders for consolidation
    let totalProcessed = 0;
    const rawOrders: RawOrderData[] = []; // Collect for consolidation
    
    for (const [vendorDomain, vendorEmails] of sortedVendors) {
      const vendorName = vendorDomain.split('.')[0].charAt(0).toUpperCase() + vendorDomain.split('.')[0].slice(1);
      jobManager.addJobLog(jobId, `\n🏢 Processing ${vendorName} (${vendorEmails.length} emails)...`);
      
      for (const emailInfo of vendorEmails) {
        try {
          // Fetch full email content
          const fullMsg = await gmail.users.messages.get({
            userId: 'me',
            id: emailInfo.id,
            format: 'full',
          });
          
          const headers = fullMsg.data.payload?.headers || [];
          const getHeader = (name: string) => 
            headers.find(h => h.name?.toLowerCase() === name.toLowerCase())?.value || '';

          let body = '';
          let htmlBody = '';
          let plainBody = '';
          const parts = fullMsg.data.payload?.parts || [];
          
          if (fullMsg.data.payload?.body?.data) {
            const decoded = Buffer.from(fullMsg.data.payload.body.data, 'base64').toString('utf-8');
            // Gmail sometimes inlines either HTML or plain text at the top level.
            if (decoded.includes('<html') || decoded.includes('<div') || decoded.includes('<table') || decoded.includes('<body')) {
              htmlBody = decoded;
            } else {
              plainBody = decoded;
            }
          } else if (parts.length > 0) {
            const extracted = extractBodiesFromParts(parts);
            htmlBody = extracted.html;
            plainBody = extracted.plain;
          }

          body = plainBody || htmlBody;
          
          if (!body || body.length < 20) {
            const snippet = fullMsg.data.snippet || '';
            body = snippet;
          }

          // Extract text from PDF attachments (invoices, order confirmations)
          const attachments = findAttachments(parts);
          const pdfAttachments = attachments.filter(a => 
            a.mimeType === 'application/pdf' || a.filename.toLowerCase().endsWith('.pdf')
          );
          
          if (pdfAttachments.length > 0) {
            for (const pdfAttachment of pdfAttachments) {
              const pdfText = await extractPdfText(gmail, emailInfo.id, pdfAttachment.attachmentId);
              if (pdfText) {
                body += `\n\n--- PDF: ${pdfAttachment.filename} ---\n${pdfText.substring(0, 15000)}`;
              }
            }
          }

          const headerDate = getHeader('Date') || emailInfo.date || '';
          const candidateProductUrls = uniqueStrings([
            ...extractUrlsFromHtml(htmlBody),
            ...extractUrlsFromText(body),
          ])
            .filter(u => !isJunkUrl(u))
            .slice(0, 50);

          const candidateImageUrls = uniqueStrings([
            ...extractImageUrlsFromHtml(htmlBody),
          ])
            .filter(u => !isJunkUrl(u))
            .slice(0, 30);

          const email = {
            id: emailInfo.id,
            subject: getHeader('Subject'),
            sender: getHeader('From'),
            date: headerDate,
            body,
          };

          // Update current email being processed
          jobManager.setJobCurrentEmail(jobId, {
            id: email.id,
            subject: email.subject,
            sender: email.sender,
            snippet: email.body.substring(0, 100) + '...',
          });
          
          jobManager.updateJobProgress(jobId, {
            processed: totalProcessed,
            currentTask: `${vendorName}: ${emailInfo.subject.substring(0, 40)}...`,
          });

          // Analyze with AI
          const result = await analyzeEmailWithRetryShared(model as any, email);
          
          // Collect raw order data for consolidation (instead of adding immediately)
          if (result.isOrder && result.items?.length > 0) {
            const rawOrder: RawOrderData = {
              id: result.emailId || email.id,
              emailId: email.id,
              subject: email.subject,
              supplier: result.supplier || vendorName,
              orderNumber: extractOrderNumber(email.subject, email.body),
              orderDate: normalizeExtractionOrderDate(result.orderDate, email.date),
              totalAmount: result.totalAmount || 0,
              items: result.items.map((item: any, idx: number) => ({
                id: `${email.id}-${idx}`,
                name: item.name || 'Unknown Item',
                normalizedName: normalizeItemName(item.name || ''),
                quantity: item.quantity || 1,
                unit: item.unit || 'ea',
                unitPrice: item.unitPrice || 0,
                asin: item.asin,
                sku: item.partNumber || item.sku,
                productUrl: pickBestProductUrlForItem(
                  { vendorDomain, itemName: item.name || '', sku: item.partNumber || item.sku },
                  candidateProductUrls
                ),
                imageUrl: pickBestImageUrlForItem({ vendorDomain }, candidateImageUrls),
              })),
              confidence: result.confidence || 0.8,
            };
            
            rawOrders.push(rawOrder);

            if (jobType === 'priority') {
              const liveSnapshot = buildLiveOrderSnapshot(rawOrders);
              jobManager.replaceJobOrders(jobId, liveSnapshot.orders);
              jobManager.updateJobProgress(jobId, { success: liveSnapshot.success });
            }
            
            // Log email type for visibility
            const emailType = detectEmailType(email.subject);
            const typeEmoji = emailType === 'order' ? '📦' : emailType === 'shipped' ? '🚚' : emailType === 'delivered' ? '✅' : '📧';
            
            // Log each item found for real-time visibility
            for (const item of result.items.slice(0, 3)) {
              const price = item.unitPrice ? `$${item.unitPrice.toFixed(2)}` : '';
              const quantity = typeof item.quantity === 'number' ? item.quantity : 1;
              const qty = quantity > 1 ? `x${quantity}` : '';
              jobManager.addJobLog(jobId, `   ${typeEmoji} ${item.name?.substring(0, 50) || 'Item'} ${qty} ${price}`);
            }
            if (result.items.length > 3) {
              jobManager.addJobLog(jobId, `   ... and ${result.items.length - 3} more items`);
            }
          }

          // Small delay between requests to avoid rate limits
          await delay(100);
          
        } catch (error: any) {
          console.error(`Failed to process email ${emailInfo.id}:`, error);
          // Log rate limit errors specifically
          if (error.message?.includes('429') || error.message?.includes('quota')) {
            jobManager.addJobLog(jobId, `   ⚠️ Rate limited - waiting...`);
            await delay(2000);
          }
        } finally {
          totalProcessed++;
          jobManager.updateJobProgress(jobId, {
            processed: totalProcessed,
            success: rawOrders.length,
          });
        }
      }
      
      // Log vendor completion
      const currentJob = jobManager.getJob(jobId);
      const ordersFound = currentJob?.progress.success || 0;
      jobManager.addJobLog(jobId, `   ✓ ${vendorName} complete (${ordersFound} total orders)`);
    }

    // STEP 4: Consolidate orders (deduplicate and calculate lead times)
    jobManager.updateJobProgress(jobId, { 
      currentTask: 'Consolidating orders and calculating lead times...' 
    });
    jobManager.addJobLog(jobId, `\n📊 Consolidating ${rawOrders.length} raw orders...`);
    
    const consolidatedOrders = consolidateOrders(rawOrders);
    logConsolidationSummary(rawOrders.length, consolidatedOrders);
    
    // Log consolidation results
    const duplicatesRemoved = rawOrders.length - consolidatedOrders.length;
    if (duplicatesRemoved > 0) {
      jobManager.addJobLog(jobId, `   🔄 Removed ${duplicatesRemoved} duplicate/related emails`);
    }
    
    const ordersWithLeadTime = consolidatedOrders.filter(o => o.leadTimeDays !== undefined);
    if (ordersWithLeadTime.length > 0) {
      const avgLeadTime = ordersWithLeadTime.reduce((sum, o) => sum + (o.leadTimeDays || 0), 0) / ordersWithLeadTime.length;
      jobManager.addJobLog(jobId, `   ⏱️ ${ordersWithLeadTime.length} orders with lead time data (avg ${avgLeadTime.toFixed(1)} days)`);
    }
    
    const finalSnapshot = buildFinalOrderSnapshot(consolidatedOrders);
    jobManager.replaceJobOrders(jobId, finalSnapshot.orders);

    // Complete
    jobManager.updateJob(jobId, { status: 'completed' });
    jobManager.setJobCurrentEmail(jobId, null);
    jobManager.updateJobProgress(jobId, { 
      processed: totalProcessed,
      success: finalSnapshot.success,
      currentTask: '✅ Complete' 
    });
    jobManager.addJobLog(jobId, `🎉 Complete: ${consolidatedOrders.length} unique orders from ${totalProcessed} emails across ${sortedVendors.length} vendors`);

  } catch (error: any) {
    console.error('Background job error:', error);
    jobManager.updateJob(jobId, { 
      status: 'failed', 
      error: error.message || 'Unknown error' 
    });
    jobManager.addJobLog(jobId, `❌ Error: ${error.message}`);
  }
}

// Middleware to require authentication
function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  next();
}

// Start a new processing job
router.post('/start', jobsLimiter, requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = req.session.userId!;
    const accessToken = await getValidAccessToken(userId);
    
    if (!accessToken) {
      return res.status(401).json({ error: 'Token expired, please re-authenticate' });
    }

    const { supplierDomains, jobType } = req.body as { supplierDomains?: unknown; jobType?: string };
    // Create job with specified type (defaults to 'suppliers')
    // allowConcurrent=true ensures this job won't cancel other job types
    const effectiveJobType = typeof jobType === 'string' && jobType.length > 0 ? jobType : 'suppliers';
    const sanitizedDomains = sanitizeSupplierDomains(supplierDomains);
    if (supplierDomains && sanitizedDomains.length === 0) {
      return res.status(400).json({ error: 'supplierDomains must contain valid hostnames' });
    }

    const effectiveDomains = effectiveJobType === 'priority'
      ? expandPrioritySupplierDomains(sanitizedDomains)
      : sanitizedDomains;

    console.log(`📥 /start request: userId=${userId.substring(0, 8)}, jobType=${effectiveJobType}, domains=${effectiveDomains.length}`);
    const job = jobManager.createJob(userId, { jobType: effectiveJobType, allowConcurrent: true });
    
    if (effectiveDomains.length > 0) {
      jobManager.addJobLog(job.id, `🚀 Job created for ${effectiveDomains.length} selected suppliers: ${effectiveDomains.join(', ')}`);
    } else {
      jobManager.addJobLog(job.id, '🚀 Job created, processing all suppliers...');
    }

    // Start processing in background (don't await)
    processEmailsInBackground(job.id, userId, accessToken, effectiveDomains, effectiveJobType);

    // Return immediately with job ID
    res.status(202).json({ 
      jobId: job.id,
      status: 'started',
      message: effectiveDomains.length 
        ? `Processing ${effectiveDomains.length} suppliers in background`
        : 'Processing all suppliers in background'
    });
  } catch (error: any) {
    console.error('Failed to start job:', error);
    res.status(500).json({ error: 'Failed to start processing job' });
  }
});

// Amazon-first processing: immediately start processing Amazon emails
// This runs BEFORE supplier discovery and extracts ASINs + enriches via PA API
router.post('/start-amazon', amazonLimiter, requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = req.session.userId!;
    const accessToken = await getValidAccessToken(userId);
    
    if (!accessToken) {
      return res.status(401).json({ error: 'Token expired, please re-authenticate' });
    }

    // Create job specifically for Amazon
    // allowConcurrent=true ensures this job won't cancel other job types
    console.log(`📥 /start-amazon request: userId=${userId.substring(0, 8)}`);
    const job = jobManager.createJob(userId, { jobType: 'amazon', allowConcurrent: true });
    jobManager.addJobLog(job.id, '🛒 Starting Amazon-first processing...');

    // Start Amazon processing in background
    processAmazonEmailsInBackground(job.id, userId, accessToken);

    res.status(202).json({ 
      jobId: job.id,
      status: 'started',
      message: 'Amazon processing started - ASIN extraction and enrichment'
    });
  } catch (error: any) {
    console.error('Failed to start Amazon job:', error);
    res.status(500).json({ error: 'Failed to start Amazon processing' });
  }
});

// Background processor specifically for Amazon emails with ASIN extraction
// NO AI - just extract ASINs and call Product Advertising API
async function processAmazonEmailsInBackground(
  jobId: string,
  userId: string,
  accessToken: string
) {
  const job = jobManager.getJob(jobId);
  if (!job) return;

  try {
    jobManager.updateJob(jobId, { status: 'running' });
    jobManager.addJobLog(jobId, '📧 Fetching Amazon order emails...');
    jobManager.updateJobProgress(jobId, { currentTask: 'Fetching Amazon emails...' });

    // Set up Gmail client
    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({ access_token: accessToken });
    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });

    // Calculate 6 months ago
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
    const afterDate = sixMonthsAgo.toISOString().split('T')[0].replace(/-/g, '/');

    // Amazon-specific query - look for order/shipment emails from Amazon
    const query = `from:amazon.com subject:(order OR shipment OR shipped OR delivery) after:${afterDate}`;
    
    const listResponse = await gmail.users.messages.list({
      userId: 'me',
      q: query,
      maxResults: 50, // Limit for faster processing
    });

    const messageIds = listResponse.data.messages || [];
    jobManager.addJobLog(jobId, `📬 Found ${messageIds.length} Amazon emails`);
    
    if (messageIds.length === 0) {
      jobManager.addJobLog(jobId, '⚠️ No Amazon order emails found');
      jobManager.updateJob(jobId, { status: 'completed' });
      return;
    }

    // Progress phases: 50% for email scanning, 50% for API enrichment
    // We use total = messageIds.length * 2 to account for both phases
    const emailCount = messageIds.length;
    jobManager.updateJobProgress(jobId, { 
      total: emailCount * 2, // Double for two-phase progress
      processed: 0,
      currentTask: 'Extracting ASINs from Amazon emails...' 
    });

    // Each email with ASINs becomes a raw order for consolidation
    // Structure: { emailId, subject, date, items[] }
    interface EmailOrder {
      emailId: string;
      subject: string;
      date: string;
      orderNumber?: string;
      items: { asin: string; quantity: number }[];
    }
    const emailOrders: EmailOrder[] = [];
    const allAsins: Set<string> = new Set();

    for (let i = 0; i < messageIds.length; i++) {
      const msg = messageIds[i];
      
      try {
        const fullMsg = await gmail.users.messages.get({
          userId: 'me',
          id: msg.id!,
          format: 'full',
        });

        const headers = fullMsg.data.payload?.headers || [];
        const getHeader = (name: string) => 
          headers.find(h => h.name?.toLowerCase() === name.toLowerCase())?.value || '';
        
        const subject = getHeader('subject');
        const date = getHeader('date');
        
        // Get email body - prefer HTML as Amazon ASINs are typically in href links
        let body = '';
        const payload = fullMsg.data.payload;
        
        // Recursive function to extract body from nested parts
        function extractBody(parts: any[] | undefined): { html: string; plain: string } {
          let html = '';
          let plain = '';
          
          if (!parts) return { html, plain };
          
          for (const part of parts) {
            if (part.mimeType === 'text/html' && part.body?.data) {
              html += Buffer.from(part.body.data, 'base64').toString('utf-8');
            } else if (part.mimeType === 'text/plain' && part.body?.data) {
              plain += Buffer.from(part.body.data, 'base64').toString('utf-8');
            } else if (part.parts) {
              // Recursively extract from nested parts
              const nested = extractBody(part.parts);
              html += nested.html;
              plain += nested.plain;
            }
          }
          
          return { html, plain };
        }
        
        if (payload?.body?.data) {
          body = Buffer.from(payload.body.data, 'base64').toString('utf-8');
        } else if (payload?.parts) {
          const extracted = extractBody(payload.parts);
          // Prefer HTML as it contains the actual product links with ASINs
          body = extracted.html || extracted.plain;
        }
        
        // Log sample of email for debugging
        if (body.length > 0) {
          const hasAsinInUrl = body.includes('/dp/') || body.includes('/gp/product/');
          const hasB0 = /B0[A-Z0-9]{8}/i.test(body);
          console.log(`📧 Email "${subject.substring(0, 40)}...": ${body.length} chars, hasAsinUrl=${hasAsinInUrl}, hasB0=${hasB0}`);
        }

        // Extract ASINs from this email
        const asins = extractAsinsFromEmail(body, subject);
        
        if (asins.length > 0) {
          // Try to extract quantities (best-effort)
          const qtyMatches = Array.from(body.matchAll(/(?:qty|quantity)\s*[:x]?\s*(\d+)/gi))
            .map(match => parseInt(match[1], 10))
            .filter(qty => !isNaN(qty) && qty > 0);
          
          // If we have the same number of quantities as ASINs, map them by position
          const quantities = qtyMatches.length === asins.length ? qtyMatches : [];
          const items = asins.map((asin, index) => ({
            asin,
            quantity: quantities[index] || 1,
          }));
          
          // Extract order number for consolidation
          const orderNumber = extractOrderNumber(subject, body);
          
          // Detect email type for logging
          const emailType = detectEmailType(subject);
          const typeEmoji = emailType === 'order' ? '📦' : emailType === 'shipped' ? '🚚' : emailType === 'delivered' ? '✅' : '📧';
          
          // Each email with ASINs = one raw order (will be consolidated later)
          emailOrders.push({
            emailId: msg.id!,
            subject,
            date,
            orderNumber,
            items,
          });
          items.forEach(item => allAsins.add(item.asin));
          jobManager.addJobLog(jobId, `${typeEmoji} Found ${items.length} items in: ${subject.substring(0, 50)}...`);
        }

        // Update progress (phase 1: email scanning = 0-50%)
        jobManager.updateJobProgress(jobId, {
          processed: i + 1,
          currentTask: `Scanning email ${i + 1}/${emailCount}... Found ${emailOrders.length} orders`
        });

      } catch (error) {
        console.error(`Error processing Amazon email ${msg.id}:`, error);
      }
    }

      jobManager.addJobLog(jobId, `🎯 Found ${emailOrders.length} emails with ${allAsins.size} unique items`);

    // Now enrich all unique ASINs with Amazon Product Advertising API (phase 2: 50-100%)
    if (allAsins.size > 0) {
      // Progress: 50% done with email scanning, starting API phase
      jobManager.updateJobProgress(jobId, {
        processed: emailCount, // 50% mark
        currentTask: `Calling Amazon Product Advertising API for ${allAsins.size} items...`
      });
      jobManager.addJobLog(jobId, '🛒 Calling Amazon Product Advertising API...');

      const asinArray = Array.from(allAsins);
      const enrichedData = await getAmazonItemDetails(asinArray.slice(0, 100)); // Limit to 100

      // Progress: 75% - API done
      jobManager.updateJobProgress(jobId, {
        processed: Math.floor(emailCount * 1.5), // 75% mark
        currentTask: `Got ${enrichedData.size} products, humanizing names...`
      });
      jobManager.addJobLog(jobId, `✅ Got ${enrichedData.size} products from Amazon API`);

      // Step 2: Humanize product names
      jobManager.addJobLog(jobId, '📝 Creating shop-floor friendly names...');
      
      const productNamesToHumanize = Array.from(enrichedData.values())
        .map(data => data.ItemName)
        .filter((name): name is string => !!name && name.length > 40);
      
      const humanizedNames = await humanizeProductNames(productNamesToHumanize);
      jobManager.addJobLog(jobId, `✅ Humanized ${humanizedNames.size} verbose product names`);
      
      // Progress: 90% - humanization done, building orders
      jobManager.updateJobProgress(jobId, {
        processed: Math.floor(emailCount * 1.8), // 90% mark
        currentTask: 'Building order data...'
      });

      // Build raw orders for consolidation
      const rawAmazonOrders: RawOrderData[] = [];
      
      for (const emailOrder of emailOrders) {
        const items: RawOrderData['items'] = [];
        
        for (const orderItem of emailOrder.items) {
          const data = enrichedData.get(orderItem.asin);
          const originalName = data?.ItemName;
          const humanizedName = originalName ? humanizedNames.get(originalName) : undefined;
          
          items.push({
            id: `amazon-item-${orderItem.asin}-${emailOrder.emailId}`,
            name: humanizedName || originalName || `Amazon Product ${orderItem.asin}`,
            normalizedName: normalizeItemName(humanizedName || originalName || orderItem.asin),
            quantity: orderItem.quantity || 1,
            unit: 'each',
            unitPrice: parseFloat(data?.Price?.replace(/[^0-9.]/g, '') || '0'),
            asin: orderItem.asin,
            productUrl: data?.AmazonURL,
            imageUrl: data?.ImageURL,
            amazonEnriched: data ? {
              asin: data.ASIN,
              itemName: data.ItemName,
              humanizedName: humanizedName || (originalName && originalName.length <= 40 ? originalName : undefined),
              price: data.Price,
              imageUrl: data.ImageURL,
              amazonUrl: data.AmazonURL,
              unitCount: data.UnitCount,
              unitPrice: data.UnitPrice,
              upc: data.UPC,
            } : undefined,
          });
        }

        // Parse email date
        let orderDate = new Date().toISOString().split('T')[0];
        try {
          const parsed = new Date(emailOrder.date);
          if (!isNaN(parsed.getTime())) {
            orderDate = parsed.toISOString().split('T')[0];
          }
        } catch {
          // Keep default date when parsing fails
        }

        // Create raw order for consolidation
        rawAmazonOrders.push({
          id: `amazon-${emailOrder.emailId}`,
          emailId: emailOrder.emailId,
          subject: emailOrder.subject,
          supplier: 'Amazon',
          orderNumber: emailOrder.orderNumber,
          orderDate,
          totalAmount: items.reduce((sum, item) => sum + (item.unitPrice || 0) * (item.quantity || 1), 0),
          items,
          confidence: 1.0,
        });
      }
      
      // Consolidate Amazon orders (remove duplicates, track shipping/delivery)
      jobManager.addJobLog(jobId, `\n📊 Consolidating ${rawAmazonOrders.length} Amazon emails...`);
      const consolidatedAmazonOrders = consolidateOrders(rawAmazonOrders);
      logConsolidationSummary(rawAmazonOrders.length, consolidatedAmazonOrders);
      
      const duplicatesRemoved = rawAmazonOrders.length - consolidatedAmazonOrders.length;
      if (duplicatesRemoved > 0) {
        jobManager.addJobLog(jobId, `   🔄 Removed ${duplicatesRemoved} duplicate/shipping/delivery emails`);
      }
      
      const ordersWithLeadTime = consolidatedAmazonOrders.filter(o => o.leadTimeDays !== undefined);
      if (ordersWithLeadTime.length > 0) {
        const avgLeadTime = ordersWithLeadTime.reduce((sum, o) => sum + (o.leadTimeDays || 0), 0) / ordersWithLeadTime.length;
        jobManager.addJobLog(jobId, `   ⏱️ ${ordersWithLeadTime.length} orders with lead time data (avg ${avgLeadTime.toFixed(1)} days)`);
      }
      
      // Add consolidated orders to job
      let totalItems = 0;
      for (const consolidated of consolidatedAmazonOrders) {
        const order: ProcessedOrder = {
          id: consolidated.id,
          supplier: 'Amazon',
          orderDate: consolidated.orderDate,
          totalAmount: consolidated.totalAmount || 0,
          items: consolidated.items.map(item => ({
            id: item.id,
            name: item.name,
            quantity: item.quantity,
            unit: item.unit,
            unitPrice: item.unitPrice || 0,
            asin: item.asin,
            sku: item.sku,
            productUrl: item.productUrl,
            imageUrl: item.imageUrl,
            amazonEnriched: item.amazonEnriched,
          })),
          confidence: consolidated.confidence,
        };

        jobManager.addJobOrder(jobId, order);
        totalItems += consolidated.items.length;
        
        // Log order with lead time if available
        const leadTimeInfo = consolidated.leadTimeDays !== undefined ? ` (${consolidated.leadTimeDays}d lead time)` : '';
        jobManager.addJobLog(jobId, `📋 Order ${consolidated.orderDate}: ${consolidated.items.length} item${consolidated.items.length > 1 ? 's' : ''} - $${(consolidated.totalAmount || 0).toFixed(2)}${leadTimeInfo}`);
      }

      jobManager.updateJobProgress(jobId, { success: totalItems });
      jobManager.addJobLog(jobId, `🎉 Amazon complete: ${consolidatedAmazonOrders.length} unique orders, ${totalItems} items`);
    } else {
      jobManager.addJobLog(jobId, '⚠️ No ASINs found in Amazon emails');
    }

    jobManager.updateJob(jobId, { status: 'completed' });
    
  } catch (error: any) {
    console.error('Amazon processing error:', error);
    jobManager.addJobLog(jobId, `❌ Error: ${error.message}`);
    jobManager.updateJob(jobId, { status: 'failed', error: error.message });
  }
}

// Get job status (for polling)
router.get('/status', requireAuth, async (req: Request, res: Response) => {
  const userId = req.session.userId!;
  const jobId = req.query.jobId as string;
  
  let job: Job | undefined;
  
  if (jobId) {
    job = jobManager.getJob(jobId);
  } else {
    // Get latest job for user
    job = jobManager.getJobForUser(userId);
  }
  
  if (!job) {
    return res.json({ 
      hasJob: false,
      message: 'No active job found'
    });
  }

  res.json({
    hasJob: true,
    jobId: job.id,
    status: job.status,
    progress: job.progress,
    currentEmail: job.currentEmail,
    orders: job.orders,
    logs: job.logs.slice(0, 20), // Last 20 logs
    error: job.error,
  });
});

// Get full job results
router.get('/:jobId', requireAuth, async (req: Request, res: Response) => {
  const job = jobManager.getJob(req.params.jobId);
  
  if (!job) {
    return res.status(404).json({ error: 'Job not found' });
  }

  // Verify job belongs to user
  if (job.userId !== req.session.userId) {
    return res.status(403).json({ error: 'Access denied' });
  }

  res.json(job);
});

export { router as jobsRouter };

```

### `server/src/routes/jobsProcessingUtils.test.ts`

```typescript
import { describe, expect, it } from 'vitest';
import { buildFinalOrderSnapshot, buildLiveOrderSnapshot, toProcessedOrder } from './jobsProcessingUtils.js';
import { ConsolidatedOrder, RawOrderData } from '../utils/orderConsolidation.js';

describe('jobsProcessingUtils', () => {
  it('converts raw order data into API processed order shape', () => {
    const rawOrder: RawOrderData = {
      id: 'raw-1',
      emailId: 'email-1',
      subject: 'Order confirmation',
      supplier: 'McMaster-Carr',
      orderDate: '2026-01-05',
      totalAmount: 42.5,
      confidence: 0.88,
      items: [{
        id: 'item-1',
        name: 'Bolt',
        quantity: 2,
        unit: 'ea',
        unitPrice: 21.25,
        sku: 'SKU-1',
      }],
    };

    const processed = toProcessedOrder(rawOrder);
    expect(processed.id).toBe('raw-1');
    expect(processed.totalAmount).toBe(42.5);
    expect(processed.items[0].name).toBe('Bolt');
    expect(processed.items[0].unitPrice).toBe(21.25);
  });

  it('builds live snapshot with success count matching extracted raw orders', () => {
    const rawOrders: RawOrderData[] = [
      {
        id: 'raw-1',
        emailId: 'e1',
        subject: 'A',
        supplier: 'Uline',
        orderDate: '2026-01-01',
        confidence: 0.9,
        items: [{ id: 'i1', name: 'Tape', quantity: 1, unit: 'ea' }],
      },
      {
        id: 'raw-2',
        emailId: 'e2',
        subject: 'B',
        supplier: 'McMaster-Carr',
        orderDate: '2026-01-02',
        confidence: 0.9,
        items: [{ id: 'i2', name: 'Gloves', quantity: 1, unit: 'ea' }],
      },
    ];

    const snapshot = buildLiveOrderSnapshot(rawOrders);
    expect(snapshot.success).toBe(2);
    expect(snapshot.orders).toHaveLength(2);
    expect(snapshot.orders.map(order => order.supplier)).toEqual(['Uline', 'McMaster-Carr']);
  });

  it('builds final snapshot from consolidated orders', () => {
    const consolidated: ConsolidatedOrder[] = [{
      id: 'final-1',
      originalEmailId: 'e1',
      supplier: 'Uline',
      orderDate: '2026-01-01',
      confidence: 0.95,
      items: [{ id: 'i1', name: 'Box Cutter', quantity: 1, unit: 'ea' }],
      relatedEmails: [],
    }];

    const snapshot = buildFinalOrderSnapshot(consolidated);
    expect(snapshot.success).toBe(1);
    expect(snapshot.orders[0].id).toBe('final-1');
    expect(snapshot.orders[0].items[0].name).toBe('Box Cutter');
  });
});

```

### `server/src/routes/jobsProcessingUtils.ts`

```typescript
import { ProcessedOrder } from '../services/jobManager.js';
import { ConsolidatedOrder, RawOrderData } from '../utils/orderConsolidation.js';

type OrderLike = Pick<
  RawOrderData | ConsolidatedOrder,
  'id' | 'supplier' | 'orderDate' | 'totalAmount' | 'items' | 'confidence'
>;

export interface OrderSnapshot {
  orders: ProcessedOrder[];
  success: number;
}

export function toProcessedOrder(order: OrderLike): ProcessedOrder {
  return {
    id: order.id,
    supplier: order.supplier,
    orderDate: order.orderDate,
    totalAmount: order.totalAmount || 0,
    items: order.items.map(item => ({
      id: item.id,
      name: item.name,
      quantity: item.quantity,
      unit: item.unit,
      unitPrice: item.unitPrice || 0,
      asin: item.asin,
      sku: item.sku,
      productUrl: item.productUrl,
      imageUrl: item.imageUrl,
      amazonEnriched: item.amazonEnriched,
    })),
    confidence: order.confidence,
  };
}

export function buildLiveOrderSnapshot(rawOrders: RawOrderData[]): OrderSnapshot {
  const orders = rawOrders.map(toProcessedOrder);
  return {
    orders,
    success: orders.length,
  };
}

export function buildFinalOrderSnapshot(consolidatedOrders: ConsolidatedOrder[]): OrderSnapshot {
  const orders = consolidatedOrders.map(toProcessedOrder);
  return {
    orders,
    success: orders.length,
  };
}

```

### `server/src/routes/jobsQueryUtils.test.ts`

```typescript
import { describe, expect, it } from 'vitest';
import {
  buildSupplierJobQuery,
  expandPrioritySupplierDomains,
  getSupplierLookbackMonths,
  sanitizeSupplierDomains,
} from './jobsQueryUtils.js';

describe('jobsQueryUtils', () => {
  it('sanitizes supplier domains with dedupe and validation', () => {
    const domains = sanitizeSupplierDomains([
      ' ULINE.com ',
      'uline.com',
      'invalid domain',
      '',
      'foo',
      'mcmaster.com',
    ]);

    expect(domains).toEqual(['uline.com', 'mcmaster.com']);
  });

  it('expands priority domains with aliases', () => {
    expect(expandPrioritySupplierDomains(['mcmaster.com'])).toEqual([
      'mcmaster.com',
      'mcmaster-carr.com',
    ]);
    expect(expandPrioritySupplierDomains(['mcmaster-carr.com', 'uline.com'])).toEqual([
      'mcmaster.com',
      'mcmaster-carr.com',
      'uline.com',
    ]);
  });

  it('builds priority strict query with broader keywords and 12 month lookback', () => {
    const now = new Date('2026-02-17T12:00:00.000Z');
    const query = buildSupplierJobQuery({
      supplierDomains: ['mcmaster.com', 'uline.com'],
      jobType: 'priority',
      mode: 'strict',
      now,
    });

    expect(query).toContain('from:mcmaster.com OR from:uline.com');
    expect(query).toContain('acknowledgment');
    expect(query).toContain('acknowledgement');
    expect(query).toContain('"purchase order"');
    expect(query).toContain('after:2025/02/17');
    expect(query).toContain('subject:(');
  });

  it('builds priority fallback query without subject filter', () => {
    const now = new Date('2026-02-17T12:00:00.000Z');
    const query = buildSupplierJobQuery({
      supplierDomains: ['mcmaster.com'],
      jobType: 'priority',
      mode: 'fallback',
      now,
    });

    expect(query).toContain('from:mcmaster.com');
    expect(query).toContain('after:2025/02/17');
    expect(query).not.toContain('subject:(');
  });

  it('keeps non-priority lookback at 6 months', () => {
    const now = new Date('2026-02-17T12:00:00.000Z');
    const query = buildSupplierJobQuery({
      supplierDomains: ['fastenal.com'],
      jobType: 'other',
      mode: 'strict',
      now,
    });

    expect(getSupplierLookbackMonths('other')).toBe(6);
    expect(query).toContain('after:2025/08/17');
  });
});

```

### `server/src/routes/jobsQueryUtils.ts`

```typescript
const MAX_SUPPLIERS = 25;

const DEFAULT_SUBJECT_KEYWORDS = [
  'order',
  'invoice',
  'receipt',
  'confirmation',
  'shipment',
  'purchase',
  'payment',
];

const PRIORITY_SUBJECT_KEYWORDS = [
  'order',
  'invoice',
  'receipt',
  'confirmation',
  'acknowledgment',
  'acknowledgement',
  'shipment',
  'shipped',
  'delivered',
  'purchase',
  'payment',
  'order status',
  'purchase order',
];

const PRIORITY_SUPPLIER_ALIASES: Record<string, string[]> = {
  'mcmaster.com': ['mcmaster.com', 'mcmaster-carr.com'],
  'uline.com': ['uline.com'],
};

const PRIORITY_ALIAS_TO_CANONICAL = Object.entries(PRIORITY_SUPPLIER_ALIASES)
  .flatMap(([canonicalDomain, aliases]) =>
    aliases.map((alias) => [alias, canonicalDomain] as const),
  )
  .reduce<Record<string, string>>((map, [alias, canonicalDomain]) => {
    map[alias] = canonicalDomain;
    return map;
  }, {});

export type SupplierQueryMode = 'strict' | 'fallback';

function formatAfterDate(monthsLookback: number, now: Date = new Date()): string {
  const fromDate = new Date(now);
  fromDate.setMonth(fromDate.getMonth() - monthsLookback);
  return fromDate.toISOString().split('T')[0].replace(/-/g, '/');
}

function quoteKeyword(keyword: string): string {
  return keyword.includes(' ') ? `"${keyword}"` : keyword;
}

export function sanitizeSupplierDomains(domains: unknown): string[] {
  if (!Array.isArray(domains)) return [];

  const deduped: string[] = [];
  const seen = new Set<string>();

  for (const domain of domains) {
    const normalized = typeof domain === 'string' ? domain.trim().toLowerCase() : '';
    const isValid = normalized.length > 2 && normalized.includes('.') && !normalized.includes(' ');
    if (!isValid || seen.has(normalized)) continue;
    seen.add(normalized);
    deduped.push(normalized);
    if (deduped.length >= MAX_SUPPLIERS) break;
  }

  return deduped;
}

export function expandPrioritySupplierDomains(domains: string[]): string[] {
  const normalizedDomains = sanitizeSupplierDomains(domains);
  const expanded: string[] = [];
  const seen = new Set<string>();

  for (const domain of normalizedDomains) {
    const canonical = PRIORITY_ALIAS_TO_CANONICAL[domain];
    const group = canonical ? PRIORITY_SUPPLIER_ALIASES[canonical] : [domain];

    for (const alias of group) {
      if (seen.has(alias)) continue;
      seen.add(alias);
      expanded.push(alias);
    }
  }

  return expanded;
}

export function getSupplierLookbackMonths(jobType?: string): number {
  return jobType === 'priority' ? 12 : 6;
}

interface BuildSupplierJobQueryParams {
  supplierDomains: string[];
  jobType?: string;
  mode?: SupplierQueryMode;
  now?: Date;
}

export function buildSupplierJobQuery({
  supplierDomains,
  jobType,
  mode = 'strict',
  now,
}: BuildSupplierJobQueryParams): string {
  const normalizedDomains = sanitizeSupplierDomains(supplierDomains);
  if (normalizedDomains.length === 0) return '';

  const fromClause = normalizedDomains.map((domain) => `from:${domain}`).join(' OR ');
  const lookbackMonths = getSupplierLookbackMonths(jobType);
  const afterDate = formatAfterDate(lookbackMonths, now);

  if (mode === 'fallback') {
    return `(${fromClause}) after:${afterDate}`;
  }

  const keywords = jobType === 'priority' ? PRIORITY_SUBJECT_KEYWORDS : DEFAULT_SUBJECT_KEYWORDS;
  const subjectClause = keywords.map(quoteKeyword).join(' OR ');
  return `(${fromClause}) subject:(${subjectClause}) after:${afterDate}`;
}

```

### `server/src/routes/orders.ts`

```typescript
import { Router, Request, Response } from 'express';
import { query } from '../db/index.js';
import { v4 as uuidv4 } from 'uuid';

const router = Router();

// Middleware to require authentication
function requireAuth(req: Request, res: Response, next: Function) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  next();
}

// Get all orders for current user
router.get('/', requireAuth, async (req: Request, res: Response) => {
  try {
    const result = await query(`
      SELECT o.*, 
        COALESCE(json_agg(
          json_build_object(
            'id', oi.id,
            'name', oi.name,
            'quantity', oi.quantity,
            'unit', oi.unit,
            'unitPrice', oi.unit_price,
            'totalPrice', oi.total_price
          )
        ) FILTER (WHERE oi.id IS NOT NULL), '[]') as items
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.user_id = $1
      GROUP BY o.id
      ORDER BY o.order_date DESC
    `, [req.session.userId]);

    res.json({ orders: result.rows });
  } catch (error) {
    console.error('Get orders error:', error);
    res.status(500).json({ error: 'Failed to get orders' });
  }
});

// Save new orders (batch)
router.post('/', requireAuth, async (req: Request, res: Response) => {
  try {
    const { orders } = req.body;

    if (!Array.isArray(orders)) {
      return res.status(400).json({ error: 'orders must be an array' });
    }

    const savedOrders = [];

    for (const order of orders) {
      // Insert order
      const orderResult = await query(`
        INSERT INTO orders (id, user_id, original_email_id, supplier, order_date, total_amount, confidence, raw_data)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        ON CONFLICT (id) DO UPDATE SET
          supplier = EXCLUDED.supplier,
          order_date = EXCLUDED.order_date,
          total_amount = EXCLUDED.total_amount,
          confidence = EXCLUDED.confidence,
          raw_data = EXCLUDED.raw_data
        RETURNING *
      `, [
        order.id || uuidv4(),
        req.session.userId,
        order.originalEmailId,
        order.supplier,
        order.orderDate,
        order.totalAmount,
        order.confidence,
        JSON.stringify(order),
      ]);

      const savedOrder = orderResult.rows[0];

      // Insert order items
      if (order.items && Array.isArray(order.items)) {
        // Delete existing items first
        await query('DELETE FROM order_items WHERE order_id = $1', [savedOrder.id]);

        for (const item of order.items) {
          await query(`
            INSERT INTO order_items (order_id, name, quantity, unit, unit_price, total_price)
            VALUES ($1, $2, $3, $4, $5, $6)
          `, [
            savedOrder.id,
            item.name,
            item.quantity,
            item.unit,
            item.unitPrice,
            item.totalPrice,
          ]);
        }
      }

      savedOrders.push(savedOrder);
    }

    res.json({ success: true, orders: savedOrders });
  } catch (error) {
    console.error('Save orders error:', error);
    res.status(500).json({ error: 'Failed to save orders' });
  }
});

// Get inventory stats (computed from orders)
router.get('/inventory', requireAuth, async (req: Request, res: Response) => {
  try {
    const result = await query(`
      SELECT 
        oi.name,
        COUNT(DISTINCT o.id) as order_count,
        SUM(oi.quantity) as total_quantity,
        MIN(o.order_date) as first_order_date,
        MAX(o.order_date) as last_order_date,
        AVG(oi.unit_price) as avg_price,
        STRING_AGG(DISTINCT o.supplier, ', ') as suppliers
      FROM order_items oi
      JOIN orders o ON oi.order_id = o.id
      WHERE o.user_id = $1
      GROUP BY oi.name
      ORDER BY order_count DESC
    `, [req.session.userId]);

    // Compute additional stats
    const inventory = result.rows.map(item => {
      const daysBetween = item.first_order_date && item.last_order_date
        ? Math.max(1, Math.ceil((new Date(item.last_order_date).getTime() - new Date(item.first_order_date).getTime()) / (1000 * 60 * 60 * 24)))
        : 1;
      
      const orderCount = parseInt(item.order_count);
      const averageCadenceDays = orderCount > 1 ? Math.round(daysBetween / (orderCount - 1)) : 30;
      const dailyBurnRate = parseFloat(item.total_quantity) / daysBetween;
      
      return {
        name: item.name,
        totalQuantityOrdered: parseFloat(item.total_quantity),
        orderCount,
        firstOrderDate: item.first_order_date,
        lastOrderDate: item.last_order_date,
        averageCadenceDays,
        dailyBurnRate: Math.round(dailyBurnRate * 100) / 100,
        recommendedMin: Math.ceil(dailyBurnRate * 7), // 1 week buffer
        recommendedOrderQty: Math.ceil(dailyBurnRate * averageCadenceDays),
        lastPrice: parseFloat(item.avg_price) || 0,
        suppliers: item.suppliers,
      };
    });

    res.json({ inventory });
  } catch (error) {
    console.error('Get inventory error:', error);
    res.status(500).json({ error: 'Failed to get inventory' });
  }
});

// Delete order
router.delete('/:id', requireAuth, async (req: Request, res: Response) => {
  try {
    await query(`
      DELETE FROM orders WHERE id = $1 AND user_id = $2
    `, [req.params.id, req.session.userId]);

    res.json({ success: true });
  } catch (error) {
    console.error('Delete order error:', error);
    res.status(500).json({ error: 'Failed to delete order' });
  }
});

export { router as ordersRouter };

```

### `server/src/routes/photo.ts`

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { GoogleGenerativeAI } from '@google/generative-ai';
import redisClient from '../utils/redisClient.js';
import { requireRedis } from '../config.js';
import { appLogger } from '../middleware/requestLogger.js';

const router = Router();

// Constants
const SESSION_TTL = 24 * 60 * 60; // 24 hours in seconds
const IMAGE_TTL = 30 * 24 * 60 * 60; // 30 days for uploaded images
const MAX_PHOTOS_PER_SESSION = 100;
const MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10MB
const REDIS_PREFIX = 'photo:session:';
const PHOTO_DATA_PREFIX = 'photo:data:';
const IMAGE_UPLOAD_PREFIX = 'image:upload:';

// Initialize Gemini with error handling
let genAI: GoogleGenerativeAI | null = null;
if (process.env.GEMINI_API_KEY) {
  genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
} else {
  appLogger.warn('GEMINI_API_KEY not set - photo analysis will be disabled');
}

// Types
interface PhotoMetadata {
  id: string;
  capturedAt: string;
  source: 'desktop' | 'mobile';
  extractedText?: string[];
  detectedBarcodes?: string[];
  suggestedName?: string;
  suggestedSupplier?: string;
  isInternalItem?: boolean;
  analyzed: boolean;
  imageSizeBytes?: number;
  manualEditsAt?: string;
}

// CapturedPhoto interface extends PhotoMetadata with image data
// interface CapturedPhoto extends PhotoMetadata {
//   imageData: string; // Base64 data URL
// }

interface PhotoSession {
  photoIds: string[]; // Just store IDs, actual data stored separately
  metadata: Record<string, PhotoMetadata>;
  createdAt: string;
  lastActivity: string;
  userId?: string;
}

// In-memory fallback
const memoryStore = new Map<string, PhotoSession>();
const memoryPhotoData = new Map<string, string>();

// Validate session ID format
const isValidSessionId = (sessionId: string): boolean => {
  return /^[a-zA-Z0-9-_]{10,64}$/.test(sessionId);
};

// Validate image data
const isValidImageData = (data: string): { valid: boolean; sizeBytes: number; error?: string } => {
  if (!data || typeof data !== 'string') {
    return { valid: false, sizeBytes: 0, error: 'Image data is required' };
  }
  
  if (!data.startsWith('data:image/')) {
    return { valid: false, sizeBytes: 0, error: 'Invalid image format - must be data URL' };
  }
  
  // Estimate base64 size
  const base64Part = data.split(',')[1];
  if (!base64Part) {
    return { valid: false, sizeBytes: 0, error: 'Invalid data URL format' };
  }
  
  const sizeBytes = Math.ceil(base64Part.length * 0.75);
  if (sizeBytes > MAX_IMAGE_SIZE) {
    return { valid: false, sizeBytes, error: `Image too large (${Math.round(sizeBytes / 1024 / 1024)}MB, max ${MAX_IMAGE_SIZE / 1024 / 1024}MB)` };
  }
  
  return { valid: true, sizeBytes };
};

const sanitizeOptionalText = (value: unknown, maxLength: number): string | undefined => {
  if (value === undefined || value === null) return undefined;
  if (typeof value !== 'string') return undefined;
  const trimmed = value.trim();
  if (!trimmed) return undefined;
  return trimmed.slice(0, maxLength);
};

const sanitizeOptionalStringArray = (
  value: unknown,
  maxItems: number,
  maxItemLength: number,
): string[] | undefined => {
  if (value === undefined || value === null) return undefined;
  if (!Array.isArray(value)) return undefined;

  const cleaned = value
    .map((entry) => (typeof entry === 'string' ? entry.trim() : String(entry).trim()))
    .filter(Boolean)
    .slice(0, maxItems)
    .map((entry) => entry.slice(0, maxItemLength));

  return cleaned.length > 0 ? cleaned : undefined;
};

// Get session from Redis or memory
const getSession = async (sessionId: string): Promise<PhotoSession> => {
  if (redisClient) {
    try {
      const data = await redisClient.get(`${REDIS_PREFIX}${sessionId}`);
      if (data) {
        return JSON.parse(data);
      }
    } catch (error) {
      appLogger.error({ err: error }, 'Redis get session error');
    }
  }
  
  const session = memoryStore.get(sessionId);
  if (session) return session;
  
  return {
    photoIds: [],
    metadata: {},
    createdAt: new Date().toISOString(),
    lastActivity: new Date().toISOString(),
  };
};

// Save session to Redis or memory
const saveSession = async (sessionId: string, session: PhotoSession): Promise<void> => {
  session.lastActivity = new Date().toISOString();
  
  if (redisClient) {
    try {
      await redisClient.setex(
        `${REDIS_PREFIX}${sessionId}`,
        SESSION_TTL,
        JSON.stringify(session)
      );
      return;
    } catch (error) {
      appLogger.error({ err: error }, 'Redis set session error');
    }
  }
  
  memoryStore.set(sessionId, session);
};

// Get photo data from Redis or memory
const getPhotoData = async (photoId: string): Promise<string | null> => {
  if (redisClient) {
    try {
      return await redisClient.get(`${PHOTO_DATA_PREFIX}${photoId}`);
    } catch (error) {
      appLogger.error({ err: error }, 'Redis get photo error');
    }
  }
  return memoryPhotoData.get(photoId) || null;
};

// Save photo data to Redis or memory
const savePhotoData = async (photoId: string, imageData: string): Promise<void> => {
  if (redisClient) {
    try {
      await redisClient.setex(
        `${PHOTO_DATA_PREFIX}${photoId}`,
        SESSION_TTL,
        imageData
      );
      return;
    } catch (error) {
      appLogger.error({ err: error }, 'Redis set photo error');
    }
  }
  
  memoryPhotoData.set(photoId, imageData);
  
  // Cleanup old photos from memory if too many
  if (memoryPhotoData.size > 500) {
    const keys = Array.from(memoryPhotoData.keys());
    for (let i = 0; i < 100; i++) {
      memoryPhotoData.delete(keys[i]);
    }
  }
};

const ensureRedis = (res: Response): boolean => {
  if (requireRedis && !redisClient) {
    res.status(503).json({ error: 'Redis unavailable; photo sessions require persistent storage' });
    return false;
  }
  return true;
};

// Session ID validation middleware
const validateSessionId = (req: Request, res: Response, next: NextFunction) => {
  const { sessionId } = req.params;
  if (!isValidSessionId(sessionId)) {
    return res.status(400).json({ error: 'Invalid session ID format' });
  }
  next();
};

/**
 * GET /api/photo/session/:sessionId/photos
 * Get all photos for a session (used by desktop to poll for mobile captures)
 */
router.get('/session/:sessionId/photos', validateSessionId, async (req: Request, res: Response) => {
  try {
    if (!ensureRedis(res)) return;
    const { sessionId } = req.params;
    const { since } = req.query;
    
    const session = await getSession(sessionId);
    
    let photoMetadata = Object.values(session.metadata);
    
    // Filter by timestamp if provided
    if (since && typeof since === 'string') {
      const sinceDate = new Date(since);
      if (!isNaN(sinceDate.getTime())) {
        photoMetadata = photoMetadata.filter(p => new Date(p.capturedAt) > sinceDate);
      }
    }
    
    // Return metadata only (no image data) for listing
    const photos = photoMetadata.map(p => ({
      ...p,
      hasFullImage: true,
    }));
    
    res.json({ 
      photos,
      sessionCreatedAt: session.createdAt,
      totalCount: session.photoIds.length,
    });
  } catch (error) {
    appLogger.error({ err: error }, 'Get photos error');
    res.status(500).json({ error: 'Failed to retrieve photos' });
  }
});

/**
 * GET /api/photo/session/:sessionId/photo/:photoId
 * Get full photo data by ID
 */
router.get('/session/:sessionId/photo/:photoId', validateSessionId, async (req: Request, res: Response) => {
  try {
    if (!ensureRedis(res)) return;
    const { sessionId, photoId } = req.params;
    
    const session = await getSession(sessionId);
    const metadata = session.metadata[photoId];
    
    if (!metadata) {
      return res.status(404).json({ error: 'Photo not found' });
    }
    
    const imageData = await getPhotoData(photoId);
    if (!imageData) {
      return res.status(404).json({ error: 'Photo data not found' });
    }
    
    res.json({ 
      photo: {
        ...metadata,
        imageData,
      }
    });
  } catch (error) {
    appLogger.error({ err: error }, 'Get photo error');
    res.status(500).json({ error: 'Failed to retrieve photo' });
  }
});

/**
 * POST /api/photo/session/:sessionId/photo
 * Add a photo to a session (used by mobile capture)
 */
router.post('/session/:sessionId/photo', validateSessionId, async (req: Request, res: Response) => {
  try {
    if (!ensureRedis(res)) return;
    const { sessionId } = req.params;
    const { id, data, timestamp, source } = req.body;
    
    // Validate image data
    const validation = isValidImageData(data);
    if (!validation.valid) {
      return res.status(400).json({ error: validation.error });
    }
    
    const session = await getSession(sessionId);
    
    // Check session limits
    if (session.photoIds.length >= MAX_PHOTOS_PER_SESSION) {
      return res.status(429).json({ 
        error: 'Session photo limit reached',
        limit: MAX_PHOTOS_PER_SESSION,
      });
    }
    
    const photoId = id || `photo-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // Create metadata entry
    const metadata: PhotoMetadata = {
      id: photoId,
      capturedAt: timestamp || new Date().toISOString(),
      source: source === 'desktop' ? 'desktop' : 'mobile',
      analyzed: false,
      imageSizeBytes: validation.sizeBytes,
    };
    
    // Store photo data separately
    await savePhotoData(photoId, data);
    
    // Update session
    session.photoIds.push(photoId);
    session.metadata[photoId] = metadata;
    await saveSession(sessionId, session);
    
    appLogger.info(`Photo captured: ${photoId} in session ${sessionId.substring(0, 8)}... (${Math.round(validation.sizeBytes / 1024)}KB)`);
    
    // Analyze in background
    analyzePhotoAsync(sessionId, photoId, data).catch(error => {
      appLogger.error('Background photo analysis failed:', error);
    });
    
    res.json({ success: true, photoId });
  } catch (error) {
    appLogger.error({ err: error }, 'Add photo error');
    res.status(500).json({ error: 'Failed to save photo' });
  }
});

/**
 * PUT /api/photo/session/:sessionId/photo/:photoId
 * Update analyzed metadata fields for a photo
 */
router.put('/session/:sessionId/photo/:photoId', validateSessionId, async (req: Request, res: Response) => {
  try {
    if (!ensureRedis(res)) return;
    const { sessionId, photoId } = req.params;
    const session = await getSession(sessionId);
    const metadata = session.metadata[photoId];

    if (!metadata) {
      return res.status(404).json({ error: 'Photo not found' });
    }

    const nextMetadata: PhotoMetadata = { ...metadata };
    const hasSuggestedName = Object.prototype.hasOwnProperty.call(req.body, 'suggestedName');
    const hasSuggestedSupplier = Object.prototype.hasOwnProperty.call(req.body, 'suggestedSupplier');
    const hasDetectedBarcodes = Object.prototype.hasOwnProperty.call(req.body, 'detectedBarcodes');
    const hasExtractedText = Object.prototype.hasOwnProperty.call(req.body, 'extractedText');
    const hasInternalItem = Object.prototype.hasOwnProperty.call(req.body, 'isInternalItem');

    if (hasSuggestedName) {
      nextMetadata.suggestedName = sanitizeOptionalText(req.body.suggestedName, 100);
    }
    if (hasSuggestedSupplier) {
      nextMetadata.suggestedSupplier = sanitizeOptionalText(req.body.suggestedSupplier, 100);
    }
    if (hasDetectedBarcodes) {
      nextMetadata.detectedBarcodes = sanitizeOptionalStringArray(req.body.detectedBarcodes, 20, 50);
    }
    if (hasExtractedText) {
      nextMetadata.extractedText = sanitizeOptionalStringArray(req.body.extractedText, 30, 200);
    }
    if (hasInternalItem) {
      if (req.body.isInternalItem === null || req.body.isInternalItem === undefined) {
        nextMetadata.isInternalItem = undefined;
      } else if (typeof req.body.isInternalItem === 'boolean') {
        nextMetadata.isInternalItem = req.body.isInternalItem;
      } else {
        return res.status(400).json({ error: 'isInternalItem must be a boolean or null' });
      }
    }

    nextMetadata.analyzed = true;
    nextMetadata.manualEditsAt = new Date().toISOString();
    session.metadata[photoId] = nextMetadata;
    await saveSession(sessionId, session);

    res.json({ success: true, photo: nextMetadata });
  } catch (error) {
    appLogger.error({ err: error }, 'Update photo metadata error');
    res.status(500).json({ error: 'Failed to update photo metadata' });
  }
});

/**
 * POST /api/photo/analyze
 * Analyze an image to extract text, barcodes, and suggest product info
 */
router.post('/analyze', async (req: Request, res: Response) => {
  const { imageData } = req.body;
  
  // Validate image data
  const validation = isValidImageData(imageData);
  if (!validation.valid) {
    return res.status(400).json({ error: validation.error });
  }
  
  if (!genAI) {
    return res.status(503).json({ error: 'Image analysis service not configured' });
  }
  
  try {
    const analysis = await analyzeImage(imageData);
    res.json(analysis);
  } catch (error) {
    appLogger.error({ err: error }, 'Image analysis error');
    res.status(500).json({ error: 'Analysis failed' });
  }
});

/**
 * Analyze photo asynchronously and update the stored session metadata
 */
async function analyzePhotoAsync(sessionId: string, photoId: string, imageData: string): Promise<void> {
  if (!genAI) {
    appLogger.warn('Skipping photo analysis - Gemini not configured');
    try {
      const session = await getSession(sessionId);
      const existing = session.metadata[photoId];
      if (existing && !existing.analyzed) {
        session.metadata[photoId] = {
          ...existing,
          analyzed: true,
        };
        await saveSession(sessionId, session);
      }
    } catch (error) {
      appLogger.error({ err: error }, 'Failed to mark photo analyzed');
    }
    return;
  }
  
  try {
    const analysis = await analyzeImage(imageData);
    
    // Update session metadata with analysis results
    const session = await getSession(sessionId);
    if (session.metadata[photoId]) {
      const existing = session.metadata[photoId];
      const hasManualEdits = Boolean(existing.manualEditsAt);
      session.metadata[photoId] = {
        ...existing,
        extractedText: hasManualEdits ? (existing.extractedText ?? analysis.extractedText) : analysis.extractedText,
        detectedBarcodes: hasManualEdits ? (existing.detectedBarcodes ?? analysis.detectedBarcodes) : analysis.detectedBarcodes,
        suggestedName: hasManualEdits ? (existing.suggestedName ?? analysis.suggestedName) : analysis.suggestedName,
        suggestedSupplier: hasManualEdits ? (existing.suggestedSupplier ?? analysis.suggestedSupplier) : analysis.suggestedSupplier,
        isInternalItem: hasManualEdits ? (existing.isInternalItem ?? analysis.isInternalItem) : analysis.isInternalItem,
        analyzed: true,
      };
      await saveSession(sessionId, session);
      appLogger.info(`Photo analyzed: ${photoId} - "${analysis.suggestedName || 'unknown'}"`);
    }
  } catch (error) {
    appLogger.error({ err: error }, 'Async photo analysis error');
    try {
      const session = await getSession(sessionId);
      const existing = session.metadata[photoId];
      if (existing && !existing.analyzed) {
        session.metadata[photoId] = {
          ...existing,
          analyzed: true,
        };
        await saveSession(sessionId, session);
      }
    } catch (markError) {
      appLogger.error({ err: markError }, 'Failed to mark photo analyzed after analysis error');
    }
  }
}

// Analysis result type
interface AnalysisResult {
  extractedText?: string[];
  detectedBarcodes?: string[];
  suggestedName?: string;
  suggestedSupplier?: string;
  isInternalItem?: boolean;
}

// Rate limiting for Gemini API
let lastAnalysisTime = 0;
const MIN_ANALYSIS_INTERVAL = 500; // ms between calls

/**
 * Analyze an image using Gemini Vision
 */
async function analyzeImage(imageData: string): Promise<AnalysisResult> {
  if (!genAI) {
    throw new Error('Gemini API not configured');
  }
  
  // Simple rate limiting
  const now = Date.now();
  const timeSinceLastCall = now - lastAnalysisTime;
  if (timeSinceLastCall < MIN_ANALYSIS_INTERVAL) {
    await new Promise(resolve => setTimeout(resolve, MIN_ANALYSIS_INTERVAL - timeSinceLastCall));
  }
  lastAnalysisTime = Date.now();
  
  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });
    
    // Extract base64 data from data URL
    const base64Match = imageData.match(/^data:image\/(\w+);base64,(.+)$/);
    if (!base64Match) {
      throw new Error('Invalid image data format');
    }
    
    const imageType = base64Match[1];
    const base64Data = base64Match[2];
    const mimeType = `image/${imageType}`;
    
    const prompt = `Analyze this image of a product or item for inventory management. Extract:

1. **Visible Text**: All readable text on packaging, labels, or product
2. **Barcodes**: Any UPC, EAN, or other barcodes (numbers only if readable)
3. **Product Name**: A concise, shop-floor friendly name (max 50 chars, no brand)
4. **Supplier/Brand**: The manufacturer, brand, or supplier name
5. **Item Type**: Is this:
   - "external" (commercially purchased with retail packaging)
   - "internal" (internally produced, handwritten labels, custom markings)

Respond ONLY with valid JSON:
{
  "extractedText": ["text1", "text2"],
  "detectedBarcodes": ["123456789012"],
  "suggestedName": "Concise Product Name",
  "suggestedSupplier": "Brand Name",
  "isInternalItem": false
}

Omit fields that cannot be determined.`;

    const result = await model.generateContent([
      prompt,
      {
        inlineData: {
          mimeType,
          data: base64Data,
        },
      },
    ]);

    const response = result.response;
    const text = response.text();
    
    // Extract JSON from response
    const jsonMatch = text.match(/\{[\s\S]*?\}/);
    if (jsonMatch) {
      try {
        const parsed = JSON.parse(jsonMatch[0]);
        
        // Sanitize and validate response
        return {
          extractedText: Array.isArray(parsed.extractedText) 
            ? parsed.extractedText.slice(0, 20).map((t: unknown) => String(t).substring(0, 200))
            : undefined,
          detectedBarcodes: Array.isArray(parsed.detectedBarcodes)
            ? parsed.detectedBarcodes.slice(0, 10).map((b: unknown) => String(b).replace(/\D/g, '').substring(0, 20))
            : undefined,
          suggestedName: typeof parsed.suggestedName === 'string' 
            ? parsed.suggestedName.substring(0, 100) 
            : undefined,
          suggestedSupplier: typeof parsed.suggestedSupplier === 'string'
            ? parsed.suggestedSupplier.substring(0, 100)
            : undefined,
          isInternalItem: typeof parsed.isInternalItem === 'boolean' 
            ? parsed.isInternalItem 
            : undefined,
        };
      } catch {
        appLogger.warn({ responseText: text.substring(0, 200) }, 'Failed to parse Gemini response JSON');
        return {};
      }
    }
    
    appLogger.warn({ responseText: text.substring(0, 200) }, 'No JSON found in Gemini response');
    return {};
  } catch (error: any) {
    // Check for rate limiting
    if (error?.status === 429 || error?.message?.includes('rate')) {
      appLogger.warn('Gemini rate limited, will retry later');
      throw new Error('Analysis rate limited, please try again');
    }
    
    appLogger.error('Gemini analysis error:', error?.message || error);
    throw new Error('Image analysis failed');
  }
}

/**
 * POST /api/photo/upload
 * Upload a base64 image and get a URL back
 * Used for syncing images to Arda - converts data URLs to hosted URLs
 */
router.post('/upload', async (req: Request, res: Response) => {
  try {
    const { imageData } = req.body;
    
    // Validate image data
    const validation = isValidImageData(imageData);
    if (!validation.valid) {
      return res.status(400).json({ error: validation.error });
    }
    
    // Generate unique image ID
    const imageId = `img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // Store image data
    if (redisClient) {
      try {
        await redisClient.setex(
          `${IMAGE_UPLOAD_PREFIX}${imageId}`,
          IMAGE_TTL,
          imageData
        );
      } catch (error) {
        appLogger.error({ err: error }, 'Redis set image error');
        return res.status(500).json({ error: 'Failed to store image' });
      }
    } else {
      // In-memory fallback (not recommended for production)
      memoryPhotoData.set(`upload-${imageId}`, imageData);
    }
    
    // Build the URL for this image
    const baseUrl = process.env.BACKEND_URL || `${req.protocol}://${req.get('host')}`;
    const imageUrl = `${baseUrl}/api/photo/image/${imageId}`;
    
    appLogger.info(`Image uploaded: ${imageId} (${Math.round(validation.sizeBytes / 1024)}KB)`);
    
    res.json({ 
      success: true, 
      imageId,
      imageUrl,
    });
  } catch (error) {
    appLogger.error({ err: error }, 'Image upload error');
    res.status(500).json({ error: 'Failed to upload image' });
  }
});

/**
 * GET /api/photo/image/:imageId
 * Serve a stored image by ID
 */
router.get('/image/:imageId', async (req: Request, res: Response) => {
  try {
    const { imageId } = req.params;
    
    // Validate image ID format
    if (!/^img-\d+-[a-z0-9]+$/.test(imageId)) {
      return res.status(400).json({ error: 'Invalid image ID format' });
    }
    
    // Retrieve image data
    let imageData: string | null = null;
    
    if (redisClient) {
      try {
        imageData = await redisClient.get(`${IMAGE_UPLOAD_PREFIX}${imageId}`);
      } catch (error) {
        appLogger.error({ err: error }, 'Redis get image error');
      }
    }
    
    // Fallback to memory
    if (!imageData) {
      imageData = memoryPhotoData.get(`upload-${imageId}`) || null;
    }
    
    if (!imageData) {
      return res.status(404).json({ error: 'Image not found' });
    }
    
    // Parse the data URL
    const match = imageData.match(/^data:image\/(\w+);base64,(.+)$/);
    if (!match) {
      return res.status(500).json({ error: 'Invalid image data format' });
    }
    
    const imageType = match[1];
    const base64Data = match[2];
    const buffer = Buffer.from(base64Data, 'base64');
    
    // Set appropriate headers and send image
    res.set({
      'Content-Type': `image/${imageType}`,
      'Content-Length': buffer.length,
      'Cache-Control': 'public, max-age=31536000', // Cache for 1 year
    });
    
    res.send(buffer);
  } catch (error) {
    appLogger.error({ err: error }, 'Image serve error');
    res.status(500).json({ error: 'Failed to serve image' });
  }
});

export default router;

```

### `server/src/routes/scan.ts`

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import redisClient from '../utils/redisClient.js';
import { requireRedis } from '../config.js';
import { appLogger } from '../middleware/requestLogger.js';
import { lookupProductByBarcode } from '../services/barcodeLookup.js';

const router = Router();

// Constants
const SESSION_TTL = 24 * 60 * 60; // 24 hours in seconds
const MAX_BARCODES_PER_SESSION = 500;
const MAX_BARCODE_LENGTH = 50;
const REDIS_PREFIX = 'scan:session:';

// Types
interface ScannedBarcode {
  id: string;
  barcode: string;
  barcodeType: string;
  scannedAt: string;
  source: 'desktop' | 'mobile';
  productName?: string;
  brand?: string;
  imageUrl?: string;
  category?: string;
  updatedAt?: string;
}

interface ScanSession {
  barcodes: ScannedBarcode[];
  createdAt: string;
  lastActivity: string;
  userId?: string;
}

// In-memory fallback when Redis is not available
const memoryStore = new Map<string, ScanSession>();

// Validate session ID format (alphanumeric with dashes)
const isValidSessionId = (sessionId: string): boolean => {
  return /^[a-zA-Z0-9-_]{10,64}$/.test(sessionId);
};

// Validate barcode format
const isValidBarcode = (barcode: string): boolean => {
  if (!barcode || typeof barcode !== 'string') return false;
  if (barcode.length > MAX_BARCODE_LENGTH) return false;
  // Allow alphanumeric barcodes
  return /^[a-zA-Z0-9-]+$/.test(barcode);
};

const sanitizeOptionalString = (value: unknown, maxLength: number): string | undefined => {
  if (value === undefined || value === null) return undefined;
  if (typeof value !== 'string') return undefined;
  const trimmed = value.trim();
  if (!trimmed) return undefined;
  return trimmed.slice(0, maxLength);
};

// Get session from Redis or memory
const getSession = async (sessionId: string): Promise<ScanSession> => {
  if (redisClient) {
    try {
      const data = await redisClient.get(`${REDIS_PREFIX}${sessionId}`);
      if (data) {
        return JSON.parse(data);
      }
    } catch (error) {
      appLogger.error({ err: error }, 'Redis get error');
    }
  }
  
  // Fallback to memory
  const session = memoryStore.get(sessionId);
  if (session) return session;
  
  // Create new session
  const newSession: ScanSession = {
    barcodes: [],
    createdAt: new Date().toISOString(),
    lastActivity: new Date().toISOString(),
  };
  
  return newSession;
};

// Save session to Redis or memory
const saveSession = async (sessionId: string, session: ScanSession): Promise<void> => {
  session.lastActivity = new Date().toISOString();
  
  if (redisClient) {
    try {
      await redisClient.setex(
        `${REDIS_PREFIX}${sessionId}`,
        SESSION_TTL,
        JSON.stringify(session)
      );
      return;
    } catch (error) {
      appLogger.error({ err: error }, 'Redis set error');
    }
  }
  
  // Fallback to memory
  memoryStore.set(sessionId, session);
  
  // Clean up old memory sessions periodically
  if (memoryStore.size > 1000) {
    const now = Date.now();
    for (const [id, sess] of memoryStore.entries()) {
      if (now - new Date(sess.lastActivity).getTime() > SESSION_TTL * 1000) {
        memoryStore.delete(id);
      }
    }
  }
};

// Session ID validation middleware
const validateSessionId = (req: Request, res: Response, next: NextFunction) => {
  const { sessionId } = req.params;
  if (!isValidSessionId(sessionId)) {
    return res.status(400).json({ error: 'Invalid session ID format' });
  }
  next();
};

const ensureRedis = (res: Response): boolean => {
  if (requireRedis && !redisClient) {
    res.status(503).json({ error: 'Redis unavailable; scanning sessions require persistent storage' });
    return false;
  }
  return true;
};

/**
 * GET /api/scan/session/:sessionId/barcodes
 * Get all barcodes for a session (used by desktop to poll for mobile scans)
 */
router.get('/session/:sessionId/barcodes', validateSessionId, async (req: Request, res: Response) => {
  try {
    if (!ensureRedis(res)) return;
    const { sessionId } = req.params;
    const { since } = req.query;
    
    const session = await getSession(sessionId);
    let barcodes = session.barcodes;
    
    // Filter by timestamp if provided
    if (since && typeof since === 'string') {
      const sinceDate = new Date(since);
      if (!isNaN(sinceDate.getTime())) {
        barcodes = barcodes.filter(b => new Date(b.scannedAt) > sinceDate);
      }
    }
    
    res.json({ 
      barcodes,
      sessionCreatedAt: session.createdAt,
      totalCount: session.barcodes.length,
    });
  } catch (error) {
    appLogger.error({ err: error }, 'Get barcodes error');
    res.status(500).json({ error: 'Failed to retrieve barcodes' });
  }
});

/**
 * POST /api/scan/session/:sessionId/barcode
 * Add a barcode to a session (used by mobile scanner and desktop scanner)
 */
router.post('/session/:sessionId/barcode', validateSessionId, async (req: Request, res: Response) => {
  try {
    if (!ensureRedis(res)) return;
    const { sessionId } = req.params;
    const { id, data, timestamp, barcodeType, source, productName, brand, imageUrl, category } = req.body;
    const barcodeValue = typeof data === 'string' ? data : req.body?.barcode;
    
    // Validate input
    if (!barcodeValue || typeof barcodeValue !== 'string') {
      return res.status(400).json({ error: 'Barcode data is required' });
    }
    
    const cleanBarcode = barcodeValue.trim();
    if (!isValidBarcode(cleanBarcode)) {
      return res.status(400).json({ error: 'Invalid barcode format' });
    }
    
    const session = await getSession(sessionId);
    
    // Check for duplicates
    const existingBarcode = session.barcodes.find((entry) => entry.barcode === cleanBarcode);
    if (existingBarcode) {
      await saveSession(sessionId, session);
      return res.json({ success: true, duplicate: true, barcode: existingBarcode });
    }

    // Check session limits
    if (session.barcodes.length >= MAX_BARCODES_PER_SESSION) {
      return res.status(429).json({ 
        error: 'Session barcode limit reached',
        limit: MAX_BARCODES_PER_SESSION,
      });
    }
    
    // Look up product info (cached, with timeout)
    const hasProvidedMetadata = Boolean(productName || brand || imageUrl || category);
    const productInfo = hasProvidedMetadata
      ? null
      : await lookupProductByBarcode(cleanBarcode, { timeoutMs: 5000 });
    
    const barcode: ScannedBarcode = {
      id: id || `scan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      barcode: cleanBarcode,
      barcodeType: sanitizeOptionalString(barcodeType, 24) || detectBarcodeType(cleanBarcode),
      scannedAt: timestamp || new Date().toISOString(),
      source: source === 'desktop' ? 'desktop' : 'mobile',
      productName: sanitizeOptionalString(productName, 200) || productInfo?.name,
      brand: sanitizeOptionalString(brand, 120) || productInfo?.brand,
      imageUrl: sanitizeOptionalString(imageUrl, 1000) || productInfo?.imageUrl,
      category: sanitizeOptionalString(category, 120) || productInfo?.category,
    };
    
    session.barcodes.push(barcode);
    await saveSession(sessionId, session);
    
    appLogger.info(`Barcode scanned: ${cleanBarcode} in session ${sessionId.substring(0, 8)}...`);
    
    res.json({ success: true, barcode });
  } catch (error) {
    appLogger.error({ err: error }, 'Add barcode error');
    res.status(500).json({ error: 'Failed to save barcode' });
  }
});

/**
 * PUT /api/scan/session/:sessionId/barcode/:barcodeId
 * Update barcode metadata for an existing session barcode
 */
router.put('/session/:sessionId/barcode/:barcodeId', validateSessionId, async (req: Request, res: Response) => {
  try {
    if (!ensureRedis(res)) return;
    const { sessionId, barcodeId } = req.params;
    const session = await getSession(sessionId);
    const existingIndex = session.barcodes.findIndex((item) => item.id === barcodeId);

    if (existingIndex === -1) {
      return res.status(404).json({ error: 'Barcode not found' });
    }

    const existing = session.barcodes[existingIndex];
    const hasBarcode = Object.prototype.hasOwnProperty.call(req.body, 'barcode');
    const nextBarcodeRaw = hasBarcode ? req.body.barcode : existing.barcode;

    if (typeof nextBarcodeRaw !== 'string') {
      return res.status(400).json({ error: 'Barcode must be a string' });
    }

    const nextBarcode = nextBarcodeRaw.trim();
    if (!isValidBarcode(nextBarcode)) {
      return res.status(400).json({ error: 'Invalid barcode format' });
    }

    const duplicateByBarcode = session.barcodes.find(
      (item) => item.id !== barcodeId && item.barcode === nextBarcode,
    );
    if (duplicateByBarcode) {
      return res.status(409).json({ error: 'Another barcode with that value already exists in session' });
    }

    const barcodeType = sanitizeOptionalString(req.body.barcodeType, 24) || existing.barcodeType;
    const updated: ScannedBarcode = {
      ...existing,
      barcode: nextBarcode,
      barcodeType,
      productName: Object.prototype.hasOwnProperty.call(req.body, 'productName')
        ? sanitizeOptionalString(req.body.productName, 200)
        : existing.productName,
      brand: Object.prototype.hasOwnProperty.call(req.body, 'brand')
        ? sanitizeOptionalString(req.body.brand, 120)
        : existing.brand,
      imageUrl: Object.prototype.hasOwnProperty.call(req.body, 'imageUrl')
        ? sanitizeOptionalString(req.body.imageUrl, 1000)
        : existing.imageUrl,
      category: Object.prototype.hasOwnProperty.call(req.body, 'category')
        ? sanitizeOptionalString(req.body.category, 120)
        : existing.category,
      updatedAt: new Date().toISOString(),
    };

    session.barcodes[existingIndex] = updated;
    await saveSession(sessionId, session);

    res.json({ success: true, barcode: updated });
  } catch (error) {
    appLogger.error({ err: error }, 'Update barcode error');
    res.status(500).json({ error: 'Failed to update barcode' });
  }
});

/**
 * GET /api/barcode/lookup
 * Look up product information from a barcode
 */
router.get('/lookup', async (req: Request, res: Response) => {
  const { code } = req.query;
  
  if (!code || typeof code !== 'string') {
    return res.status(400).json({ error: 'Barcode code is required' });
  }
  
  const cleanCode = code.trim();
  if (!isValidBarcode(cleanCode)) {
    return res.status(400).json({ error: 'Invalid barcode format' });
  }
  
  try {
    const productInfo = await lookupProductByBarcode(cleanCode, { timeoutMs: 5000 });
    if (productInfo?.name) return res.json(productInfo);
    return res.status(404).json({ error: 'Product not found' });
  } catch (error) {
    appLogger.error({ err: error }, 'Barcode lookup error');
    res.status(500).json({ error: 'Lookup failed' });
  }
});

/**
 * Detect barcode type from string
 */
function detectBarcodeType(barcode: string): string {
  const digits = barcode.replace(/\D/g, '');
  if (digits.length === 12) return 'UPC-A';
  if (digits.length === 13) return 'EAN-13';
  if (digits.length === 8) return 'EAN-8';
  if (digits.length === 14) return 'GTIN-14';
  return 'unknown';
}

export default router;

```

### `server/src/routes/urlIngestion.test.ts`

```typescript
import express from 'express';
import { AddressInfo } from 'node:net';
import type { Server } from 'node:http';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const mockScrapeUrls = vi.fn();

vi.mock('../services/urlScraper.js', () => ({
  urlScraper: {
    scrapeUrls: mockScrapeUrls,
  },
}));

async function startServer(sessionUserId?: string): Promise<{ server: Server; baseUrl: string }> {
  const { urlIngestionRouter } = await import('./urlIngestion.js');
  const app = express();
  app.use(express.json());
  app.use((req, _res, next) => {
    (req as any).session = sessionUserId ? { userId: sessionUserId } : {};
    next();
  });
  app.use('/api/url-ingestion', urlIngestionRouter);

  const server = app.listen(0);
  await new Promise<void>((resolve) => server.once('listening', resolve));
  const address = server.address() as AddressInfo;
  return {
    server,
    baseUrl: `http://127.0.0.1:${address.port}`,
  };
}

describe('urlIngestion routes', () => {
  let server: Server | null = null;
  let baseUrl = '';

  beforeEach(async () => {
    vi.resetModules();
    vi.clearAllMocks();
    ({ server, baseUrl } = await startServer('user-1'));
  });

  afterEach(async () => {
    if (server) {
      await new Promise<void>((resolve, reject) => {
        server?.close((err) => (err ? reject(err) : resolve()));
      });
      server = null;
    }
  });

  it('requires authentication', async () => {
    if (server) {
      await new Promise<void>((resolve, reject) => {
        server?.close((err) => (err ? reject(err) : resolve()));
      });
    }

    ({ server, baseUrl } = await startServer(undefined));

    const response = await fetch(`${baseUrl}/api/url-ingestion/scrape`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ urls: ['https://example.com'] }),
    });

    expect(response.status).toBe(401);
  });

  it('rejects invalid request body', async () => {
    const response = await fetch(`${baseUrl}/api/url-ingestion/scrape`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ urls: 'https://example.com' }),
    });

    expect(response.status).toBe(400);
    expect(mockScrapeUrls).not.toHaveBeenCalled();
  });

  it('enforces max URL limit of 50', async () => {
    const urls = Array.from({ length: 51 }, (_, idx) => `https://example.com/${idx}`);

    const response = await fetch(`${baseUrl}/api/url-ingestion/scrape`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ urls }),
    });

    expect(response.status).toBe(400);
    expect(mockScrapeUrls).not.toHaveBeenCalled();
  });

  it('returns mixed scrape results and normalized items', async () => {
    mockScrapeUrls.mockResolvedValue({
      requested: 2,
      processed: 2,
      results: [
        {
          sourceUrl: 'https://example.com/a',
          status: 'success',
          extractionSource: 'html-metadata',
          item: {
            sourceUrl: 'https://example.com/a',
            productUrl: 'https://example.com/a',
            itemName: 'Item A',
            supplier: 'Vendor A',
            needsReview: false,
            extractionSource: 'html-metadata',
            confidence: 0.7,
          },
        },
        {
          sourceUrl: 'https://example.com/b',
          status: 'failed',
          extractionSource: 'error',
          item: {
            sourceUrl: 'https://example.com/b',
            needsReview: true,
            extractionSource: 'error',
            confidence: 0,
          },
        },
      ],
      items: [
        {
          sourceUrl: 'https://example.com/a',
          productUrl: 'https://example.com/a',
          itemName: 'Item A',
          supplier: 'Vendor A',
          needsReview: false,
          extractionSource: 'html-metadata',
          confidence: 0.7,
        },
        {
          sourceUrl: 'https://example.com/b',
          needsReview: true,
          extractionSource: 'error',
          confidence: 0,
        },
      ],
    });

    const response = await fetch(`${baseUrl}/api/url-ingestion/scrape`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        urls: ['https://example.com/a', 'https://example.com/a', 'https://example.com/b'],
      }),
    });

    expect(response.status).toBe(200);
    expect(mockScrapeUrls).toHaveBeenCalledWith(['https://example.com/a', 'https://example.com/b']);

    const payload = await response.json() as {
      requested: number;
      processed: number;
      results: unknown[];
      items: unknown[];
    };

    expect(payload.requested).toBe(2);
    expect(payload.results).toHaveLength(2);
    expect(payload.items).toHaveLength(2);
  });
});

```

### `server/src/routes/urlIngestion.ts`

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { urlScraper } from '../services/urlScraper.js';

const router = Router();

async function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  next();
}

router.post('/scrape', requireAuth, async (req: Request, res: Response) => {
  try {
    const { urls } = req.body as { urls?: unknown };

    if (!Array.isArray(urls)) {
      return res.status(400).json({ error: 'urls must be an array of strings' });
    }

    const deduped = Array.from(
      new Set(
        urls
          .filter((url): url is string => typeof url === 'string')
          .map(url => url.trim())
          .filter(Boolean)
      )
    );

    if (deduped.length === 0) {
      return res.status(400).json({ error: 'At least one URL is required' });
    }

    if (deduped.length > 50) {
      return res.status(400).json({ error: 'Maximum 50 URLs are allowed per request' });
    }

    const scraped = await urlScraper.scrapeUrls(deduped);
    res.json(scraped);
  } catch (error) {
    console.error('URL scraping error:', error);
    res.status(500).json({ error: 'Failed to scrape URLs' });
  }
});

export { router as urlIngestionRouter };

```

### `server/src/scripts/ensureCognitoUser.ts`

```typescript
import {
  CognitoIdentityProviderClient,
  ListUsersCommand,
  AdminCreateUserCommand,
  AdminUpdateUserAttributesCommand,
} from '@aws-sdk/client-cognito-identity-provider';

type Args = {
  email: string;
  tenantId: string;
  role: string;
  name?: string;
  suppressMessage: boolean;
};

const USAGE = `
Usage: tsx src/scripts/ensureCognitoUser.ts --email <email> --tenant <tenantId> [--role <role>] [--name <name>] [--send-invite]

Required:
  --email    User email address (used for lookup)
  --tenant   Tenant ID to assign (custom:tenant)

Optional:
  --role     Cognito role to set (default: User)
  --name     Display name to set (name attribute)
  --send-invite  Send the Cognito invite email (default: suppressed)
`;

function parseArgs(argv: string[]): Args {
  const args: Record<string, string | boolean> = {};
  for (let i = 0; i < argv.length; i += 1) {
    const token = argv[i];
    if (!token) continue;
    if (token === '--send-invite') {
      args.sendInvite = true;
      continue;
    }
    if (!token.startsWith('--')) continue;
    const key = token.slice(2);
    const value = argv[i + 1];
    if (!value || value.startsWith('--')) {
      throw new Error(`Missing value for ${token}`);
    }
    args[key] = value;
    i += 1;
  }

  const email = String(args.email || '').trim();
  const tenantId = String(args.tenant || '').trim();
  if (!email || !tenantId) {
    throw new Error('Missing required --email or --tenant');
  }

  return {
    email,
    tenantId,
    role: String(args.role || 'User'),
    name: args.name ? String(args.name) : undefined,
    suppressMessage: !args.sendInvite,
  };
}

function buildClient(): { client: CognitoIdentityProviderClient; userPoolId: string } {
  const region = process.env.COGNITO_AWS_REGION || process.env.AWS_REGION;
  const userPoolId = process.env.COGNITO_USER_POOL_ID;

  if (!region || !userPoolId) {
    throw new Error('COGNITO_AWS_REGION/AWS_REGION and COGNITO_USER_POOL_ID are required');
  }

  const accessKeyId = process.env.COGNITO_AWS_ACCESS_KEY_ID || process.env.AWS_ACCESS_KEY_ID;
  const secretAccessKey = process.env.COGNITO_AWS_SECRET_ACCESS_KEY || process.env.AWS_SECRET_ACCESS_KEY;
  const sessionToken = process.env.COGNITO_AWS_SESSION_TOKEN || process.env.AWS_SESSION_TOKEN;

  const client = new CognitoIdentityProviderClient({
    region,
    ...(accessKeyId && secretAccessKey ? {
      credentials: {
        accessKeyId,
        secretAccessKey,
        sessionToken,
      },
    } : {}),
  });

  return { client, userPoolId };
}

async function findUserByEmail(client: CognitoIdentityProviderClient, userPoolId: string, email: string) {
  const response = await client.send(new ListUsersCommand({
    UserPoolId: userPoolId,
    Filter: `email = "${email}"`,
    Limit: 1,
  }));

  const user = response.Users?.[0];
  return user ? { username: user.Username || email, attributes: user.Attributes || [] } : null;
}

async function run() {
  const args = parseArgs(process.argv.slice(2));
  const { client, userPoolId } = buildClient();

  const existing = await findUserByEmail(client, userPoolId, args.email);
  const attributes = [
    { Name: 'email', Value: args.email },
    { Name: 'email_verified', Value: 'true' },
    { Name: 'custom:tenant', Value: args.tenantId },
    { Name: 'custom:role', Value: args.role },
  ];

  if (args.name) {
    attributes.push({ Name: 'name', Value: args.name });
  }

  if (existing) {
    await client.send(new AdminUpdateUserAttributesCommand({
      UserPoolId: userPoolId,
      Username: existing.username,
      UserAttributes: attributes,
    }));
    console.log(`✅ Updated Cognito user ${args.email} (username: ${existing.username})`);
    return;
  }

  await client.send(new AdminCreateUserCommand({
    UserPoolId: userPoolId,
    Username: args.email,
    UserAttributes: attributes,
    MessageAction: args.suppressMessage ? 'SUPPRESS' : undefined,
  }));

  console.log(`✅ Created Cognito user ${args.email}`);
}

run().catch((error) => {
  console.error('❌ Failed to ensure Cognito user:', error instanceof Error ? error.message : error);
  if (error instanceof Error && error.stack) {
    console.error(error.stack);
  }
  console.log(USAGE.trim());
  process.exit(1);
});

```

### `server/src/services/amazon.ts`

```typescript
// Amazon Product Advertising API Integration
// Uses the official Amazon PAAPI 5.0 SDK

import amazonPaapi from 'amazon-paapi';

interface AmazonItemResponse {
  ASIN: string;
  ItemName?: string;
  Price?: string;
  ImageURL?: string;
  AmazonURL?: string;
  Quantity?: string;
  Units?: string;
  UnitCount?: number;
  UnitPrice?: number;
  UPC?: string;
}

// API Configuration - loaded from environment variables
const AMAZON_API_CONFIG = {
  accessKey: process.env.AMAZON_ACCESS_KEY || '',
  secretKey: process.env.AMAZON_SECRET_KEY || '',
  partnerTag: process.env.AMAZON_PARTNER_TAG || 'arda06-20',
  partnerType: 'Associates' as const,
  marketplace: 'www.amazon.com' as const,
};

// ASIN pattern: B followed by 9 alphanumeric, or 10 digits
// const ASIN_PATTERN = /\b(B0[A-Z0-9]{8}|[0-9]{10})\b/gi;

// Extract ASINs from email content
export function extractAsinsFromEmail(emailBody: string, emailSubject: string): string[] {
  const text = `${emailSubject} ${emailBody}`;
  
  // Decode HTML entities and URL encoding that might hide ASINs
  const decodedText = text
    .replace(/&#x2F;/g, '/')
    .replace(/&#47;/g, '/')
    .replace(/%2F/gi, '/')
    .replace(/&amp;/g, '&')
    .replace(/&#x3D;/g, '=')
    .replace(/%3D/gi, '=');
  
  const allMatches: string[] = [];
  
  // Pattern 1: Extract from Amazon product URLs (most reliable)
  // Handles various URL formats including encoded ones
  const urlPatterns = [
    /amazon\.com[^"'\s]*?\/dp\/([A-Z0-9]{10})/gi,
    /amazon\.com[^"'\s]*?\/gp\/product\/([A-Z0-9]{10})/gi,
    /amazon\.com[^"'\s]*?\/gp\/aw\/d\/([A-Z0-9]{10})/gi,  // Mobile URLs
    /amazon\.com[^"'\s]*?ASIN[=/]([A-Z0-9]{10})/gi,
    /a\.co\/d\/([A-Za-z0-9]+)/gi,  // Short URLs (may need expansion)
  ];
  
  for (const pattern of urlPatterns) {
    const matches = [...decodedText.matchAll(pattern)].map(m => m[1].toUpperCase());
    allMatches.push(...matches);
  }
  
  // Pattern 2: Extract B0-prefixed ASINs from anywhere in text
  // These are very reliable as they have a distinctive pattern
  const b0Pattern = /\b(B0[A-Z0-9]{8})\b/gi;
  const b0Matches = [...decodedText.matchAll(b0Pattern)].map(m => m[1].toUpperCase());
  allMatches.push(...b0Matches);
  
  // Pattern 3: Look for ASINs in href attributes specifically
  const hrefPattern = /href\s*=\s*["'][^"']*?\/([A-Z0-9]{10})[^"']*?["']/gi;
  const hrefMatches = [...decodedText.matchAll(hrefPattern)]
    .map(m => m[1].toUpperCase())
    .filter(asin => asin.startsWith('B0') || /^[0-9]{10}$/.test(asin) === false);
  allMatches.push(...hrefMatches);
  
  // Deduplicate
  const uniqueMatches = [...new Set(allMatches)];
  
  // Filter out false positives
  const asins = uniqueMatches.filter(asin => {
    // Must be exactly 10 characters
    if (asin.length !== 10) return false;
    
    // If all digits, it's likely a timestamp or phone number - reject
    if (/^[0-9]{10}$/.test(asin)) return false;
    
    // Must contain at least one letter (real ASINs almost always do)
    if (!/[A-Z]/.test(asin)) return false;
    
    return true;
  });
  
  console.log(`📦 Extracted ${asins.length} ASINs from email:`, asins.slice(0, 5), asins.length > 5 ? `... (${asins.length} total)` : '');
  
  return asins;
}

// Get the affiliate tag from config
export function getAffiliateTag(): string {
  return process.env.AMAZON_PARTNER_TAG || 'arda06-20';
}

// Create an affiliate-tagged Amazon product URL from an ASIN
export function createAffiliateUrl(asin: string): string {
  const tag = getAffiliateTag();
  return `https://www.amazon.com/dp/${asin}?tag=${tag}`;
}

// Ensure a product URL has the affiliate tag
export function ensureAffiliateTag(url: string): string {
  if (!url) return url;
  
  const tag = getAffiliateTag();
  
  // If URL already has our tag, return as-is
  if (url.includes(`tag=${tag}`)) {
    return url;
  }
  
  // Try to extract ASIN and create clean affiliate URL
  const asin = extractAsinFromUrl(url);
  if (asin) {
    return createAffiliateUrl(asin);
  }
  
  // If we can't extract ASIN but it's an Amazon URL, append tag
  if (url.includes('amazon.com')) {
    const separator = url.includes('?') ? '&' : '?';
    // Remove any existing tag first
    const cleanUrl = url.replace(/[?&]tag=[^&]+/g, '');
    return `${cleanUrl}${separator}tag=${tag}`;
  }
  
  return url;
}

// Extract ASINs from Amazon product URLs
export function extractAsinFromUrl(url: string): string | null {
  // Patterns for Amazon product URLs
  const patterns = [
    /amazon\.com\/dp\/([A-Z0-9]{10})/i,
    /amazon\.com\/gp\/product\/([A-Z0-9]{10})/i,
    /amazon\.com\/.*\/dp\/([A-Z0-9]{10})/i,
    /amzn\.to\/([A-Z0-9]+)/i,  // Short links (would need redirect follow)
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }
  
  return null;
}

// Fetch item details from Amazon API using official PAAPI 5.0
export async function getAmazonItemDetails(asins: string[]): Promise<Map<string, AmazonItemResponse>> {
  const results = new Map<string, AmazonItemResponse>();
  
  if (asins.length === 0) {
    return results;
  }
  
  // Check if credentials are configured
  if (!AMAZON_API_CONFIG.accessKey || !AMAZON_API_CONFIG.secretKey) {
    console.warn('⚠️ Amazon API credentials not configured');
    return results;
  }
  
  try {
    console.log(`🛒 Fetching Amazon data for ${asins.length} ASINs:`, asins);
    
    // Amazon PAAPI allows max 10 items per request
    const batchSize = 10;
    
    for (let i = 0; i < asins.length; i += batchSize) {
      const batch = asins.slice(i, i + batchSize);
      
      try {
        const commonParameters = {
          AccessKey: AMAZON_API_CONFIG.accessKey,
          SecretKey: AMAZON_API_CONFIG.secretKey,
          PartnerTag: AMAZON_API_CONFIG.partnerTag,
          PartnerType: AMAZON_API_CONFIG.partnerType,
          Marketplace: AMAZON_API_CONFIG.marketplace,
        };
        
        const requestParameters = {
          ItemIds: batch,
          ItemIdType: 'ASIN' as const,
          Condition: 'New' as const,
          Resources: [
            'ItemInfo.Title',
            'ItemInfo.ProductInfo',
            'ItemInfo.ExternalIds',
            'Images.Primary.Large',
            'Offers.Listings.Price',
          ],
        };
        
        const response = await amazonPaapi.GetItems(commonParameters, requestParameters);
        
        if (response.ItemsResult?.Items) {
          for (const item of response.ItemsResult.Items) {
            // Ensure the URL has our affiliate tag
            const amazonUrl = item.DetailPageURL 
              ? ensureAffiliateTag(item.DetailPageURL)
              : createAffiliateUrl(item.ASIN);
            
            const itemData: AmazonItemResponse = {
              ASIN: item.ASIN,
              ItemName: item.ItemInfo?.Title?.DisplayValue,
              Price: item.Offers?.Listings?.[0]?.Price?.DisplayAmount,
              ImageURL: item.Images?.Primary?.Large?.URL,
              AmazonURL: amazonUrl,
              UnitCount: item.ItemInfo?.ProductInfo?.UnitCount?.DisplayValue,
            };
            
            // Parse numeric unit price from display price string (e.g., "$19.99" -> 19.99)
            if (itemData.Price) {
              const numericPrice = parseFloat(itemData.Price.replace(/[^0-9.]/g, ''));
              if (!isNaN(numericPrice)) {
                itemData.UnitPrice = numericPrice;
              }
            }
            
            // Extract UPC from ExternalIds
            const upcs = item.ItemInfo?.ExternalIds?.UPCs?.DisplayValues;
            if (upcs && upcs.length > 0) {
              itemData.UPC = upcs[0];
            }
            
            results.set(item.ASIN, itemData);
            console.log(`  ✓ ${item.ASIN}: ${itemData.ItemName?.substring(0, 50)}...`);
          }
        }
        
        // Rate limit: wait between batches
        if (i + batchSize < asins.length) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
      } catch (batchError: any) {
        console.error(`Error fetching batch starting at ${i}:`, batchError?.message || batchError);
      }
    }
    
    console.log(`✅ Got Amazon data for ${results.size}/${asins.length} items`);
  } catch (error) {
    console.error('Amazon API fetch error:', error);
  }
  
  return results;
}

// Enrich a single item with Amazon data
export async function enrichItemWithAmazon(asin: string): Promise<AmazonItemResponse | null> {
  const results = await getAmazonItemDetails([asin]);
  return results.get(asin) || null;
}

// Batch enrich multiple items
export async function batchEnrichItems(asins: string[]): Promise<Map<string, AmazonItemResponse>> {
  // API may have rate limits, so batch in groups of 10
  const batchSize = 10;
  const allResults = new Map<string, AmazonItemResponse>();
  
  for (let i = 0; i < asins.length; i += batchSize) {
    const batch = asins.slice(i, i + batchSize);
    const results = await getAmazonItemDetails(batch);
    
    for (const [asin, data] of results) {
      allResults.set(asin, data);
    }
    
    // Rate limit: wait 1 second between batches
    if (i + batchSize < asins.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  return allResults;
}

export const amazonService = {
  extractAsinsFromEmail,
  extractAsinFromUrl,
  getAmazonItemDetails,
  enrichItemWithAmazon,
  batchEnrichItems,
  getAffiliateTag,
  createAffiliateUrl,
  ensureAffiliateTag,
};

```

### `server/src/services/arda.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

const originalEnv = process.env;

const mockGetUserByEmail = vi.fn();
const fetchMock = vi.fn();

vi.mock('./cognito.js', () => ({
  cognitoService: {
    getUserByEmail: mockGetUserByEmail,
  },
}));

function mockArdaSuccessResponse() {
  fetchMock.mockResolvedValue({
    ok: true,
    json: async () => ({
      rId: 'record-1',
      asOf: { effective: Date.now(), recorded: Date.now() },
      payload: {},
      metadata: {},
      retired: false,
    }),
  });
}

describe('arda service', () => {
  beforeEach(() => {
    vi.resetModules();
    vi.clearAllMocks();
    process.env = { ...originalEnv };
    vi.stubGlobal('fetch', fetchMock);
  });

  afterEach(() => {
    process.env = originalEnv;
    vi.unstubAllGlobals();
  });

  describe('isMockMode', () => {
    it('returns true when ARDA_MOCK_MODE is true', async () => {
      process.env.ARDA_MOCK_MODE = 'true';
      process.env.ARDA_API_KEY = 'test-key';
      process.env.ARDA_TENANT_ID = 'test-tenant';

      const { isMockMode } = await import('./arda.js');
      expect(isMockMode()).toBe(true);
    });

    it('returns true when ARDA_API_KEY is not set', async () => {
      delete process.env.ARDA_API_KEY;
      delete process.env.ARDA_TENANT_ID;
      delete process.env.ARDA_MOCK_MODE;

      const { isMockMode } = await import('./arda.js');
      expect(isMockMode()).toBe(true);
    });

    it('returns true when ARDA_TENANT_ID is placeholder', async () => {
      process.env.ARDA_API_KEY = 'real-key';
      process.env.ARDA_TENANT_ID = 'your_tenant_uuid_here';
      delete process.env.ARDA_MOCK_MODE;

      const { isMockMode } = await import('./arda.js');
      expect(isMockMode()).toBe(true);
    });
  });

  describe('ardaService.isConfigured', () => {
    it('returns false when API key is missing', async () => {
      delete process.env.ARDA_API_KEY;
      process.env.ARDA_TENANT_ID = 'valid-tenant';

      const { ardaService } = await import('./arda.js');
      expect(ardaService.isConfigured()).toBe(false);
    });

    it('returns false when tenant ID is placeholder', async () => {
      process.env.ARDA_API_KEY = 'valid-key';
      process.env.ARDA_TENANT_ID = 'your_tenant_uuid_here';

      const { ardaService } = await import('./arda.js');
      expect(ardaService.isConfigured()).toBe(false);
    });

    it('returns true when properly configured', async () => {
      process.env.ARDA_API_KEY = 'valid-key';
      process.env.ARDA_TENANT_ID = 'c35bb200-ce7f-4280-9108-f61227127a98';

      const { ardaService } = await import('./arda.js');
      expect(ardaService.isConfigured()).toBe(true);
    });
  });

  describe('tenant resolution precedence', () => {
    it('uses Cognito tenant for authenticated email even when ARDA_TENANT_ID is set', async () => {
      process.env.ARDA_API_KEY = 'valid-key';
      process.env.ARDA_TENANT_ID = 'global-tenant';

      mockGetUserByEmail.mockReturnValue({ tenantId: 'tenant-from-email' });
      mockArdaSuccessResponse();

      const { createItem } = await import('./arda.js');
      await createItem(
        { name: 'Coffee Filters', primarySupplier: 'Acme' },
        { author: 'author-sub', email: 'user@example.com' }
      );

      expect(mockGetUserByEmail).toHaveBeenCalledWith('user@example.com');
      expect(fetchMock).toHaveBeenCalledTimes(1);
      const [, init] = fetchMock.mock.calls[0];
      const headers = init.headers as Record<string, string>;
      expect(headers['X-Tenant-Id']).toBe('tenant-from-email');
      expect(headers['X-Author']).toBe('author-sub');
    });

    it('uses explicit actor tenantId over all other sources', async () => {
      process.env.ARDA_API_KEY = 'valid-key';
      process.env.ARDA_TENANT_ID = 'global-tenant';

      mockArdaSuccessResponse();

      const { createItem } = await import('./arda.js');
      await createItem(
        { name: 'Paper Towels', primarySupplier: 'SupplyCo' },
        { author: 'author-sub', email: 'user@example.com', tenantId: 'explicit-tenant' }
      );

      expect(mockGetUserByEmail).not.toHaveBeenCalled();
      const [, init] = fetchMock.mock.calls[0];
      const headers = init.headers as Record<string, string>;
      expect(headers['X-Tenant-Id']).toBe('explicit-tenant');
    });

    it('throws when authenticated email has no Cognito mapping even if ARDA_TENANT_ID is set', async () => {
      process.env.ARDA_API_KEY = 'valid-key';
      process.env.ARDA_TENANT_ID = 'global-tenant';

      mockGetUserByEmail.mockReturnValue(null);

      const { createItem } = await import('./arda.js');

      await expect(
        createItem(
          { name: 'Gloves', primarySupplier: 'Vendor' },
          { author: 'author-sub', email: 'missing@example.com' }
        )
      ).rejects.toThrow('No tenant mapping found for authenticated email missing@example.com');

      expect(fetchMock).not.toHaveBeenCalled();
    });

    it('uses ARDA_TENANT_ID for legacy non-email flows', async () => {
      process.env.ARDA_API_KEY = 'valid-key';
      process.env.ARDA_TENANT_ID = 'legacy-tenant';

      mockArdaSuccessResponse();

      const { createItem } = await import('./arda.js');
      await createItem(
        { name: 'Batteries', primarySupplier: 'Warehouse' },
        { author: 'legacy-author' }
      );

      expect(mockGetUserByEmail).not.toHaveBeenCalled();
      const [, init] = fetchMock.mock.calls[0];
      const headers = init.headers as Record<string, string>;
      expect(headers['X-Tenant-Id']).toBe('legacy-tenant');
    });
  });

  describe('provisionUserForEmail', () => {
    it('returns null when ARDA_API_KEY is missing', async () => {
      delete process.env.ARDA_API_KEY;
      const { provisionUserForEmail } = await import('./arda.js');

      await expect(provisionUserForEmail('new@example.com')).resolves.toBeNull();
      expect(fetchMock).not.toHaveBeenCalled();
    });

    it('returns actor credentials when provisioning endpoint returns tenant and author', async () => {
      process.env.ARDA_API_KEY = 'valid-key';

      fetchMock.mockResolvedValue({
        ok: true,
        json: async () => ({
          payload: {
            tenantId: 'tenant-created',
            sub: 'author-created',
          },
        }),
      });

      const { provisionUserForEmail } = await import('./arda.js');
      const actor = await provisionUserForEmail('new@example.com');

      expect(actor).toEqual({
        author: 'author-created',
        email: 'new@example.com',
        tenantId: 'tenant-created',
      });
    });
  });
});

```

### `server/src/services/arda.ts`

```typescript
// Arda API Service - Integration with prod.alpha001.io.arda.cards
import { v4 as uuidv4 } from 'uuid';

const ARDA_BASE_URL = process.env.ARDA_BASE_URL || 'https://prod.alpha001.io.arda.cards';
const ARDA_API_KEY = process.env.ARDA_API_KEY;

// Cache for tenant lookups (reserved for future use)
// const tenantCache = new Map<string, string>();

// Types based on Arda OpenAPI schemas (matching actual API structure)
export interface QuantityValue {
  amount: number;
  unit: string;
}

export interface ItemSupplyValue {
  supplier: string;
  name?: string;
  sku?: string;
  orderMethod?: 'EMAIL' | 'PHONE' | 'ONLINE';
  url?: string;
  orderQuantity?: QuantityValue;
  unitCost?: { value: number; currency: string };
}

export interface PhysicalLocatorValue {
  facility: string;
  department?: string;
  location?: string;
  subLocation?: string;
}

export type ItemColor = 'BLUE' | 'GREEN' | 'YELLOW' | 'ORANGE' | 'RED' | 'PINK' | 'PURPLE' | 'GRAY';

// Arda Item.Entity structure
export interface ArdaItemEntity {
  eId: string;
  name: string;
  description?: string;
  imageUrl?: string;
  locator?: PhysicalLocatorValue;
  internalSKU?: string;
  minQuantity?: QuantityValue;
  notes?: string;
  primarySupply?: ItemSupplyValue;
  itemColor?: ItemColor;
}

// Our simplified input that gets mapped to Arda format
export interface ItemInput {
  name: string;
  description?: string;
  primarySupplier: string;
  orderMechanism?: string;
  location?: string;
  minQty?: number;
  minQtyUnit?: string;
  orderQty?: number;
  orderQtyUnit?: string;
  primarySupplierLink?: string;
  imageUrl?: string;
  sku?: string;
  color?: string;
}

export interface ItemInputMetadata {
  tenantId: string;
}

export interface ItemCreateRequest {
  payload: ItemInput;
  metadata: ItemInputMetadata;
  effectiveAt: number;
  author: string;
}

export interface KanbanCardInput {
  item: {
    itemId: string;
    itemName: string;
  };
  quantity: {
    value: number;
    unit: string;
  };
  locator?: {
    facility: string;
    location?: string;
  };
  seedStatus?: 'AVAILABLE' | 'REQUESTED' | 'IN_PROCESS' | 'READY' | 'FULFILLING' | 'FULFILLED' | 'IN_USE' | 'DEPLETED' | 'REQUESTING' | 'UNKNOWN';
  notes?: string;
}

export interface OrderHeaderInput {
  orderDate: { utcTimestamp: number };
  allowPartial: boolean;
  expedite: boolean;
  deliverBy?: { utcTimestamp: number };
  supplierName?: string;
  notes?: string;
  taxesAndFees: Record<string, { value: number; currency: string }>;
}

export interface EntityRecord {
  rId: string;
  asOf: { effective: number; recorded: number };
  payload: unknown;
  metadata: unknown;
  previous?: string;
  retired: boolean;
}

export interface ArdaActor {
  author: string;
  email?: string;
  tenantId?: string;
}

interface ProvisionAttemptError {
  endpoint: string;
  status: number;
  message: string;
}

// PageResult interface available for paginated API calls
// interface PageResult {
//   thisPage: string;
//   nextPage: string;
//   results: UserAccountRecord[];
//   totalCount?: number;
// }

interface ArdaError {
  responseMessage: string;
  code: number;
  details?: unknown;
}

// Helper to make Arda API calls
async function ardaFetch<T>(
  endpoint: string,
  options: {
    method: 'GET' | 'POST' | 'PUT' | 'DELETE';
    body?: unknown;
    author: string;
    effectiveAsOf?: number;
    tenantId?: string;
  }
): Promise<T> {
  if (!ARDA_API_KEY) {
    throw new Error('ARDA_API_KEY environment variable not set');
  }

  const effectiveAsOf = options.effectiveAsOf || Date.now();
  const url = `${ARDA_BASE_URL}${endpoint}?effectiveasof=${effectiveAsOf}`;

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${ARDA_API_KEY}`,
    'X-Author': options.author,
    'X-Request-ID': uuidv4(),
  };

  // Add tenant header if provided (required for some endpoints)
  if (options.tenantId) {
    headers['X-Tenant-Id'] = options.tenantId;
  }

  const response = await fetch(url, {
    method: options.method,
    headers,
    body: options.body ? JSON.stringify(options.body) : undefined,
  });

  if (!response.ok) {
    let errorData: ArdaError;
    try {
      errorData = await response.json() as ArdaError;
    } catch {
      errorData = {
        responseMessage: `HTTP ${response.status}`,
        code: response.status,
      };
    }
    throw new Error(`Arda API Error: ${errorData.responseMessage} (${errorData.code})`);
  }

  const data = await response.json() as T;
  return data;
}

function findFirstMatchingString(
  source: unknown,
  keys: Set<string>
): string | null {
  if (!source || typeof source !== 'object') return null;

  const queue: unknown[] = [source];
  while (queue.length > 0) {
    const current = queue.shift();
    if (!current || typeof current !== 'object') continue;

    for (const [key, value] of Object.entries(current as Record<string, unknown>)) {
      const normalizedKey = key.toLowerCase();
      if (typeof value === 'string' && keys.has(normalizedKey) && value.trim()) {
        return value.trim();
      }
      if (value && typeof value === 'object') {
        queue.push(value);
      }
    }
  }

  return null;
}

function getProvisionEndpoints(): string[] {
  const configured = process.env.ARDA_USER_PROVISION_ENDPOINTS;
  if (configured) {
    return configured
      .split(',')
      .map((part) => part.trim())
      .filter(Boolean);
  }

  return [
    '/v1/account/user-account',
    '/v1/account/account-user',
    '/v1/user/user-account',
  ];
}

function getProvisionPayloads(email: string): Array<Record<string, unknown>> {
  const displayName = email.split('@')[0] || 'OrderPulse User';

  return [
    {
      email,
      name: displayName,
    },
    {
      payload: {
        email,
        name: displayName,
      },
    },
    {
      user: {
        email,
        name: displayName,
      },
    },
  ];
}

// Attempt to create an Arda account for the given email and return resolved actor credentials.
export async function provisionUserForEmail(email: string): Promise<ArdaActor | null> {
  if (!ARDA_API_KEY) {
    console.warn('⚠️ Skipping auto-provision: ARDA_API_KEY is not configured');
    return null;
  }

  const endpoints = getProvisionEndpoints();
  const payloads = getProvisionPayloads(email);
  const attemptErrors: ProvisionAttemptError[] = [];
  const systemAuthor = process.env.ARDA_SYSTEM_AUTHOR || 'orderpulse-system';

  for (const endpoint of endpoints) {
    const url = `${ARDA_BASE_URL}${endpoint}`;

    for (const payload of payloads) {
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${ARDA_API_KEY}`,
            'X-Author': systemAuthor,
            'X-Request-ID': uuidv4(),
          },
          body: JSON.stringify(payload),
        });

        // Treat 409 as success when account already exists.
        if (!response.ok && response.status !== 409) {
          let message = `HTTP ${response.status}`;
          try {
            const parsed = await response.json() as { message?: string; responseMessage?: string };
            message = parsed.responseMessage || parsed.message || message;
          } catch {
            // keep fallback
          }
          attemptErrors.push({ endpoint, status: response.status, message });
          continue;
        }

        let data: unknown = null;
        try {
          data = await response.json();
        } catch {
          data = null;
        }

        const tenantId = findFirstMatchingString(
          data,
          new Set(['tenantid', 'tenant_id', 'tenantguid', 'tenant_guid'])
        );
        const author = findFirstMatchingString(
          data,
          new Set(['author', 'sub', 'usersub', 'user_sub', 'cognitosub', 'cognito_sub'])
        );

        if (tenantId) {
          return {
            author: author || email,
            email,
            tenantId,
          };
        }

        // Successful response but no tenant details - continue trying other formats/endpoints.
      } catch (error) {
        attemptErrors.push({
          endpoint,
          status: 0,
          message: error instanceof Error ? error.message : String(error),
        });
      }
    }
  }

  if (attemptErrors.length > 0) {
    const sample = attemptErrors
      .slice(0, 3)
      .map((entry) => `${entry.endpoint} (${entry.status}): ${entry.message}`)
      .join('; ');
    console.warn(`⚠️ Auto-provision failed for ${email}. Attempts: ${sample}`);
  }

  return null;
}

// Look up tenant ID from user email via Cognito user cache
// Now uses the local Cognito users file synced from GitHub workflow
import { cognitoService } from './cognito.js';

export async function getTenantByEmail(email: string): Promise<string | null> {
  const user = cognitoService.getUserByEmail(email);
  if (user?.tenantId) {
    console.log(`🔑 Found tenant ID for ${email}: ${user.tenantId}`);
    return user.tenantId;
  }
  console.log(`⚠️ No tenant found for ${email} in Cognito cache`);
  return null;
}

// Resolve tenant using actor context:
// 1) explicit actor tenant, 2) email->Cognito mapping.
async function resolveTenantId(actor: ArdaActor): Promise<string> {
  if (actor.tenantId) {
    return actor.tenantId;
  }

  if (actor.email) {
    const cognitoTenant = await getTenantByEmail(actor.email);
    if (cognitoTenant) {
      return cognitoTenant;
    }

    throw new Error(
      `No tenant mapping found for authenticated email ${actor.email}. ` +
      'Ensure this Google account is present in Cognito sync data.'
    );
  }

  throw new Error(
    'Unable to resolve tenant ID: authenticated email mapping or explicit actor tenantId is required.'
  );
}

// Check if mock mode is enabled
export function isMockMode(): boolean {
  return process.env.ARDA_MOCK_MODE === 'true' || !ARDA_API_KEY;
}

// Map color string to Arda ItemColor enum
function mapToArdaColor(color?: string): ItemColor | undefined {
  if (!color) return undefined;
  const colorMap: Record<string, ItemColor> = {
    'blue': 'BLUE',
    'green': 'GREEN',
    'yellow': 'YELLOW',
    'orange': 'ORANGE',
    'red': 'RED',
    'pink': 'PINK',
    'purple': 'PURPLE',
    'gray': 'GRAY',
    'grey': 'GRAY',
  };
  return colorMap[color.toLowerCase()] || undefined;
}

// Map order mechanism to Arda OrderMethod enum
function mapToArdaOrderMethod(mechanism?: string): ItemSupplyValue['orderMethod'] {
  if (!mechanism) return 'EMAIL';
  const normalized = mechanism.trim().toLowerCase();
  if (normalized === 'phone' || normalized === 'call') {
    return 'PHONE';
  }
  if (['web', 'url', 'website', 'online', 'shopping'].includes(normalized)) {
    return 'ONLINE';
  }
  return 'EMAIL';
}

function normalizeUnit(unit?: string): string {
  const raw = unit?.trim();
  if (!raw) return 'EA';
  const normalized = raw.toLowerCase();
  if (['each', 'ea', 'unit', 'units', 'piece', 'pieces', 'pcs'].includes(normalized)) {
    return 'EA';
  }
  return raw.toUpperCase();
}

// Create an item in Arda's Item Data Authority
// Maps our simplified ItemInput to Arda's Item.Entity schema
export async function createItem(
  item: ItemInput,
  actor: ArdaActor
): Promise<EntityRecord> {
  const tenantId = await resolveTenantId(actor);

  // Build Arda Item.Entity structure
  const ardaItem: ArdaItemEntity = {
    eId: uuidv4(),
    name: item.name,
    description: item.description || undefined,
    imageUrl: item.imageUrl || undefined,
    internalSKU: item.sku || undefined,
    itemColor: mapToArdaColor(item.color),
  };

  // Add minQuantity if provided
  if (item.minQty) {
    ardaItem.minQuantity = {
      amount: item.minQty,
      unit: normalizeUnit(item.minQtyUnit),
    };
  }

  // Add locator if location provided
  if (item.location) {
    ardaItem.locator = {
      facility: 'Main', // Default facility
      location: item.location,
    };
  }

  // Add primarySupply
  ardaItem.primarySupply = {
    supplier: item.primarySupplier,
    orderMethod: mapToArdaOrderMethod(item.orderMechanism),
    url: item.primarySupplierLink || undefined,
  };

  // Add orderQuantity to supply if provided
  if (item.orderQty) {
    ardaItem.primarySupply.orderQuantity = {
      amount: item.orderQty,
      unit: normalizeUnit(item.orderQtyUnit || item.minQtyUnit),
    };
  }

  console.log('📤 Creating Arda item:', JSON.stringify(ardaItem, null, 2));

  return ardaFetch<EntityRecord>('/v1/item/item', {
    method: 'POST',
    body: ardaItem,
    author: actor.author,
    tenantId,
  });
}

// Create a Kanban card in Arda
export async function createKanbanCard(
  card: KanbanCardInput,
  actor: ArdaActor
): Promise<EntityRecord> {
  const tenantId = await resolveTenantId(actor);

  return ardaFetch<EntityRecord>('/v1/kanban/kanban-card', {
    method: 'POST',
    body: card,
    author: actor.author,
    tenantId,
  });
}

// Create an order in Arda
export async function createOrder(
  order: OrderHeaderInput,
  actor: ArdaActor
): Promise<EntityRecord> {
  const tenantId = await resolveTenantId(actor);

  return ardaFetch<EntityRecord>('/v1/order/order', {
    method: 'POST',
    body: order,
    author: actor.author,
    tenantId,
  });
}

// Velocity profile input for creating items from velocity data
export interface ItemVelocityProfileInput {
  displayName: string;
  supplier: string;
  dailyBurnRate: number;
  averageCadenceDays: number;
  recommendedMin: number;
  recommendedOrderQty: number;
  unit?: string; // Defaults to 'EA' if not provided
  location?: string;
  primarySupplierLink?: string;
  imageUrl?: string;
}

// Result type for sync operations
export interface VelocitySyncResult {
  displayName: string;
  success: boolean;
  itemId?: string;
  error?: string;
}

// Create an item in Arda from velocity profile data
// Calculates kanban parameters and sets order mechanism based on velocity
export async function createItemFromVelocity(
  profile: ItemVelocityProfileInput,
  actor: ArdaActor
): Promise<EntityRecord> {
  // Calculate kanban parameters
  const minQty = profile.recommendedMin;
  const orderQty = profile.recommendedOrderQty;
  const unit = profile.unit || 'EA';

  // Set order mechanism based on velocity: AUTO for high velocity (>5/day), MANUAL otherwise
  const orderMechanism = profile.dailyBurnRate > 5 ? 'AUTO' : 'MANUAL';

  // Create item using existing createItem function
  return createItem(
    {
      name: profile.displayName,
      orderMechanism,
      location: profile.location,
      minQty,
      minQtyUnit: unit,
      orderQty,
      orderQtyUnit: unit,
      primarySupplier: profile.supplier,
      primarySupplierLink: profile.primarySupplierLink,
      imageUrl: profile.imageUrl,
    },
    actor
  );
}

// Sync multiple velocity profiles to Arda
// Creates items for each profile and returns results with success/failure status
export async function syncVelocityToArda(
  profiles: ItemVelocityProfileInput[],
  actor: ArdaActor
): Promise<VelocitySyncResult[]> {
  const results: VelocitySyncResult[] = [];

  for (const profile of profiles) {
    try {
      const result = await createItemFromVelocity(profile, actor);
      
      // Extract item ID from the result (assuming it's in the payload)
      const itemId = (result.payload as { itemId?: string })?.itemId || result.rId;

      results.push({
        displayName: profile.displayName,
        success: true,
        itemId,
      });
    } catch (error) {
      results.push({
        displayName: profile.displayName,
        success: false,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  return results;
}

export const ardaService = {
  createItem,
  createKanbanCard,
  createOrder,
  getTenantByEmail,
  provisionUserForEmail,
  isMockMode,
  createItemFromVelocity,
  syncVelocityToArda,
  isConfigured: () => Boolean(ARDA_API_KEY),
};

```

### `server/src/services/ardaSyncStatus.ts`

```typescript
import { randomUUID } from 'node:crypto';
import redisClient from '../utils/redisClient.js';

const REDIS_KEY_PREFIX = 'orderpulse:arda:sync-status:';
const REDIS_TTL_SECONDS = 60 * 60 * 24 * 14; // 14 days
const RECENT_EVENT_LIMIT = 25;

export type ArdaSyncOperation =
  | 'item_create'
  | 'item_bulk_create'
  | 'kanban_card_create'
  | 'order_create'
  | 'velocity_sync'
  | 'velocity_push'
  | 'velocity_item_sync';

export interface ArdaSyncEvent {
  id: string;
  operation: ArdaSyncOperation;
  success: boolean;
  requested: number;
  successful: number;
  failed: number;
  timestamp: string;
  error?: string;
  email?: string;
  tenantId?: string;
}

export interface ArdaSyncStatusSnapshot {
  totalAttempts: number;
  successfulAttempts: number;
  failedAttempts: number;
  totalRequested: number;
  totalSuccessful: number;
  totalFailed: number;
  lastAttemptAt: string | null;
  lastSuccessAt: string | null;
  lastErrorAt: string | null;
  recent: ArdaSyncEvent[];
  updatedAt: string;
}

interface RecordSyncEventInput {
  operation: ArdaSyncOperation;
  success: boolean;
  requested?: number;
  successful?: number;
  failed?: number;
  error?: string;
  email?: string;
  tenantId?: string | null;
}

const statusCache = new Map<string, ArdaSyncStatusSnapshot>();

function nowIso(): string {
  return new Date().toISOString();
}

function createEmptyStatus(): ArdaSyncStatusSnapshot {
  return {
    totalAttempts: 0,
    successfulAttempts: 0,
    failedAttempts: 0,
    totalRequested: 0,
    totalSuccessful: 0,
    totalFailed: 0,
    lastAttemptAt: null,
    lastSuccessAt: null,
    lastErrorAt: null,
    recent: [],
    updatedAt: nowIso(),
  };
}

function normalizeUserKey(userKey: string): string {
  const trimmed = userKey.trim().toLowerCase();
  return trimmed || 'anonymous';
}

function redisKeyForUser(userKey: string): string {
  return `${REDIS_KEY_PREFIX}${encodeURIComponent(normalizeUserKey(userKey))}`;
}

function safeParseStatus(payload: string | null): ArdaSyncStatusSnapshot {
  if (!payload) {
    return createEmptyStatus();
  }

  try {
    const parsed = JSON.parse(payload) as Partial<ArdaSyncStatusSnapshot>;
    const recent = Array.isArray(parsed.recent)
      ? parsed.recent
        .filter((value): value is ArdaSyncEvent => Boolean(value && typeof value === 'object'))
        .slice(0, RECENT_EVENT_LIMIT)
      : [];

    return {
      totalAttempts: Number(parsed.totalAttempts) || 0,
      successfulAttempts: Number(parsed.successfulAttempts) || 0,
      failedAttempts: Number(parsed.failedAttempts) || 0,
      totalRequested: Number(parsed.totalRequested) || 0,
      totalSuccessful: Number(parsed.totalSuccessful) || 0,
      totalFailed: Number(parsed.totalFailed) || 0,
      lastAttemptAt: parsed.lastAttemptAt || null,
      lastSuccessAt: parsed.lastSuccessAt || null,
      lastErrorAt: parsed.lastErrorAt || null,
      recent,
      updatedAt: parsed.updatedAt || nowIso(),
    };
  } catch {
    return createEmptyStatus();
  }
}

async function loadStatus(userKey: string): Promise<ArdaSyncStatusSnapshot> {
  const normalized = normalizeUserKey(userKey);
  const cached = statusCache.get(normalized);
  if (cached) {
    return cached;
  }

  if (!redisClient) {
    const empty = createEmptyStatus();
    statusCache.set(normalized, empty);
    return empty;
  }

  try {
    const redisPayload = await redisClient.get(redisKeyForUser(normalized));
    const parsed = safeParseStatus(redisPayload);
    statusCache.set(normalized, parsed);
    return parsed;
  } catch (error) {
    console.warn('⚠️ Failed to load Arda sync status from Redis:', error);
    const empty = createEmptyStatus();
    statusCache.set(normalized, empty);
    return empty;
  }
}

async function persistStatus(userKey: string, status: ArdaSyncStatusSnapshot): Promise<void> {
  const normalized = normalizeUserKey(userKey);
  statusCache.set(normalized, status);

  if (!redisClient) {
    return;
  }

  try {
    await redisClient.setex(
      redisKeyForUser(normalized),
      REDIS_TTL_SECONDS,
      JSON.stringify(status)
    );
  } catch (error) {
    console.warn('⚠️ Failed to persist Arda sync status to Redis:', error);
  }
}

function normalizeCount(value: number | undefined, fallback: number): number {
  if (typeof value !== 'number' || !Number.isFinite(value)) {
    return fallback;
  }
  return Math.max(0, Math.floor(value));
}

function buildSyncEvent(input: RecordSyncEventInput): ArdaSyncEvent {
  const requested = normalizeCount(input.requested, 1);
  const successful = normalizeCount(input.successful, input.success ? requested : 0);
  const failed = normalizeCount(input.failed, Math.max(requested - successful, input.success ? 0 : 1));

  return {
    id: randomUUID(),
    operation: input.operation,
    success: input.success,
    requested,
    successful,
    failed,
    timestamp: nowIso(),
    ...(input.error ? { error: input.error } : {}),
    ...(input.email ? { email: input.email } : {}),
    ...(input.tenantId ? { tenantId: input.tenantId } : {}),
  };
}

export async function recordArdaSyncEvent(
  userKey: string,
  input: RecordSyncEventInput
): Promise<ArdaSyncStatusSnapshot> {
  const status = await loadStatus(userKey);
  const event = buildSyncEvent(input);

  status.totalAttempts += 1;
  status.totalRequested += event.requested;
  status.totalSuccessful += event.successful;
  status.totalFailed += event.failed;
  status.lastAttemptAt = event.timestamp;
  status.updatedAt = event.timestamp;

  if (event.success) {
    status.successfulAttempts += 1;
    status.lastSuccessAt = event.timestamp;
  } else {
    status.failedAttempts += 1;
    status.lastErrorAt = event.timestamp;
  }

  status.recent.unshift(event);
  status.recent = status.recent.slice(0, RECENT_EVENT_LIMIT);

  await persistStatus(userKey, status);
  return status;
}

export async function getArdaSyncStatus(userKey: string): Promise<ArdaSyncStatusSnapshot> {
  return loadStatus(userKey);
}


```

### `server/src/services/barcodeLookup.ts`

```typescript
import redisClient from '../utils/redisClient.js';
import { appLogger } from '../middleware/requestLogger.js';

// Cache TTLs (match previous route behavior)
const CACHE_FOUND_TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days
const CACHE_NOT_FOUND_TTL_SECONDS = 60 * 60; // 1 hour

export type BarcodeLookupSource = 'barcodelookup' | 'openfoodfacts' | 'upcitemdb';

export interface BarcodeProductInfo {
  name: string;
  brand?: string;
  imageUrl?: string;
  category?: string;
  // Optional metadata (safe for frontend to ignore)
  source?: BarcodeLookupSource;
  normalizedBarcode?: string;
}

type CachePayload = BarcodeProductInfo | { notFound: true };

type LookupResult =
  | { status: 'found'; product: BarcodeProductInfo }
  | { status: 'not_found' }
  | { status: 'error' };

export interface BarcodeLookupOptions {
  timeoutMs?: number;
}

function deadlineFromNow(timeoutMs: number): number {
  const safe = Number.isFinite(timeoutMs) ? Math.max(0, Number(timeoutMs)) : 0;
  return Date.now() + safe;
}

function msUntil(deadlineMs: number): number {
  return Math.max(0, deadlineMs - Date.now());
}

async function promiseWithTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
  if (!Number.isFinite(timeoutMs) || timeoutMs <= 0) {
    throw new Error('Timeout');
  }

  let timeoutId: ReturnType<typeof setTimeout> | undefined;
  try {
    return await Promise.race([
      promise,
      new Promise<T>((_, reject) => {
        timeoutId = setTimeout(() => reject(new Error('Timeout')), timeoutMs);
      }),
    ]);
  } finally {
    if (timeoutId) clearTimeout(timeoutId);
  }
}

async function fetchWithTimeout(url: string, init: RequestInit, timeoutMs: number): Promise<Response> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  try {
    return await fetch(url, { ...init, signal: controller.signal });
  } finally {
    clearTimeout(timeoutId);
  }
}

function isAllDigits(s: string): boolean {
  return /^[0-9]+$/.test(s);
}

function computeGtinCheckDigit(dataWithoutCheckDigit: string): number {
  // GS1 Mod10 algorithm used by GTIN-8/12/13/14.
  let sum = 0;
  let weight = 3;
  for (let i = dataWithoutCheckDigit.length - 1; i >= 0; i--) {
    const digit = Number(dataWithoutCheckDigit[i]);
    sum += digit * weight;
    weight = weight === 3 ? 1 : 3;
  }
  return (10 - (sum % 10)) % 10;
}

function isValidGtin(gtin: string): boolean {
  if (!isAllDigits(gtin)) return false;
  if (![8, 12, 13, 14].includes(gtin.length)) return false;
  const expected = computeGtinCheckDigit(gtin.slice(0, -1));
  return expected === Number(gtin[gtin.length - 1]);
}

function expandUpcEToUpcA(upcE: string): string | null {
  // UPC-E is 8 digits: number system (0/1), 6-digit UPC-E payload, check digit.
  if (!isAllDigits(upcE) || upcE.length !== 8) return null;
  const numberSystem = upcE[0];
  if (numberSystem !== '0' && numberSystem !== '1') return null;

  const x1 = upcE[1];
  const x2 = upcE[2];
  const x3 = upcE[3];
  const x4 = upcE[4];
  const x5 = upcE[5];
  const x6 = upcE[6];
  const check = upcE[7];

  let upcA = '';
  if (x6 === '0' || x6 === '1' || x6 === '2') {
    // N X1 X2 X6 0000 X3 X4 X5 C
    upcA = `${numberSystem}${x1}${x2}${x6}0000${x3}${x4}${x5}${check}`;
  } else if (x6 === '3') {
    // N X1 X2 X3 00000 X4 X5 C
    upcA = `${numberSystem}${x1}${x2}${x3}00000${x4}${x5}${check}`;
  } else if (x6 === '4') {
    // N X1 X2 X3 X4 00000 X5 C
    upcA = `${numberSystem}${x1}${x2}${x3}${x4}00000${x5}${check}`;
  } else {
    // N X1 X2 X3 X4 X5 0000 X6 C
    upcA = `${numberSystem}${x1}${x2}${x3}${x4}${x5}0000${x6}${check}`;
  }

  // Validate check digit after expansion; if it fails, still return it (some scanners misreport)
  return upcA.length === 12 ? upcA : null;
}

function normalizeBarcodeForLookup(raw: string): string {
  const trimmed = raw.trim();
  // Some scanners can prefix an AIM symbology identifier like "]C1"
  if (trimmed.startsWith(']') && trimmed.length > 3) {
    return trimmed.slice(3).trim();
  }
  return trimmed;
}

function uniqueKeepOrder(values: string[]): string[] {
  const seen = new Set<string>();
  const out: string[] = [];
  for (const v of values) {
    if (!v) continue;
    if (seen.has(v)) continue;
    seen.add(v);
    out.push(v);
  }
  return out;
}

function getGtinCandidates(rawBarcode: string): string[] {
  const normalized = normalizeBarcodeForLookup(rawBarcode);
  const digits = normalized.replace(/\D/g, '');
  if (!digits) return [];

  const candidates: string[] = [];

  // Start with the raw digits if it looks like a GTIN length.
  if ([8, 12, 13, 14].includes(digits.length)) {
    candidates.push(digits);
  }

  // Common normalization: UPC-A (12) is often represented as EAN-13 with a leading 0.
  if (digits.length === 13 && digits.startsWith('0')) {
    candidates.unshift(digits.slice(1)); // Prefer UPC-A form first for broader lookup coverage
  } else if (digits.length === 12) {
    candidates.push(`0${digits}`);
  }

  // GTIN-14 often includes leading zeros; try trimming to GTIN-13/12 forms.
  if (digits.length === 14 && digits.startsWith('0')) {
    const gtin13 = digits.slice(1);
    candidates.push(gtin13);
    if (gtin13.startsWith('0')) {
      candidates.push(gtin13.slice(1));
    }
  }

  // UPC-E can appear as 8 digits; expand to UPC-A.
  if (digits.length === 8) {
    const upcA = expandUpcEToUpcA(digits);
    if (upcA) {
      candidates.push(upcA);
      candidates.push(`0${upcA}`); // EAN-13 representation
    }
  }

  // Prefer candidates with valid check digits first.
  const uniq = uniqueKeepOrder(candidates);
  const validFirst = uniq.sort((a, b) => Number(isValidGtin(b)) - Number(isValidGtin(a)));
  return validFirst;
}

async function getCached(code: string, maxWaitMs?: number): Promise<CachePayload | null> {
  if (!redisClient) return null;
  if (Number.isFinite(maxWaitMs) && Number(maxWaitMs) <= 0) return null;
  try {
    const getPromise = redisClient.get(`barcode:lookup:${code}`) as Promise<string | null>;
    const cached = Number.isFinite(maxWaitMs)
      ? await promiseWithTimeout(getPromise, Number(maxWaitMs))
      : await getPromise;
    if (!cached) return null;
    return JSON.parse(cached) as CachePayload;
  } catch (err) {
    appLogger.warn({ err }, 'Barcode lookup cache read failed');
    return null;
  }
}

async function setCached(code: string, payload: CachePayload, ttlSeconds: number, maxWaitMs?: number): Promise<void> {
  if (!redisClient) return;
  if (Number.isFinite(maxWaitMs) && Number(maxWaitMs) <= 0) return;
  try {
    const setPromise = redisClient.setex(
      `barcode:lookup:${code}`,
      ttlSeconds,
      JSON.stringify(payload)
    ) as Promise<unknown>;
    if (Number.isFinite(maxWaitMs)) {
      await promiseWithTimeout(setPromise, Number(maxWaitMs));
    } else {
      await setPromise;
    }
  } catch (err) {
    appLogger.warn({ err }, 'Barcode lookup cache write failed');
  }
}

async function lookupFromBarcodeLookup(code: string, timeoutMs: number): Promise<LookupResult> {
  const apiKey = process.env.BARCODE_LOOKUP_API_KEY;
  if (!apiKey) return { status: 'not_found' }; // Provider disabled

  const url = `https://api.barcodelookup.com/v3/products?barcode=${encodeURIComponent(code)}&key=${encodeURIComponent(apiKey)}`;

  try {
    const response = await fetchWithTimeout(url, {
      headers: {
        Accept: 'application/json',
      },
    }, timeoutMs);

    if (!response.ok) {
      // 404 and 400 mean "not found / invalid" for our purposes.
      if (response.status === 404 || response.status === 400) return { status: 'not_found' };
      appLogger.warn({ status: response.status }, 'BarcodeLookup API non-OK response');
      return { status: 'error' };
    }

    const data = await response.json() as {
      products?: Array<{
        title?: string;
        brand?: string;
        category?: string;
        images?: string[];
      }>;
    };

    const first = data.products?.[0];
    const name = first?.title?.trim();
    if (!name) return { status: 'not_found' };

    return {
      status: 'found',
      product: {
        name,
        brand: first?.brand?.trim() || undefined,
        category: first?.category?.trim() || undefined,
        imageUrl: first?.images?.[0],
        source: 'barcodelookup',
        normalizedBarcode: code,
      },
    };
  } catch (err) {
    appLogger.warn({ err }, 'BarcodeLookup API request failed');
    return { status: 'error' };
  }
}

async function lookupFromOpenFoodFacts(code: string, timeoutMs: number): Promise<LookupResult> {
  // Open Food Facts is free and requires no API key.
  const url = `https://world.openfoodfacts.org/api/v0/product/${encodeURIComponent(code)}.json`;
  const userAgent = process.env.BARCODE_LOOKUP_USER_AGENT || 'OrderPulse/1.0 (barcode lookup)';

  try {
    const response = await fetchWithTimeout(url, {
      headers: {
        Accept: 'application/json',
        'User-Agent': userAgent,
      },
    }, timeoutMs);

    if (!response.ok) {
      if (response.status === 404) return { status: 'not_found' };
      return { status: 'error' };
    }

    const data = await response.json() as {
      status?: number;
      product?: {
        product_name?: string;
        product_name_en?: string;
        brands?: string;
        image_url?: string;
        image_front_url?: string;
        categories?: string;
      };
    };

    if (data.status !== 1 || !data.product) return { status: 'not_found' };

    const product = data.product;
    const name = (product.product_name || product.product_name_en || '').trim();
    if (!name) return { status: 'not_found' };

    return {
      status: 'found',
      product: {
        name,
        brand: product.brands?.trim() || undefined,
        imageUrl: product.image_url || product.image_front_url,
        category: product.categories?.split(',')[0]?.trim() || undefined,
        source: 'openfoodfacts',
        normalizedBarcode: code,
      },
    };
  } catch (err) {
    appLogger.warn({ err }, 'Open Food Facts request failed');
    return { status: 'error' };
  }
}

async function lookupFromUpcItemDb(code: string, timeoutMs: number): Promise<LookupResult> {
  const userKey = process.env.UPCITEMDB_USER_KEY;
  const keyType = process.env.UPCITEMDB_KEY_TYPE || '3scale';
  const path = userKey ? 'v1' : 'trial';

  const url = `https://api.upcitemdb.com/prod/${path}/lookup?upc=${encodeURIComponent(code)}`;

  const headers: Record<string, string> = {
    Accept: 'application/json',
  };
  if (userKey) {
    // Preserve underscore header names exactly (Node fetch will keep them as-is)
    headers['user_key'] = userKey;
    headers['key_type'] = keyType;
  }

  try {
    const response = await fetchWithTimeout(url, {
      headers,
    }, timeoutMs);

    if (!response.ok) {
      if (response.status === 404 || response.status === 400) return { status: 'not_found' };
      if (response.status === 429) {
        appLogger.warn({ status: 429 }, 'UPCitemdb rate limited');
      }
      return { status: 'error' };
    }

    const data = await response.json() as {
      items?: Array<{
        title?: string;
        brand?: string;
        images?: string[];
        category?: string;
      }>;
      code?: string;
      message?: string;
    };

    if (!data.items || data.items.length === 0) return { status: 'not_found' };
    const item = data.items[0];
    const name = item.title?.trim();
    if (!name) return { status: 'not_found' };

    return {
      status: 'found',
      product: {
        name,
        brand: item.brand?.trim() || undefined,
        imageUrl: item.images?.[0],
        category: item.category?.trim() || undefined,
        source: 'upcitemdb',
        normalizedBarcode: code,
      },
    };
  } catch (err) {
    appLogger.warn({ err }, 'UPCitemdb request failed');
    return { status: 'error' };
  }
}

async function lookupAcrossProviders(code: string, deadlineMs: number): Promise<{ product: BarcodeProductInfo | null; hadError: boolean }> {
  let hadError = false;

  // Provider order: use the most general catalog first (when configured), then free sources.
  const providers = [
    lookupFromBarcodeLookup,
    lookupFromOpenFoodFacts,
    lookupFromUpcItemDb,
  ];

  for (const provider of providers) {
    const remainingMs = msUntil(deadlineMs);
    if (remainingMs <= 0) {
      // Treat deadline exhaustion as an error to avoid caching "not found".
      return { product: null, hadError: true };
    }

    const result = await provider(code, remainingMs);
    if (result.status === 'found') return { product: result.product, hadError };
    if (result.status === 'error') hadError = true;
  }

  return { product: null, hadError };
}

/**
 * Look up a barcode and return a real product when possible.
 *
 * - Normalizes UPC/EAN/GTIN variants (UPC-A vs EAN-13 leading zero, UPC-E expansion)
 * - Uses Redis caching when available
 * - Tries multiple providers for better coverage
 */
export async function lookupProductByBarcode(rawBarcode: string, options: BarcodeLookupOptions = {}): Promise<BarcodeProductInfo | null> {
  const timeoutMs = Number.isFinite(options.timeoutMs) ? Number(options.timeoutMs) : 5000;
  const deadlineMs = deadlineFromNow(timeoutMs);
  const candidates = getGtinCandidates(rawBarcode);
  if (candidates.length === 0) return null;

  // Cache read across all candidate representations.
  for (const code of candidates) {
    const remainingMs = msUntil(deadlineMs);
    if (remainingMs <= 0) return null;

    const cached = await getCached(code, remainingMs);
    if (!cached) continue;
    if ('notFound' in cached) continue;
    if (cached.name) return cached;
  }

  for (const code of candidates) {
    const remainingMs = msUntil(deadlineMs);
    if (remainingMs <= 0) return null;

    const { product, hadError } = await lookupAcrossProviders(code, deadlineMs);
    if (product?.name) {
      await setCached(code, product, CACHE_FOUND_TTL_SECONDS, msUntil(deadlineMs));
      return product;
    }

    // Only cache "not found" when providers did not error (avoid locking in transient failures).
    if (!hadError) {
      await setCached(code, { notFound: true }, CACHE_NOT_FOUND_TTL_SECONDS, msUntil(deadlineMs));
    }
  }

  return null;
}

```

### `server/src/services/cognito.ts`

```typescript
// Cognito User Sync Service
// Syncs user data for email→tenant/author lookups.

import { readFileSync, existsSync, mkdirSync, writeFileSync } from 'fs';
import path from 'path';
import {
  CognitoIdentityProviderClient,
  AdminCreateUserCommand,
  AdminUpdateUserAttributesCommand,
  ListUsersCommand,
  type UserType,
} from '@aws-sdk/client-cognito-identity-provider';
import redisClient from '../utils/redisClient.js';

const GITHUB_TOKEN = process.env.GITHUB_COGNITO_TOKEN;
const REPO_OWNER = 'Arda-cards';
const REPO_NAME = 'management';
const WORKFLOW_FILE = 'cognito.yml';
const DEFAULT_AWS_REGION = process.env.COGNITO_AWS_REGION || process.env.AWS_REGION;
const DEFAULT_USER_POOL_ID = process.env.COGNITO_USER_POOL_ID;
const DEFAULT_SYNC_SOURCE = (process.env.COGNITO_SYNC_SOURCE || 'aws').toLowerCase();
const DATA_DIR = path.join(process.cwd(), 'data');
const USERS_FILE = path.join(DATA_DIR, 'cognito_users.csv');
const COGNITO_LOCK_KEY = 'orderpulse:cognito:lock';
const COGNITO_LOCK_TTL = 1000 * 60 * 60 * 3; // 3 hours

export interface CognitoUser {
  email: string;
  tenantId: string;
  name: string;
  status: string;
  enabled: boolean;
  createdAt: string;
  modifiedAt: string;
  sub: string; // Author ID for Arda API calls
  role: string;
}

export interface TenantDomainSuggestion {
  tenantId: string;
  matchedEmail: string;
  domain: string;
  matchCount: number;
}

// In-memory cache of users
const usersCache: Map<string, CognitoUser> = new Map();
let lastLoadTime: Date | null = null;
let onDemandSyncPromise: Promise<boolean> | null = null;

const PUBLIC_EMAIL_DOMAINS = new Set([
  'gmail.com',
  'googlemail.com',
  'outlook.com',
  'hotmail.com',
  'live.com',
  'msn.com',
  'icloud.com',
  'me.com',
  'mac.com',
  'yahoo.com',
  'ymail.com',
  'rocketmail.com',
  'aol.com',
  'protonmail.com',
  'pm.me',
  'zoho.com',
  'mail.com',
  'gmx.com',
  'gmx.us',
  'qq.com',
  '163.com',
  '126.com',
  'sina.com',
  'comcast.net',
  'att.net',
  'verizon.net',
]);

function parseCSVLine(line: string): string[] {
  const fields: string[] = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];

    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }

    if (char === ',' && !inQuotes) {
      fields.push(current);
      current = '';
      continue;
    }

    current += char;
  }

  fields.push(current);
  return fields;
}

// Parse CSV into user objects
function parseCSV(csvContent: string): CognitoUser[] {
  const lines = csvContent.split(/\r?\n/).filter(Boolean);
  const users: CognitoUser[] = [];
  
  // Skip header line
  for (let i = 1; i < lines.length; i++) {
    const parts = parseCSVLine(lines[i] || '');
    if (parts.length >= 8) {
      users.push({
        email: parts[0]?.toLowerCase() || '',
        tenantId: parts[1] || '',
        name: parts[2] || '',
        status: parts[3] || '',
        enabled: parts[4] === 'True',
        createdAt: parts[5] || '',
        modifiedAt: parts[6] || '',
        sub: parts[7] || '',
        role: parts[8] || '',
      });
    }
  }

  return users;
}

function csvEscape(value: string): string {
  if (value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r')) {
    return `"${value.replace(/"/g, '""')}"`;
  }
  return value;
}

function writeUsersToFile(users: CognitoUser[]): void {
  mkdirSync(DATA_DIR, { recursive: true });
  const header = 'email,tenantId,name,status,enabled,createdAt,modifiedAt,sub,role';
  const rows = users.map((user) => (
    [
      user.email,
      user.tenantId,
      user.name,
      user.status,
      user.enabled ? 'True' : 'False',
      user.createdAt,
      user.modifiedAt,
      user.sub,
      user.role,
    ].map(csvEscape).join(',')
  ));
  writeFileSync(USERS_FILE, `${[header, ...rows].join('\n')}\n`, 'utf-8');
  console.log(`💾 Wrote ${users.length} Cognito users to ${USERS_FILE}`);
}

function setUsersCache(users: CognitoUser[], source: string): void {
  usersCache.clear();
  for (const user of users) {
    if (user.email) {
      usersCache.set(user.email.toLowerCase(), user);
    }
  }
  lastLoadTime = new Date();
  console.log(`📋 Loaded ${usersCache.size} Cognito users from ${source} (last update: ${lastLoadTime.toISOString()})`);
}

function getAttribute(user: UserType, name: string): string {
  return user.Attributes?.find((attribute) => attribute.Name === name)?.Value?.trim() || '';
}

function firstNonEmpty(...values: Array<string | undefined>): string {
  for (const value of values) {
    if (value && value.trim().length > 0) {
      return value.trim();
    }
  }
  return '';
}

function mapAwsUser(user: UserType): CognitoUser | null {
  const email = getAttribute(user, 'email').toLowerCase();
  if (!email) return null;

  const givenName = getAttribute(user, 'given_name');
  const familyName = getAttribute(user, 'family_name');
  const fullNameFromParts = [givenName, familyName].filter(Boolean).join(' ').trim();
  const name = firstNonEmpty(
    getAttribute(user, 'name'),
    fullNameFromParts,
    getAttribute(user, 'preferred_username'),
    user.Username || undefined,
  );

  return {
    email,
    tenantId: firstNonEmpty(
      getAttribute(user, 'custom:tenant'),
      getAttribute(user, 'custom:tenantId'),
      getAttribute(user, 'custom:tenant_id'),
      getAttribute(user, 'tenant'),
      getAttribute(user, 'tenantId'),
      getAttribute(user, 'tenant_id'),
    ),
    name,
    status: user.UserStatus || '',
    enabled: Boolean(user.Enabled),
    createdAt: user.UserCreateDate?.toISOString() || '',
    modifiedAt: user.UserLastModifiedDate?.toISOString() || '',
    sub: firstNonEmpty(getAttribute(user, 'sub'), user.Username || undefined),
    role: firstNonEmpty(getAttribute(user, 'custom:role'), getAttribute(user, 'role')),
  };
}

// Load users from file into cache
export function loadUsersFromFile(): void {
  if (!existsSync(USERS_FILE)) {
    console.log('⚠️ Cognito users file not found:', USERS_FILE);
    return;
  }
  
  try {
    const content = readFileSync(USERS_FILE, 'utf-8');
    const users = parseCSV(content);
    setUsersCache(users, 'file');
  } catch (error) {
    console.error('❌ Failed to load Cognito users:', error);
  }
}

// Look up user by email
export function getUserByEmail(email: string): CognitoUser | null {
  // Lazy load on first access
  if (usersCache.size === 0) {
    loadUsersFromFile();
  }
  
  return usersCache.get(email.toLowerCase()) || null;
}

function getDomain(email: string): string | null {
  const normalized = email.trim().toLowerCase();
  const atIndex = normalized.lastIndexOf('@');
  if (atIndex < 0 || atIndex === normalized.length - 1) return null;
  return normalized.slice(atIndex + 1);
}

export function isPublicEmailDomain(domain: string): boolean {
  return PUBLIC_EMAIL_DOMAINS.has(domain.trim().toLowerCase());
}

export function findTenantSuggestionForEmail(email: string): TenantDomainSuggestion | null {
  if (usersCache.size === 0) {
    loadUsersFromFile();
  }

  const normalizedEmail = email.trim().toLowerCase();
  const domain = getDomain(normalizedEmail);
  if (!domain || isPublicEmailDomain(domain)) {
    return null;
  }

  const grouped = new Map<string, { count: number; matchedEmail: string }>();
  for (const user of usersCache.values()) {
    if (!user.tenantId || !user.email) continue;
    if (user.email.toLowerCase() === normalizedEmail) continue;
    if (!user.email.toLowerCase().endsWith(`@${domain}`)) continue;

    const existing = grouped.get(user.tenantId);
    if (existing) {
      existing.count += 1;
    } else {
      grouped.set(user.tenantId, { count: 1, matchedEmail: user.email });
    }
  }

  let suggestion: TenantDomainSuggestion | null = null;
  for (const [tenantId, match] of grouped.entries()) {
    if (
      !suggestion ||
      match.count > suggestion.matchCount ||
      (match.count === suggestion.matchCount && tenantId < suggestion.tenantId)
    ) {
      suggestion = {
        tenantId,
        matchedEmail: match.matchedEmail,
        domain,
        matchCount: match.count,
      };
    }
  }

  return suggestion;
}

// Get tenant ID for an email
export function getTenantIdForEmail(email: string): string | null {
  const user = getUserByEmail(email);
  return user?.tenantId || null;
}

// Get author (sub) for an email
export function getAuthorForEmail(email: string): string | null {
  const user = getUserByEmail(email);
  return user?.sub || null;
}

function buildAwsClient(): { client: CognitoIdentityProviderClient; userPoolId: string } | null {
  const region = DEFAULT_AWS_REGION;
  const userPoolId = DEFAULT_USER_POOL_ID;

  if (!region || !userPoolId) {
    console.error('❌ AWS Cognito sync requires COGNITO_AWS_REGION/AWS_REGION and COGNITO_USER_POOL_ID');
    return null;
  }

  const accessKeyId = process.env.COGNITO_AWS_ACCESS_KEY_ID || process.env.AWS_ACCESS_KEY_ID;
  const secretAccessKey = process.env.COGNITO_AWS_SECRET_ACCESS_KEY || process.env.AWS_SECRET_ACCESS_KEY;
  const sessionToken = process.env.COGNITO_AWS_SESSION_TOKEN || process.env.AWS_SESSION_TOKEN;

  const client = new CognitoIdentityProviderClient({
    region,
    ...(accessKeyId && secretAccessKey ? {
      credentials: {
        accessKeyId,
        secretAccessKey,
        sessionToken,
      },
    } : {}),
  });

  return { client, userPoolId };
}

async function syncUsersFromAws(): Promise<boolean> {
  const awsClient = buildAwsClient();
  if (!awsClient) {
    return false;
  }

  const { client, userPoolId } = awsClient;
  console.log(`🔄 Starting Cognito user sync from AWS API (pool: ${userPoolId})...`);

  try {
    let paginationToken: string | undefined;
    const users: CognitoUser[] = [];

    do {
      const response = await client.send(new ListUsersCommand({
        UserPoolId: userPoolId,
        Limit: 60,
        PaginationToken: paginationToken,
      }));

      for (const awsUser of response.Users || []) {
        const mappedUser = mapAwsUser(awsUser);
        if (mappedUser) {
          users.push(mappedUser);
        }
      }

      paginationToken = response.PaginationToken;
    } while (paginationToken);

    setUsersCache(users, 'AWS Cognito API');
    writeUsersToFile(users);
    return true;
  } catch (error) {
    console.error('❌ Error syncing Cognito users from AWS API:', error);
    return false;
  }
}

export async function ensureUserMappingForEmail(
  email: string,
  tenantId: string,
  options?: { role?: string; name?: string; suppressMessage?: boolean }
): Promise<boolean> {
  const awsClient = buildAwsClient();
  if (!awsClient) {
    return false;
  }

  const normalizedEmail = email.trim().toLowerCase();
  if (!normalizedEmail) {
    throw new Error('Email is required to ensure Cognito mapping');
  }

  const { client, userPoolId } = awsClient;
  const userAttributes = [
    { Name: 'email', Value: normalizedEmail },
    { Name: 'email_verified', Value: 'true' },
    { Name: 'custom:tenant', Value: tenantId },
    { Name: 'custom:role', Value: options?.role || 'User' },
    ...(options?.name ? [{ Name: 'name', Value: options.name }] : []),
  ];

  const lookup = await client.send(new ListUsersCommand({
    UserPoolId: userPoolId,
    Filter: `email = "${normalizedEmail}"`,
    Limit: 1,
  }));

  const existing = lookup.Users?.[0];
  if (existing?.Username) {
    await client.send(new AdminUpdateUserAttributesCommand({
      UserPoolId: userPoolId,
      Username: existing.Username,
      UserAttributes: userAttributes,
    }));
    console.log(`✅ Updated Cognito mapping for ${normalizedEmail}`);
    return true;
  }

  await client.send(new AdminCreateUserCommand({
    UserPoolId: userPoolId,
    Username: normalizedEmail,
    UserAttributes: userAttributes,
    MessageAction: options?.suppressMessage === false ? undefined : 'SUPPRESS',
  }));
  console.log(`✅ Created Cognito mapping for ${normalizedEmail}`);
  return true;
}

// Trigger GitHub workflow and wait for artifact
async function triggerWorkflowAndGetArtifact(): Promise<string | null> {
  if (!GITHUB_TOKEN) {
    console.error('❌ GITHUB_COGNITO_TOKEN not configured');
    return null;
  }

  const baseUrl = 'https://api.github.com';
  const headers = {
    'Authorization': `token ${GITHUB_TOKEN}`,
    'Accept': 'application/vnd.github.v3+json',
  };

  try {
    // 1. Trigger the workflow
    console.log('🚀 Triggering Cognito workflow...');
    const dispatchResponse = await fetch(
      `${baseUrl}/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/${WORKFLOW_FILE}/dispatches`,
      {
        method: 'POST',
        headers,
        body: JSON.stringify({ ref: 'main', inputs: { purpose: 'prod' } }),
      }
    );

    if (!dispatchResponse.ok) {
      console.error('❌ Failed to trigger workflow:', dispatchResponse.status);
      return null;
    }

    // 2. Wait for workflow to complete (poll every 10s for up to 5 minutes)
    console.log('⏳ Waiting for workflow to complete...');
    let runId: number | null = null;
    let attempts = 0;
    const maxAttempts = 30;

    while (attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 10000));
      attempts++;

      const runsResponse = await fetch(
        `${baseUrl}/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?per_page=5`,
        { headers }
      );

      if (!runsResponse.ok) continue;

      const runsData = await runsResponse.json() as { workflow_runs: any[] };
      const latestRun = runsData.workflow_runs?.find(
        (run: any) => run.name === 'Cognito' && run.status === 'completed' && run.conclusion === 'success'
      );

      if (latestRun) {
        const runCreatedAt = new Date(latestRun.created_at);
        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
        
        // Only accept runs from the last 5 minutes
        if (runCreatedAt > fiveMinutesAgo) {
          runId = latestRun.id;
          console.log(`✅ Workflow completed: run ${runId}`);
          break;
        }
      }

      console.log(`   Attempt ${attempts}/${maxAttempts}...`);
    }

    if (!runId) {
      console.error('❌ Workflow did not complete in time');
      return null;
    }

    // 3. Get artifact download URL
    const artifactsResponse = await fetch(
      `${baseUrl}/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs/${runId}/artifacts`,
      { headers }
    );

    if (!artifactsResponse.ok) {
      console.error('❌ Failed to get artifacts');
      return null;
    }

    const artifactsData = await artifactsResponse.json() as { artifacts: any[] };
    const usersArtifact = artifactsData.artifacts?.find((a: any) => a.name === 'users.csv');

    if (!usersArtifact) {
      console.error('❌ users.csv artifact not found');
      return null;
    }

    // 4. Download artifact (returns a zip)
    console.log('📥 Downloading artifact...');
    const downloadResponse = await fetch(
      `${baseUrl}/repos/${REPO_OWNER}/${REPO_NAME}/actions/artifacts/${usersArtifact.id}/zip`,
      { headers, redirect: 'follow' }
    );

    if (!downloadResponse.ok) {
      console.error('❌ Failed to download artifact');
      return null;
    }

    // Note: GitHub returns a zip file - we need to handle unzipping
    // For simplicity, we'll use the existing file if this fails
    console.log('✅ Artifact downloaded successfully');
    return 'success';

  } catch (error) {
    console.error('❌ Error syncing Cognito users:', error);
    return null;
  }
}

// Legacy sync path: GitHub workflow (trigger workflow + download)
async function syncUsersFromGitHubWorkflow(): Promise<boolean> {
  console.log('🔄 Starting Cognito user sync from GitHub...');
  
  const result = await triggerWorkflowAndGetArtifact();
  
  if (result) {
    loadUsersFromFile();
    return true;
  }

  return false;
}

function getSyncSource(): 'aws' | 'github' | 'auto' {
  if (DEFAULT_SYNC_SOURCE === 'aws' || DEFAULT_SYNC_SOURCE === 'github' || DEFAULT_SYNC_SOURCE === 'auto') {
    return DEFAULT_SYNC_SOURCE;
  }

  console.warn(`⚠️ Invalid COGNITO_SYNC_SOURCE="${DEFAULT_SYNC_SOURCE}" (expected aws|github|auto). Using "aws".`);
  return 'aws';
}

// Sync users according to configured source.
export async function syncUsers(): Promise<boolean> {
  const source = getSyncSource();

  if (source === 'aws') {
    return syncUsersFromAws();
  }

  if (source === 'github') {
    return syncUsersFromGitHubWorkflow();
  }

  const awsSuccess = await syncUsersFromAws();
  if (awsSuccess) {
    return true;
  }
  console.warn('⚠️ AWS Cognito sync failed; attempting GitHub fallback because COGNITO_SYNC_SOURCE=auto');
  return syncUsersFromGitHubWorkflow();
}

// On-demand sync path for missing tenant mappings.
export async function syncUsersOnDemand(reason: string): Promise<boolean> {
  if (process.env.ENABLE_COGNITO_SYNC === 'false') {
    console.log('⚠️ Cognito sync disabled via ENABLE_COGNITO_SYNC=false');
    return false;
  }

  if (!process.env.REDIS_URL || !redisClient) {
    console.warn('⚠️ Redis unavailable; skipping on-demand Cognito sync');
    return false;
  }

  if (onDemandSyncPromise) {
    return onDemandSyncPromise;
  }

  onDemandSyncPromise = (async () => {
    let lockAcquired = false;
    try {
      const lock = await redisClient.set(
        COGNITO_LOCK_KEY,
        `ondemand:${reason}`,
        'PX',
        COGNITO_LOCK_TTL,
        'NX'
      );
      if (!lock) {
        console.log('⏳ Cognito sync already running on another instance');
        return false;
      }

      lockAcquired = true;
      console.log(`🔄 Running on-demand Cognito sync (${reason})...`);
      const success = await syncUsers();
      if (success) {
        console.log('✅ On-demand Cognito sync completed');
      } else {
        console.warn('⚠️ On-demand Cognito sync failed');
      }
      return success;
    } catch (error) {
      console.error('❌ On-demand Cognito sync failed:', error);
      return false;
    } finally {
      if (lockAcquired) {
        await redisClient.del(COGNITO_LOCK_KEY).catch((err: Error) => {
          console.error('Failed to release Cognito sync lock:', err);
        });
      }
    }
  })();

  try {
    return await onDemandSyncPromise;
  } finally {
    onDemandSyncPromise = null;
  }
}

// Backward-compatible export for callers not yet migrated.
export async function syncUsersFromGitHub(): Promise<boolean> {
  return syncUsersFromGitHubWorkflow();
}

// Get all users (for admin purposes)
export function getAllUsers(): CognitoUser[] {
  if (usersCache.size === 0) {
    loadUsersFromFile();
  }
  return Array.from(usersCache.values());
}

// Get sync status
export function getSyncStatus(): { lastSync: string | null; userCount: number } {
  return {
    lastSync: lastLoadTime?.toISOString() || null,
    userCount: usersCache.size,
  };
}

// Initialize on module load
loadUsersFromFile();

export const cognitoService = {
  getUserByEmail,
  getTenantIdForEmail,
  getAuthorForEmail,
  ensureUserMappingForEmail,
  findTenantSuggestionForEmail,
  isPublicEmailDomain,
  syncUsers,
  syncUsersOnDemand,
  syncUsersFromGitHub,
  loadUsersFromFile,
  getAllUsers,
  getSyncStatus,
};

```

### `server/src/services/cognitoScheduler.ts`

```typescript
import redisClient from '../utils/redisClient.js';
import { cognitoService } from './cognito.js';

const LOCK_KEY = 'orderpulse:cognito:lock';
const LOCK_TTL = 1000 * 60 * 60 * 3; // 3 hours
let syncTimeout: ReturnType<typeof setTimeout> | null = null;

function shouldRunCognitoSync(): boolean {
  if (process.env.ENABLE_COGNITO_SYNC === 'false') {
    console.log('⚠️ Cognito sync disabled via ENABLE_COGNITO_SYNC=false');
    return false;
  }
  if (!redisClient) {
    console.warn('⚠️ Redis unavailable; skipping scheduled Cognito sync');
    return false;
  }
  return true;
}

function getNextRunDelay(hour: number): number {
  const now = new Date();
  const next = new Date(now);
  next.setHours(hour, 0, 0, 0);
  if (next <= now) {
    next.setDate(next.getDate() + 1);
  }
  return next.getTime() - now.getTime();
}

async function runCognitoSync() {
  if (!redisClient) return;
  const lock = await redisClient.set(LOCK_KEY, 'locked', 'PX', LOCK_TTL, 'NX');
  if (!lock) {
    console.log('⏳ Cognito sync already running on another instance');
    return;
  }

  try {
    console.log('🔄 Running scheduled Cognito sync...');
    await cognitoService.syncUsersFromGitHub();
    console.log('✅ Scheduled Cognito sync completed');
  } catch (error) {
    console.error('❌ Scheduled Cognito sync failed:', error);
  } finally {
    await redisClient.del(LOCK_KEY).catch((err: Error) => {
      console.error('Failed to release Cognito sync lock:', err);
    });
  }
}

export function startCognitoSyncScheduler(): void {
  if (syncTimeout) return; // already scheduled
  if (!shouldRunCognitoSync()) return;

  const syncHour = Number(process.env.COGNITO_SYNC_HOUR ?? '2');

  const scheduleNext = () => {
    const delay = getNextRunDelay(syncHour);
    console.log(`⏰ Next Cognito sync scheduled in ${Math.round(delay / 1000 / 60)} minutes`);
    syncTimeout = setTimeout(async () => {
      await runCognitoSync();
      scheduleNext();
    }, delay);
  };

  scheduleNext();
}

export function stopCognitoSyncScheduler(): void {
  if (syncTimeout) {
    clearTimeout(syncTimeout);
    syncTimeout = null;
  }
}

```

### `server/src/services/emailExtraction.ts`

```typescript
import { GoogleGenerativeAI } from '@google/generative-ai';

export interface EmailExtractionInput {
  id: string;
  subject: string;
  sender: string;
  body: string;
  date?: string;
}

export interface ExtractedItem {
  name?: string;
  normalizedName?: string;
  quantity?: number;
  unit?: string;
  unitPrice?: number | null;
  totalPrice?: number | null;
  partNumber?: string | null;
  sku?: string | null;
  asin?: string | null;
  [key: string]: unknown;
}

export interface EmailExtractionResult {
  emailId: string;
  isOrder: boolean;
  supplier: string | null;
  orderDate: string;
  totalAmount: number;
  items: ExtractedItem[];
  confidence: number;
  [key: string]: unknown;
}

const EXTRACTION_PROMPT = `You are an order extraction AI. Extract purchase data from emails.

CRITICAL: EXTRACT ACTUAL ITEM NAMES FROM THE EMAIL BODY
DO NOT use placeholders, generic descriptions, or the email subject as item names.
Look for REAL product names, SKUs, and part numbers in the email content.

ITEM EXTRACTION RULES:
1. Find the EXACT product name/description as written in the email
2. Include part numbers/SKUs when present (e.g., "S-1234 Industrial Tape" or "McMaster #91251A540")
3. Extract ALL items - emails often contain multiple line items
4. Look for item tables, order summaries, and line-by-line breakdowns
5. If you cannot find specific item names, set items to an EMPTY array []

AMAZON-SPECIFIC RULES:
- For Amazon orders, ALWAYS extract the ASIN (10-character code starting with B0 or 10 digits)
- Find ASINs in product URLs like amazon.com/dp/B08N5WRWNW or amazon.com/gp/product/B08N5WRWNW
- Also look for ASINs in image URLs or product links
- Set the "asin" field for each Amazon item

WHERE TO FIND ITEMS:
- Order confirmation tables
- Invoice line items
- "Items in your order" sections
- Shipping manifests
- Product name + quantity + price patterns

SUPPLIER RECOGNITION (these are ALWAYS orders):
- Industrial: McMaster-Carr, Grainger, Fastenal, ULine, MSC, Global Industrial, Zoro, Motion
- Electronics: DigiKey, Mouser, Newark, Allied, AutomationDirect, Misumi, RS Components
- General: Amazon, Costco, Home Depot, Lowes
- Shipping: FedEx, UPS, DHL invoices

Return JSON:
{
  "isOrder": true,
  "supplier": "Exact Company Name",
  "orderDate": "YYYY-MM-DD",
  "totalAmount": 123.45,
  "items": [
    {"name": "ACTUAL product name from email", "quantity": 2, "unit": "ea", "unitPrice": 10.50, "partNumber": "ABC-123", "asin": null},
    {"name": "Amazon Product Name", "quantity": 1, "unit": "ea", "unitPrice": 25.00, "partNumber": null, "asin": "B08N5WRWNW"}
  ],
  "confidence": 0.9
}

ONLY set isOrder: false for pure marketing, password resets, or newsletters.
If it's an order but you can't find specific items, still mark isOrder: true with items: []

If you cannot find an order date in the email body, use the email Date header (provided below).

EMAIL:
`;

export function createGeminiExtractionModel(apiKey?: string) {
  const genAI = new GoogleGenerativeAI(apiKey || process.env.GEMINI_API_KEY || '');
  return genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
}

export function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export function parseEmailDate(dateHeader?: string): string | null {
  if (!dateHeader) return null;
  const parsed = new Date(dateHeader);
  if (isNaN(parsed.getTime())) return null;
  return parsed.toISOString().split('T')[0];
}

export function normalizeOrderDate(orderDate?: string, fallbackDate?: string): string {
  const candidates = [orderDate, fallbackDate];
  for (const candidate of candidates) {
    if (!candidate) continue;
    const parsed = new Date(candidate);
    if (!isNaN(parsed.getTime())) {
      return parsed.toISOString().split('T')[0];
    }
  }
  return new Date().toISOString().split('T')[0];
}

export function stripHtml(html: string): string {
  return html
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    .replace(/<head[^>]*>[\s\S]*?<\/head>/gi, '')
    .replace(/<\/tr>/gi, '\n')
    .replace(/<\/td>/gi, ' | ')
    .replace(/<\/th>/gi, ' | ')
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<\/p>/gi, '\n')
    .replace(/<\/div>/gi, '\n')
    .replace(/<\/li>/gi, '\n')
    .replace(/<hr[^>]*>/gi, '\n---\n')
    .replace(/<[^>]+>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&dollar;/g, '$')
    .replace(/&#36;/g, '$')
    .replace(/[ \t]+/g, ' ')
    .replace(/\n\s*\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

function extractItemsFromBody(body: string): ExtractedItem[] {
  const items: ExtractedItem[] = [];
  const seenNames = new Set<string>();

  const priceLinePattern = /([A-Z][^$\n]{5,60})\s*\$(\d+\.?\d*)/gi;
  let match: RegExpExecArray | null;
  while ((match = priceLinePattern.exec(body)) !== null) {
    const name = match[1].trim();
    const price = parseFloat(match[2]);
    if (
      !name.toLowerCase().includes('total') &&
      !name.toLowerCase().includes('subtotal') &&
      !name.toLowerCase().includes('shipping') &&
      !name.toLowerCase().includes('tax') &&
      !seenNames.has(name.toLowerCase())
    ) {
      seenNames.add(name.toLowerCase());
      items.push({
        name,
        normalizedName: name.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim(),
        quantity: 1,
        unit: 'ea',
        unitPrice: price,
        totalPrice: price,
      });
    }
  }

  const itemNumberPattern = /Item\s*#?\s*:?\s*(\d+)[^$]*\$(\d+\.?\d*)/gi;
  while ((match = itemNumberPattern.exec(body)) !== null) {
    const sku = match[1];
    const price = parseFloat(match[2]);
    const beforeMatch = body.substring(Math.max(0, match.index - 100), match.index);
    const lines = beforeMatch.split('\n').filter(line => line.trim().length > 10);
    const productName = lines[lines.length - 1]?.trim() || `Item ${sku}`;

    if (!seenNames.has(productName.toLowerCase()) && price > 0) {
      seenNames.add(productName.toLowerCase());
      items.push({
        name: productName,
        normalizedName: productName.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim(),
        sku,
        quantity: 1,
        unit: 'ea',
        unitPrice: price,
        totalPrice: price,
      });
    }
  }

  const qtyPattern = /([A-Za-z][^|\n]{5,60})\s*(?:Qty|Quantity)\s*:?\s*(\d+)\s*[|\s]*\$?(\d+\.?\d*)?/gi;
  while ((match = qtyPattern.exec(body)) !== null) {
    const name = match[1].trim();
    const qty = parseInt(match[2], 10);
    const price = match[3] ? parseFloat(match[3]) : 0;

    if (!seenNames.has(name.toLowerCase()) && qty > 0) {
      seenNames.add(name.toLowerCase());
      items.push({
        name,
        normalizedName: name.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim(),
        quantity: qty,
        unit: 'ea',
        unitPrice: price || null,
        totalPrice: price ? price * qty : null,
      });
    }
  }

  return items.slice(0, 20);
}

function extractSupplierFromSender(sender: string): string {
  const emailMatch = sender.match(/@([^.]+)/);
  if (emailMatch) {
    return emailMatch[1].charAt(0).toUpperCase() + emailMatch[1].slice(1);
  }
  const nameMatch = sender.match(/^([^<]+)/);
  if (nameMatch) {
    return nameMatch[1].trim();
  }
  return 'Unknown Supplier';
}

function keywordFallbackDetection(
  email: Pick<EmailExtractionInput, 'id' | 'subject' | 'sender' | 'date'>,
  body: string
): EmailExtractionResult {
  const combined = `${email.subject} ${email.sender} ${body}`.toLowerCase();
  const emailDate = parseEmailDate(email.date) || new Date().toISOString().split('T')[0];

  const orderKeywords = [
    'order confirmation', 'order #', 'order number', 'order placed',
    'invoice', 'receipt', 'payment received', 'payment confirmation',
    'your order', 'purchase', 'transaction', 'shipped', 'shipment',
    'tracking number', 'delivered', 'out for delivery',
    'qty', 'quantity', 'subtotal', 'total:', 'grand total', 'amount due',
  ];

  const knownSuppliers: Record<string, string> = {
    amazon: 'Amazon',
    costco: 'Costco',
    walmart: 'Walmart',
    target: 'Target',
    uline: 'Uline',
    grainger: 'Grainger',
    fastenal: 'Fastenal',
    mcmaster: 'McMaster-Carr',
    msc: 'MSC Industrial',
    homedepot: 'Home Depot',
    lowes: 'Lowes',
    sysco: 'Sysco',
    usfoods: 'US Foods',
    zoro: 'Zoro',
    staples: 'Staples',
    officedepot: 'Office Depot',
    newegg: 'Newegg',
    chewy: 'Chewy',
    ebay: 'eBay',
    fedex: 'FedEx',
    ups: 'UPS',
    usps: 'USPS',
  };

  const hasOrderKeyword = orderKeywords.some(keyword => combined.includes(keyword));
  const hasDollarAmount = /\$\d+\.?\d*/i.test(combined);

  let detectedSupplier: string | null = null;
  for (const [key, name] of Object.entries(knownSuppliers)) {
    if (combined.includes(key)) {
      detectedSupplier = name;
      break;
    }
  }

  if ((hasOrderKeyword && hasDollarAmount) || (detectedSupplier && hasDollarAmount)) {
    const extractedItems = extractItemsFromBody(body);
    const totalAmount = extractedItems.reduce(
      (sum, item) => sum + (typeof item.totalPrice === 'number' ? item.totalPrice : (item.unitPrice || 0)),
      0
    );
    return {
      emailId: email.id,
      isOrder: true,
      supplier: detectedSupplier || extractSupplierFromSender(email.sender),
      items: extractedItems,
      confidence: extractedItems.length > 0 ? 0.7 : 0.5,
      orderDate: emailDate,
      totalAmount,
    };
  }

  return {
    emailId: email.id,
    isOrder: false,
    supplier: null,
    items: [],
    confidence: 0,
    orderDate: emailDate,
    totalAmount: 0,
  };
}

export async function analyzeEmailWithRetry(
  model: {
    generateContent: (prompt: string) => Promise<{ response: { text: () => string } }>;
  },
  email: EmailExtractionInput,
  maxRetries: number = 3
): Promise<EmailExtractionResult> {
  let cleanBody = email.body;
  if (cleanBody.includes('<html') || cleanBody.includes('<div') || cleanBody.includes('<table')) {
    cleanBody = stripHtml(cleanBody);
  }

  const emailContent = `
Subject: ${email.subject}
From: ${email.sender}
Date: ${email.date || 'Unknown'}
Content:
${cleanBody.substring(0, 8000)}
`;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const result = await model.generateContent(EXTRACTION_PROMPT + emailContent);
      const response = result.response;
      const text = response.text();
      const jsonMatch = text.match(/\{[\s\S]*\}/);

      if (!jsonMatch) {
        const fallbackResult = keywordFallbackDetection(email, cleanBody);
        if (fallbackResult.isOrder) {
          return fallbackResult;
        }
        return {
          emailId: email.id,
          isOrder: false,
          supplier: null,
          orderDate: normalizeOrderDate(undefined, email.date),
          totalAmount: 0,
          items: [],
          confidence: 0,
        };
      }

      let parsed = JSON.parse(jsonMatch[0]) as Partial<EmailExtractionResult>;

      if (!parsed.isOrder) {
        const fallbackResult = keywordFallbackDetection(email, cleanBody);
        if (fallbackResult.isOrder) {
          parsed = { ...parsed, ...fallbackResult };
        }
      }

      if (parsed.isOrder && (!Array.isArray(parsed.items) || parsed.items.length === 0)) {
        const extractedItems = extractItemsFromBody(cleanBody);
        if (extractedItems.length > 0) {
          parsed.items = extractedItems;
          parsed.totalAmount = extractedItems.reduce(
            (sum, item) => sum + (typeof item.totalPrice === 'number' ? item.totalPrice : (item.unitPrice || 0)),
            0
          );
        }
      }

      return {
        emailId: email.id,
        isOrder: Boolean(parsed.isOrder),
        supplier: parsed.supplier || null,
        orderDate: normalizeOrderDate(parsed.orderDate, email.date),
        totalAmount: typeof parsed.totalAmount === 'number' ? parsed.totalAmount : 0,
        items: Array.isArray(parsed.items) ? parsed.items : [],
        confidence: typeof parsed.confidence === 'number' ? parsed.confidence : 0,
        ...parsed,
      };
    } catch (error: any) {
      const isRateLimit = error.status === 429 || error.status === 403;
      const isLastAttempt = attempt === maxRetries - 1;

      if (isRateLimit && !isLastAttempt) {
        const waitTime = Math.pow(2, attempt + 1) * 1000;
        await delay(waitTime);
        continue;
      }

      const fallbackResult = keywordFallbackDetection(email, cleanBody);
      if (fallbackResult.isOrder) {
        return fallbackResult;
      }

      return {
        emailId: email.id,
        isOrder: false,
        supplier: null,
        orderDate: normalizeOrderDate(undefined, email.date),
        totalAmount: 0,
        items: [],
        confidence: 0,
      };
    }
  }

  return {
    emailId: email.id,
    isOrder: false,
    supplier: null,
    orderDate: normalizeOrderDate(undefined, email.date),
    totalAmount: 0,
    items: [],
    confidence: 0,
  };
}

```

### `server/src/services/imageUpload.ts`

```typescript
// Image Upload Service
// Handles uploading base64 images to cloud storage and returning hosted URLs

import { v2 as cloudinary } from 'cloudinary';
import { appLogger } from '../middleware/requestLogger.js';

// Configure Cloudinary from environment
const isConfigured = !!(
  process.env.CLOUDINARY_CLOUD_NAME &&
  process.env.CLOUDINARY_API_KEY &&
  process.env.CLOUDINARY_API_SECRET
);

if (isConfigured) {
  cloudinary.config({
    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET,
  });
  appLogger.info('Cloudinary configured for image uploads');
} else {
  appLogger.warn('Cloudinary not configured - image uploads will fail. Set CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY, CLOUDINARY_API_SECRET');
}

/**
 * Check if a URL is a base64 data URL
 */
export function isDataUrl(url: string): boolean {
  return url?.startsWith('data:');
}

/**
 * Check if image upload service is available
 */
export function isImageUploadAvailable(): boolean {
  return isConfigured;
}

/**
 * Upload a base64 image to Cloudinary and return the hosted URL
 * @param dataUrl - Base64 data URL (data:image/jpeg;base64,...)
 * @param options - Upload options
 * @returns Hosted URL or null if upload fails
 */
export async function uploadImage(
  dataUrl: string,
  options?: {
    folder?: string;
    publicId?: string;
    transformation?: Record<string, unknown>;
  }
): Promise<string | null> {
  if (!isConfigured) {
    appLogger.warn('Cloudinary not configured - cannot upload image');
    return null;
  }

  if (!isDataUrl(dataUrl)) {
    // Already a hosted URL, return as-is
    return dataUrl;
  }

  try {
    const result = await cloudinary.uploader.upload(dataUrl, {
      folder: options?.folder || 'order-pulse/items',
      public_id: options?.publicId,
      transformation: options?.transformation || [
        { width: 800, height: 800, crop: 'limit' }, // Limit size
        { quality: 'auto' },
        { fetch_format: 'auto' },
      ],
      resource_type: 'image',
    });

    appLogger.info({ publicId: result.public_id, url: result.secure_url }, 'Image uploaded to Cloudinary');
    return result.secure_url;
  } catch (error) {
    appLogger.error({ err: error }, 'Failed to upload image to Cloudinary');
    return null;
  }
}

/**
 * Upload multiple images in parallel
 * @param dataUrls - Array of base64 data URLs or hosted URLs
 * @param folder - Folder name in Cloudinary
 * @returns Map of original URL to hosted URL
 */
export async function uploadImages(
  dataUrls: string[],
  folder?: string
): Promise<Map<string, string>> {
  const results = new Map<string, string>();

  const uploadPromises = dataUrls.map(async (url) => {
    if (!isDataUrl(url)) {
      // Already hosted
      results.set(url, url);
      return;
    }

    const hostedUrl = await uploadImage(url, { folder });
    if (hostedUrl) {
      results.set(url, hostedUrl);
    }
  });

  await Promise.all(uploadPromises);
  return results;
}

/**
 * Ensure an image URL is hosted (upload if it's a data URL)
 * @param imageUrl - Image URL (data URL or hosted URL)
 * @param folder - Optional folder for organization
 * @returns Hosted URL or original URL if upload fails/not configured
 */
export async function ensureHostedUrl(
  imageUrl: string | undefined,
  folder?: string
): Promise<string | undefined> {
  if (!imageUrl) return undefined;
  
  if (!isDataUrl(imageUrl)) {
    // Already hosted
    return imageUrl;
  }

  if (!isConfigured) {
    appLogger.warn('Image is data URL but Cloudinary not configured - returning undefined');
    return undefined; // Don't send data URLs to Arda
  }

  const hostedUrl = await uploadImage(imageUrl, { folder });
  return hostedUrl || undefined;
}

export const imageUploadService = {
  isDataUrl,
  isImageUploadAvailable,
  uploadImage,
  uploadImages,
  ensureHostedUrl,
};

```

### `server/src/services/inboundReceiptWorker.test.ts`

```typescript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const mockQuery = vi.fn();
const mockGetUserByEmail = vi.fn();
const mockProvisionUserForEmail = vi.fn();

vi.mock('../db/index.js', () => ({
  query: mockQuery,
}));

vi.mock('./cognito.js', () => ({
  cognitoService: {
    getUserByEmail: mockGetUserByEmail,
  },
}));

vi.mock('./arda.js', () => ({
  ardaService: {
    provisionUserForEmail: mockProvisionUserForEmail,
    createOrder: vi.fn(),
    createItem: vi.fn(),
  },
}));

describe('inboundReceiptWorker helpers', () => {
  const originalEnv = process.env;

  beforeEach(() => {
    vi.resetModules();
    vi.clearAllMocks();
    process.env = { ...originalEnv };
  });

  afterEach(async () => {
    process.env = originalEnv;
    const { stopInboundReceiptWorker } = await import('./inboundReceiptWorker.js');
    stopInboundReceiptWorker();
  });

  it('normalizes postmark payload and produces stable idempotency key', async () => {
    const { normalizePostmarkPayload } = await import('./inboundReceiptWorker.js');
    const payload = normalizePostmarkPayload({
      MessageID: '<abc123@example.com>',
      Subject: 'Your receipt',
      From: 'Sender <sender@example.com>',
      TextBody: 'Thanks for ordering',
      Headers: [{ Name: 'X-Test', Value: '1' }],
    });

    expect(payload.fromEmail).toBe('sender@example.com');
    expect(payload.messageId).toBe('abc123@example.com');
    expect(payload.idempotencyKey).toBe('postmark:abc123@example.com');
    expect(payload.contentHash).toHaveLength(64);
  });

  it('enqueues first payload and marks repeated payload as duplicate', async () => {
    const { enqueuePostmarkInboundReceipt } = await import('./inboundReceiptWorker.js');

    mockQuery
      .mockResolvedValueOnce({ rowCount: 1, rows: [{ id: 'evt-1', status: 'received' }] })
      .mockResolvedValueOnce({ rowCount: 0, rows: [] })
      .mockResolvedValueOnce({ rowCount: 1, rows: [{ id: 'evt-1', status: 'received' }] });

    const payload = {
      MessageID: '<m-1@example.com>',
      Subject: 'Receipt',
      FromFull: { Email: 'sender@example.com' },
      TextBody: 'Thanks',
    };

    const first = await enqueuePostmarkInboundReceipt(payload);
    const second = await enqueuePostmarkInboundReceipt(payload);

    expect(first.duplicate).toBe(false);
    expect(first.eventId).toBe('evt-1');
    expect(second.duplicate).toBe(true);
    expect(second.eventId).toBe('evt-1');
  });

  it('resolves actor from cognito mapping first, then provision fallback', async () => {
    const { resolveInboundActorForSender } = await import('./inboundReceiptWorker.js');

    mockGetUserByEmail.mockReturnValueOnce({
      email: 'mapped@example.com',
      tenantId: 'tenant-1',
      sub: 'author-1',
    });
    const cognitoResolved = await resolveInboundActorForSender('mapped@example.com');
    expect(cognitoResolved?.source).toBe('cognito');
    expect(cognitoResolved?.actor.author).toBe('author-1');

    mockGetUserByEmail.mockReturnValueOnce(null);
    mockProvisionUserForEmail.mockResolvedValueOnce({
      author: 'provisioned-author',
      email: 'new@example.com',
      tenantId: 'tenant-2',
    });
    const provisionedResolved = await resolveInboundActorForSender('new@example.com');
    expect(provisionedResolved?.source).toBe('provisioned');
    expect(provisionedResolved?.actor.tenantId).toBe('tenant-2');
  });

  it('evaluates guardrails for low confidence and missing items', async () => {
    const { evaluateInboundGuardrails } = await import('./inboundReceiptWorker.js');

    const lowConfidence = evaluateInboundGuardrails(
      { isOrder: true, confidence: 0.5, items: [{ name: 'Item' }] },
      0.78
    );
    expect(lowConfidence.pass).toBe(false);
    expect(lowConfidence.reason).toBe('low_confidence');

    const noItems = evaluateInboundGuardrails(
      { isOrder: true, confidence: 0.9, items: [] },
      0.78
    );
    expect(noItems.pass).toBe(false);
    expect(noItems.reason).toBe('no_items');
  });

  it('purges raw content using configured retention days', async () => {
    const { purgeExpiredInboundRawContent } = await import('./inboundReceiptWorker.js');
    process.env.INBOUND_RETENTION_DAYS = '30';
    mockQuery.mockResolvedValueOnce({ rowCount: 2, rows: [{ id: 'a' }, { id: 'b' }] });

    const purged = await purgeExpiredInboundRawContent();
    expect(purged).toBe(2);
    expect(mockQuery).toHaveBeenCalledWith(expect.stringContaining('UPDATE inbound_receipts'), [30]);
  });
});

```

### `server/src/services/inboundReceiptWorker.ts`

```typescript
import crypto from 'node:crypto';
import { query } from '../db/index.js';
import { appLogger } from '../middleware/requestLogger.js';
import { cognitoService } from './cognito.js';
import { ArdaActor, ardaService } from './arda.js';
import {
  analyzeEmailWithRetry,
  createGeminiExtractionModel,
  EmailExtractionResult,
  normalizeOrderDate,
} from './emailExtraction.js';

type InboundReceiptStatus = 'received' | 'processing' | 'retry' | 'quarantined' | 'synced' | 'failed';
type InboundAttemptStatus = 'processing' | 'retry' | 'quarantined' | 'synced' | 'failed';

interface InboundReceiptRow {
  id: string;
  provider: string;
  provider_message_id: string | null;
  message_id: string | null;
  idempotency_key: string;
  from_email: string;
  from_name: string | null;
  subject: string | null;
  source_recipient: string | null;
  email_date: string | null;
  raw_headers: unknown;
  raw_text_body: string | null;
  raw_html_body: string | null;
  content_hash: string;
  status: InboundReceiptStatus;
  guardrail_reason: string | null;
  resolved_user_email: string | null;
  resolved_author: string | null;
  resolved_tenant_id: string | null;
  extracted_data: unknown;
  arda_order_record_id: string | null;
  arda_item_record_ids: unknown;
  duplicate_of_event_id: string | null;
  attempt_count: number;
  next_attempt_at: string;
  last_error: string | null;
  processed_at: string | null;
  created_at: string;
  updated_at: string;
}

interface InboundStatusRow {
  id: string;
  provider: string;
  provider_message_id: string | null;
  message_id: string | null;
  from_email: string;
  subject: string | null;
  status: InboundReceiptStatus;
  guardrail_reason: string | null;
  resolved_user_email: string | null;
  resolved_author: string | null;
  resolved_tenant_id: string | null;
  attempt_count: number;
  next_attempt_at: string;
  last_error: string | null;
  processed_at: string | null;
  created_at: string;
  updated_at: string;
  arda_order_record_id: string | null;
  arda_item_count: number;
}

export interface PostmarkInboundAddress {
  Email?: string;
  Name?: string;
  MailboxHash?: string;
}

export interface PostmarkInboundPayload {
  MessageID?: string;
  Subject?: string;
  Date?: string;
  From?: string;
  FromName?: string;
  FromFull?: PostmarkInboundAddress;
  To?: string;
  TextBody?: string;
  HtmlBody?: string;
  StrippedTextReply?: string;
  Headers?: Array<{ Name?: string; Value?: string }>;
  [key: string]: unknown;
}

export interface NormalizedPostmarkPayload {
  provider: 'postmark';
  providerMessageId: string | null;
  messageId: string | null;
  fromEmail: string;
  fromName: string | null;
  subject: string;
  sourceRecipient: string | null;
  emailDate: string | null;
  rawHeaders: unknown;
  rawTextBody: string;
  rawHtmlBody: string;
  contentHash: string;
  idempotencyKey: string;
}

export interface EnqueueInboundResult {
  eventId: string;
  duplicate: boolean;
  status: InboundReceiptStatus;
}

export interface InboundStatusResponse {
  eventId: string;
  provider: string;
  providerMessageId: string | null;
  messageId: string | null;
  fromEmail: string;
  subject: string | null;
  status: InboundReceiptStatus;
  guardrailReason: string | null;
  resolvedUserEmail: string | null;
  resolvedAuthor: string | null;
  resolvedTenantId: string | null;
  attemptCount: number;
  nextAttemptAt: string;
  lastError: string | null;
  processedAt: string | null;
  createdAt: string;
  updatedAt: string;
  ardaOrderRecordId: string | null;
  ardaItemCount: number;
}

export interface InboundGuardrailEvaluation {
  pass: boolean;
  reason?: 'not_order' | 'no_items' | 'low_confidence' | 'duplicate';
}

export interface ResolvedInboundActor {
  actor: ArdaActor;
  source: 'cognito' | 'provisioned';
}

let processTimer: ReturnType<typeof setInterval> | null = null;
let purgeTimer: ReturnType<typeof setInterval> | null = null;
let isProcessing = false;
let immediateProcessTimer: ReturnType<typeof setTimeout> | null = null;
let extractionModel: ReturnType<typeof createGeminiExtractionModel> | null = null;

const PROCESS_INTERVAL_MS = 3_000;
const PURGE_INTERVAL_MS = 24 * 60 * 60 * 1000;

function getInboundBatchSize(): number {
  return Number(process.env.INBOUND_PROCESS_BATCH_SIZE || '10');
}

function getInboundConfidenceThreshold(): number {
  return Number(process.env.INBOUND_CONFIDENCE_THRESHOLD || '0.78');
}

function getInboundMaxRetries(): number {
  return Number(process.env.INBOUND_MAX_RETRIES || '5');
}

function getInboundRetentionDays(): number {
  return Number(process.env.INBOUND_RETENTION_DAYS || '30');
}

function getExtractionModel() {
  if (!extractionModel) {
    extractionModel = createGeminiExtractionModel();
  }
  return extractionModel;
}

function parseEmailAddress(input?: string): string | null {
  if (!input) return null;
  const trimmed = input.trim();
  const angleMatch = trimmed.match(/<([^>]+)>/);
  if (angleMatch?.[1]) {
    return angleMatch[1].trim().toLowerCase();
  }
  if (trimmed.includes('@')) {
    return trimmed.toLowerCase();
  }
  return null;
}

function normalizeMessageId(value?: string | null): string | null {
  if (!value) return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  return trimmed.replace(/^<|>$/g, '');
}

function computeContentHash(parts: string[]): string {
  return crypto.createHash('sha256').update(parts.join('\n')).digest('hex');
}

function buildIdempotencyKey(messageId: string | null, contentHash: string): string {
  return messageId ? `postmark:${messageId}` : `postmark:${contentHash}`;
}

function inferSupplierFromEmail(email: string): string {
  const domain = email.split('@')[1] || '';
  const base = domain.split('.')[0] || 'Unknown';
  return base.charAt(0).toUpperCase() + base.slice(1);
}

function computeRetryDelayMs(attemptNumber: number): number {
  const minute = 60 * 1000;
  return Math.min(60 * minute, Math.pow(2, Math.max(0, attemptNumber - 1)) * minute);
}

export function evaluateInboundGuardrails(
  result: Pick<EmailExtractionResult, 'isOrder' | 'confidence' | 'items'>,
  threshold: number
): InboundGuardrailEvaluation {
  if (!result.isOrder) {
    return { pass: false, reason: 'not_order' };
  }
  if (!Array.isArray(result.items) || result.items.length === 0) {
    return { pass: false, reason: 'no_items' };
  }
  if (typeof result.confidence !== 'number' || result.confidence < threshold) {
    return { pass: false, reason: 'low_confidence' };
  }
  return { pass: true };
}

export function isTransientInboundError(error: unknown): boolean {
  const message = (error instanceof Error ? error.message : String(error)).toLowerCase();
  return (
    message.includes('timeout') ||
    message.includes('timed out') ||
    message.includes('econnreset') ||
    message.includes('eai_again') ||
    message.includes('rate limit') ||
    message.includes('429') ||
    message.includes('502') ||
    message.includes('503') ||
    message.includes('504')
  );
}

export function normalizePostmarkPayload(payload: PostmarkInboundPayload): NormalizedPostmarkPayload {
  const messageId = normalizeMessageId(
    typeof payload.MessageID === 'string' ? payload.MessageID : null
  );

  const fromEmail = (
    payload.FromFull?.Email?.trim().toLowerCase() ||
    parseEmailAddress(typeof payload.From === 'string' ? payload.From : '') ||
    ''
  );
  const fromName = (payload.FromFull?.Name || payload.FromName || null)?.trim() || null;
  const subject = (typeof payload.Subject === 'string' ? payload.Subject : '').trim();
  const rawTextBody = (
    typeof payload.TextBody === 'string'
      ? payload.TextBody
      : (typeof payload.StrippedTextReply === 'string' ? payload.StrippedTextReply : '')
  ).trim();
  const rawHtmlBody = (typeof payload.HtmlBody === 'string' ? payload.HtmlBody : '').trim();
  const sourceRecipient = (typeof payload.To === 'string' ? payload.To : null)?.trim() || null;
  const emailDate = (typeof payload.Date === 'string' ? payload.Date : null)?.trim() || null;

  const contentHash = computeContentHash([
    fromEmail,
    subject,
    emailDate || '',
    rawTextBody,
    rawHtmlBody,
  ]);

  return {
    provider: 'postmark',
    providerMessageId: messageId,
    messageId,
    fromEmail,
    fromName,
    subject,
    sourceRecipient,
    emailDate,
    rawHeaders: payload.Headers || [],
    rawTextBody,
    rawHtmlBody,
    contentHash,
    idempotencyKey: buildIdempotencyKey(messageId, contentHash),
  };
}

export async function enqueuePostmarkInboundReceipt(payload: PostmarkInboundPayload): Promise<EnqueueInboundResult> {
  const normalized = normalizePostmarkPayload(payload);
  if (!normalized.fromEmail) {
    throw new Error('Invalid Postmark payload: missing sender email');
  }

  const insertResult = await query<{ id: string; status: InboundReceiptStatus }>(
    `
    INSERT INTO inbound_receipts (
      provider,
      provider_message_id,
      message_id,
      idempotency_key,
      from_email,
      from_name,
      subject,
      source_recipient,
      email_date,
      raw_headers,
      raw_text_body,
      raw_html_body,
      content_hash,
      status,
      next_attempt_at
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8,
      CASE WHEN $9::text IS NOT NULL THEN $9::timestamptz ELSE NULL END,
      $10::jsonb, $11, $12, $13, 'received', NOW()
    )
    ON CONFLICT (idempotency_key) DO NOTHING
    RETURNING id, status
    `,
    [
      normalized.provider,
      normalized.providerMessageId,
      normalized.messageId,
      normalized.idempotencyKey,
      normalized.fromEmail,
      normalized.fromName,
      normalized.subject,
      normalized.sourceRecipient,
      normalized.emailDate,
      JSON.stringify(normalized.rawHeaders),
      normalized.rawTextBody,
      normalized.rawHtmlBody,
      normalized.contentHash,
    ]
  );

  if (insertResult.rowCount && insertResult.rows[0]) {
    const inserted = insertResult.rows[0];
    appLogger.info(
      { eventId: inserted.id, senderEmail: normalized.fromEmail, status: inserted.status, attempt: 0 },
      'Inbound receipt accepted'
    );
    triggerInboundProcessing();
    return { eventId: inserted.id, duplicate: false, status: inserted.status };
  }

  const existingResult = await query<{ id: string; status: InboundReceiptStatus }>(
    `
    SELECT id, status
    FROM inbound_receipts
    WHERE idempotency_key = $1
    LIMIT 1
    `,
    [normalized.idempotencyKey]
  );

  if (!existingResult.rowCount || !existingResult.rows[0]) {
    throw new Error('Failed to resolve existing inbound receipt');
  }

  const existing = existingResult.rows[0];
  appLogger.info(
    { eventId: existing.id, senderEmail: normalized.fromEmail, status: existing.status, attempt: 0 },
    'Inbound receipt duplicate ignored by idempotency key'
  );
  return { eventId: existing.id, duplicate: true, status: existing.status };
}

export async function getInboundReceiptStatus(eventId: string): Promise<InboundStatusResponse | null> {
  const result = await query<InboundStatusRow>(
    `
    SELECT
      id,
      provider,
      provider_message_id,
      message_id,
      from_email,
      subject,
      status,
      guardrail_reason,
      resolved_user_email,
      resolved_author,
      resolved_tenant_id,
      attempt_count,
      next_attempt_at,
      last_error,
      processed_at,
      created_at,
      updated_at,
      arda_order_record_id,
      COALESCE(jsonb_array_length(arda_item_record_ids), 0)::int AS arda_item_count
    FROM inbound_receipts
    WHERE id = $1
    LIMIT 1
    `,
    [eventId]
  );

  const row = result.rows[0];
  if (!row) return null;

  return {
    eventId: row.id,
    provider: row.provider,
    providerMessageId: row.provider_message_id,
    messageId: row.message_id,
    fromEmail: row.from_email,
    subject: row.subject,
    status: row.status,
    guardrailReason: row.guardrail_reason,
    resolvedUserEmail: row.resolved_user_email,
    resolvedAuthor: row.resolved_author,
    resolvedTenantId: row.resolved_tenant_id,
    attemptCount: row.attempt_count,
    nextAttemptAt: row.next_attempt_at,
    lastError: row.last_error,
    processedAt: row.processed_at,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
    ardaOrderRecordId: row.arda_order_record_id,
    ardaItemCount: row.arda_item_count,
  };
}

export async function resolveInboundActorForSender(senderEmail: string): Promise<ResolvedInboundActor | null> {
  const normalizedEmail = senderEmail.trim().toLowerCase();
  const cached = cognitoService.getUserByEmail(normalizedEmail);
  if (cached?.sub && cached.tenantId) {
    return {
      actor: {
        author: cached.sub,
        email: normalizedEmail,
        tenantId: cached.tenantId,
      },
      source: 'cognito',
    };
  }

  const provisioned = await ardaService.provisionUserForEmail(normalizedEmail);
  if (provisioned?.author && provisioned.tenantId) {
    return {
      actor: {
        author: provisioned.author,
        email: provisioned.email || normalizedEmail,
        tenantId: provisioned.tenantId,
      },
      source: 'provisioned',
    };
  }

  return null;
}

async function isDuplicateForResolvedUser(
  receiptId: string,
  resolvedUserEmail: string,
  messageId: string | null,
  contentHash: string
): Promise<string | null> {
  const duplicateResult = await query<{ id: string }>(
    `
    SELECT id
    FROM inbound_receipts
    WHERE id <> $1
      AND resolved_user_email = $2
      AND status IN ('processing', 'retry', 'quarantined', 'synced', 'failed')
      AND (
        ($3::text IS NOT NULL AND message_id = $3)
        OR content_hash = $4
      )
    ORDER BY created_at ASC
    LIMIT 1
    `,
    [receiptId, resolvedUserEmail, messageId, contentHash]
  );
  return duplicateResult.rows[0]?.id || null;
}

async function insertReceiptAttempt(
  receiptId: string,
  attemptNumber: number,
  status: InboundAttemptStatus,
  error: string | null,
  metadata: unknown
): Promise<void> {
  await query(
    `
    INSERT INTO inbound_receipt_attempts (
      receipt_id,
      attempt_number,
      status,
      error,
      metadata
    ) VALUES ($1, $2, $3, $4, $5::jsonb)
    `,
    [receiptId, attemptNumber, status, error, JSON.stringify(metadata || {})]
  );
}

async function markReceiptQuarantined(params: {
  row: InboundReceiptRow;
  attemptNumber: number;
  reason: string;
  actor?: ArdaActor;
  extractedData?: unknown;
  duplicateOfEventId?: string | null;
}): Promise<void> {
  await query(
    `
    UPDATE inbound_receipts
    SET
      status = 'quarantined',
      guardrail_reason = $2,
      resolved_user_email = COALESCE($3, resolved_user_email),
      resolved_author = COALESCE($4, resolved_author),
      resolved_tenant_id = COALESCE($5, resolved_tenant_id),
      extracted_data = COALESCE($6::jsonb, extracted_data),
      duplicate_of_event_id = COALESCE($7::uuid, duplicate_of_event_id),
      attempt_count = $8,
      last_error = NULL,
      next_attempt_at = NOW(),
      processed_at = NOW(),
      updated_at = NOW()
    WHERE id = $1
    `,
    [
      params.row.id,
      params.reason,
      params.actor?.email || null,
      params.actor?.author || null,
      params.actor?.tenantId || null,
      params.extractedData ? JSON.stringify(params.extractedData) : null,
      params.duplicateOfEventId || null,
      params.attemptNumber,
    ]
  );

  await insertReceiptAttempt(params.row.id, params.attemptNumber, 'quarantined', null, {
    reason: params.reason,
    duplicateOfEventId: params.duplicateOfEventId || null,
  });
}

async function markReceiptSynced(params: {
  row: InboundReceiptRow;
  attemptNumber: number;
  actor: ArdaActor;
  extractedData: unknown;
  orderRecordId: string;
  itemRecordIds: string[];
}): Promise<void> {
  await query(
    `
    UPDATE inbound_receipts
    SET
      status = 'synced',
      guardrail_reason = NULL,
      resolved_user_email = $2,
      resolved_author = $3,
      resolved_tenant_id = $4,
      extracted_data = $5::jsonb,
      arda_order_record_id = $6,
      arda_item_record_ids = $7::jsonb,
      attempt_count = $8,
      last_error = NULL,
      next_attempt_at = NOW(),
      processed_at = NOW(),
      updated_at = NOW()
    WHERE id = $1
    `,
    [
      params.row.id,
      params.actor.email || null,
      params.actor.author,
      params.actor.tenantId || null,
      JSON.stringify(params.extractedData),
      params.orderRecordId,
      JSON.stringify(params.itemRecordIds),
      params.attemptNumber,
    ]
  );

  await insertReceiptAttempt(params.row.id, params.attemptNumber, 'synced', null, {
    orderRecordId: params.orderRecordId,
    itemCount: params.itemRecordIds.length,
  });
}

async function markReceiptRetry(params: {
  row: InboundReceiptRow;
  attemptNumber: number;
  errorMessage: string;
  actor?: ArdaActor;
}): Promise<void> {
  const retryAt = new Date(Date.now() + computeRetryDelayMs(params.attemptNumber));
  await query(
    `
    UPDATE inbound_receipts
    SET
      status = 'retry',
      resolved_user_email = COALESCE($2, resolved_user_email),
      resolved_author = COALESCE($3, resolved_author),
      resolved_tenant_id = COALESCE($4, resolved_tenant_id),
      attempt_count = $5,
      last_error = $6,
      next_attempt_at = $7::timestamptz,
      processed_at = NULL,
      updated_at = NOW()
    WHERE id = $1
    `,
    [
      params.row.id,
      params.actor?.email || null,
      params.actor?.author || null,
      params.actor?.tenantId || null,
      params.attemptNumber,
      params.errorMessage,
      retryAt.toISOString(),
    ]
  );

  await insertReceiptAttempt(params.row.id, params.attemptNumber, 'retry', params.errorMessage, {
    retryAt: retryAt.toISOString(),
  });
}

async function markReceiptFailed(params: {
  row: InboundReceiptRow;
  attemptNumber: number;
  errorMessage: string;
  actor?: ArdaActor;
}): Promise<void> {
  await query(
    `
    UPDATE inbound_receipts
    SET
      status = 'failed',
      resolved_user_email = COALESCE($2, resolved_user_email),
      resolved_author = COALESCE($3, resolved_author),
      resolved_tenant_id = COALESCE($4, resolved_tenant_id),
      attempt_count = $5,
      last_error = $6,
      next_attempt_at = NOW(),
      processed_at = NOW(),
      updated_at = NOW()
    WHERE id = $1
    `,
    [
      params.row.id,
      params.actor?.email || null,
      params.actor?.author || null,
      params.actor?.tenantId || null,
      params.attemptNumber,
      params.errorMessage,
    ]
  );

  await insertReceiptAttempt(params.row.id, params.attemptNumber, 'failed', params.errorMessage, {});
}

async function claimInboundReceipt(): Promise<InboundReceiptRow | null> {
  const claimResult = await query<InboundReceiptRow>(
    `
    WITH next_receipt AS (
      SELECT id
      FROM inbound_receipts
      WHERE status IN ('received', 'retry')
        AND next_attempt_at <= NOW()
      ORDER BY created_at ASC
      LIMIT 1
      FOR UPDATE SKIP LOCKED
    )
    UPDATE inbound_receipts r
    SET status = 'processing', updated_at = NOW()
    FROM next_receipt
    WHERE r.id = next_receipt.id
    RETURNING r.*
    `
  );

  return claimResult.rows[0] || null;
}

async function processClaimedReceipt(row: InboundReceiptRow): Promise<void> {
  const attemptNumber = row.attempt_count + 1;
  let resolvedActor: ArdaActor | undefined;
  let extractedResult: EmailExtractionResult | null = null;

  try {
    const actorResolution = await resolveInboundActorForSender(row.from_email);
    if (!actorResolution) {
      await markReceiptQuarantined({
        row,
        attemptNumber,
        reason: 'unmapped_sender',
      });
      appLogger.info(
        { eventId: row.id, senderEmail: row.from_email, status: 'quarantined', attempt: attemptNumber },
        'Inbound receipt quarantined due to unmapped sender'
      );
      return;
    }

    resolvedActor = actorResolution.actor;
    const duplicateOfEventId = await isDuplicateForResolvedUser(
      row.id,
      resolvedActor.email || row.from_email,
      row.message_id,
      row.content_hash
    );
    if (duplicateOfEventId) {
      await markReceiptQuarantined({
        row,
        attemptNumber,
        reason: 'duplicate',
        actor: resolvedActor,
        duplicateOfEventId,
      });
      appLogger.info(
        {
          eventId: row.id,
          senderEmail: row.from_email,
          resolvedUserEmail: resolvedActor.email,
          status: 'quarantined',
          attempt: attemptNumber,
        },
        'Inbound receipt quarantined as duplicate'
      );
      return;
    }

    const emailBody = row.raw_text_body || row.raw_html_body || '';
    const extractionInput = {
      id: row.id,
      subject: row.subject || '',
      sender: row.from_email,
      body: emailBody,
      date: row.email_date || undefined,
    };

    extractedResult = await analyzeEmailWithRetry(getExtractionModel() as any, extractionInput);

    const normalizedItems = (extractedResult.items || [])
      .map((item): { name: string; quantity: number; unit: string; unitPrice: number | null; sku?: string } | null => {
        if (!item || typeof item !== 'object') return null;
        const name = typeof item.name === 'string' ? item.name.trim() : '';
        if (!name) return null;
        const quantityRaw = Number((item as any).quantity);
        const quantity = Number.isFinite(quantityRaw) && quantityRaw > 0 ? quantityRaw : 1;
        const unit = typeof (item as any).unit === 'string' && (item as any).unit.trim()
          ? (item as any).unit.trim()
          : 'ea';
        const unitPriceRaw = (item as any).unitPrice;
        const unitPrice = typeof unitPriceRaw === 'number'
          ? unitPriceRaw
          : (typeof unitPriceRaw === 'string' ? Number(unitPriceRaw) : null);
        const sku = (typeof (item as any).partNumber === 'string' && (item as any).partNumber.trim())
          ? (item as any).partNumber.trim()
          : ((typeof (item as any).sku === 'string' && (item as any).sku.trim()) ? (item as any).sku.trim() : undefined);
        return { name, quantity, unit, unitPrice: Number.isFinite(unitPrice as number) ? (unitPrice as number) : null, sku };
      })
      .filter((item): item is { name: string; quantity: number; unit: string; unitPrice: number | null; sku?: string } => Boolean(item));

    extractedResult = {
      ...extractedResult,
      items: normalizedItems,
    };

    const guardrailEvaluation = evaluateInboundGuardrails(extractedResult, getInboundConfidenceThreshold());
    if (!guardrailEvaluation.pass) {
      await markReceiptQuarantined({
        row,
        attemptNumber,
        reason: guardrailEvaluation.reason || 'unknown_guardrail',
        actor: resolvedActor,
        extractedData: extractedResult,
      });
      appLogger.info(
        {
          eventId: row.id,
          senderEmail: row.from_email,
          resolvedUserEmail: resolvedActor.email,
          status: 'quarantined',
          attempt: attemptNumber,
        },
        'Inbound receipt quarantined by guardrail'
      );
      return;
    }

    const supplier = extractedResult.supplier || inferSupplierFromEmail(row.from_email);
    const orderDate = normalizeOrderDate(extractedResult.orderDate, row.email_date || undefined);

    const orderRecord = await ardaService.createOrder(
      {
        orderDate: {
          utcTimestamp: new Date(orderDate).getTime(),
        },
        allowPartial: false,
        expedite: false,
        supplierName: supplier,
        notes: `Forwarded receipt ${row.message_id || row.id}`,
        taxesAndFees: {},
      },
      resolvedActor
    );

    const itemRecordIds: string[] = [];
    for (const item of normalizedItems) {
      const itemRecord = await ardaService.createItem(
        {
          name: item.name,
          primarySupplier: supplier,
          orderMechanism: 'email',
          minQty: 1,
          minQtyUnit: item.unit || 'ea',
          orderQty: item.quantity || 1,
          orderQtyUnit: item.unit || 'ea',
          sku: item.sku,
        },
        resolvedActor
      );
      itemRecordIds.push(itemRecord.rId);
    }

    await markReceiptSynced({
      row,
      attemptNumber,
      actor: resolvedActor,
      extractedData: {
        ...extractedResult,
        supplier,
        orderDate,
      },
      orderRecordId: orderRecord.rId,
      itemRecordIds,
    });

    appLogger.info(
      {
        eventId: row.id,
        senderEmail: row.from_email,
        resolvedUserEmail: resolvedActor.email,
        status: 'synced',
        attempt: attemptNumber,
      },
      'Inbound receipt synced to Arda'
    );
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    const transient = isTransientInboundError(error);
    if (transient && attemptNumber < getInboundMaxRetries()) {
      await markReceiptRetry({
        row,
        attemptNumber,
        errorMessage: message,
        actor: resolvedActor,
      });
      appLogger.warn(
        {
          eventId: row.id,
          senderEmail: row.from_email,
          resolvedUserEmail: resolvedActor?.email,
          status: 'retry',
          attempt: attemptNumber,
        },
        'Inbound receipt processing failed transiently; scheduled retry'
      );
      return;
    }

    await markReceiptFailed({
      row,
      attemptNumber,
      errorMessage: message,
      actor: resolvedActor,
    });
    appLogger.error(
      {
        eventId: row.id,
        senderEmail: row.from_email,
        resolvedUserEmail: resolvedActor?.email,
        status: 'failed',
        attempt: attemptNumber,
      },
      'Inbound receipt processing failed'
    );
  }
}

export async function processInboundReceiptBatch(): Promise<number> {
  const batchSize = getInboundBatchSize();
  let processed = 0;

  for (let i = 0; i < batchSize; i++) {
    const claimed = await claimInboundReceipt();
    if (!claimed) break;
    await processClaimedReceipt(claimed);
    processed += 1;
  }

  return processed;
}

export async function purgeExpiredInboundRawContent(): Promise<number> {
  const retentionDays = getInboundRetentionDays();
  const result = await query<{ id: string }>(
    `
    UPDATE inbound_receipts
    SET
      raw_headers = NULL,
      raw_text_body = NULL,
      raw_html_body = NULL,
      updated_at = NOW()
    WHERE created_at < NOW() - ($1::text || ' days')::interval
      AND (raw_headers IS NOT NULL OR raw_text_body IS NOT NULL OR raw_html_body IS NOT NULL)
    RETURNING id
    `,
    [retentionDays]
  );
  return result.rowCount || 0;
}

export async function runInboundWorkerTick(): Promise<void> {
  if (isProcessing) return;
  isProcessing = true;
  try {
    await processInboundReceiptBatch();
  } catch (error) {
    appLogger.error({ err: error }, 'Inbound worker tick failed');
  } finally {
    isProcessing = false;
  }
}

function scheduleInboundWorkerTick(): void {
  void runInboundWorkerTick();
}

function scheduleInboundPurge(): void {
  void purgeExpiredInboundRawContent().catch((error) => {
    appLogger.error({ err: error }, 'Inbound raw-content purge failed');
  });
}

export function triggerInboundProcessing(): void {
  if (immediateProcessTimer) return;
  immediateProcessTimer = setTimeout(() => {
    immediateProcessTimer = null;
    scheduleInboundWorkerTick();
  }, 50);
}

export function startInboundReceiptWorker(): void {
  if (processTimer) return;

  processTimer = setInterval(() => {
    scheduleInboundWorkerTick();
  }, PROCESS_INTERVAL_MS);

  purgeTimer = setInterval(() => {
    scheduleInboundPurge();
  }, PURGE_INTERVAL_MS);

  scheduleInboundWorkerTick();
  scheduleInboundPurge();
}

export function stopInboundReceiptWorker(): void {
  if (processTimer) {
    clearInterval(processTimer);
    processTimer = null;
  }
  if (purgeTimer) {
    clearInterval(purgeTimer);
    purgeTimer = null;
  }
  if (immediateProcessTimer) {
    clearTimeout(immediateProcessTimer);
    immediateProcessTimer = null;
  }
}

```

### `server/src/services/integrations/errors.ts`

```typescript
export class IntegrationAuthError extends Error {
  public readonly retryable: boolean;
  public readonly code: string;

  constructor(code: string, message: string, retryable = false) {
    super(message);
    this.name = 'IntegrationAuthError';
    this.code = code;
    this.retryable = retryable;
  }
}

export function requireEnv(name: string): string {
  const value = process.env[name];
  if (!value) {
    throw new IntegrationAuthError('INTEGRATION_ENV_MISSING', `${name} is not configured`);
  }
  return value;
}

export async function parseJsonResponse(response: Response): Promise<any> {
  const text = await response.text();
  if (!text) return {};
  try {
    return JSON.parse(text);
  } catch {
    return { raw: text };
  }
}

export function asDateFromExpiresIn(expiresInSeconds?: number): Date {
  const expires = Number(expiresInSeconds || 3600);
  return new Date(Date.now() + Math.max(60, expires) * 1000);
}

```

### `server/src/services/integrations/providers/adapters.test.ts`

```typescript
import { describe, expect, it, vi } from 'vitest';
import { QuickBooksAdapter, mapQuickBooksPurchaseOrder } from './quickbooksAdapter.js';
import { XeroAdapter, mapXeroPurchaseOrder } from './xeroAdapter.js';
import { buildProviderOrderId, isDeletedPurchaseOrderStatus } from '../syncOrchestrator.js';

describe('provider adapters', () => {
  it('maps QuickBooks purchase orders to canonical shape', () => {
    const mapped = mapQuickBooksPurchaseOrder({
      Id: '123',
      DocNumber: 'PO-1001',
      VendorRef: { name: 'Acme Supply' },
      TxnDate: '2026-01-10',
      POStatus: 'Open',
      TotalAmt: 52.5,
      MetaData: { LastUpdatedTime: '2026-01-11T12:00:00Z' },
      Line: [
        {
          Id: 'line-1',
          Description: 'M8 Bolt',
          Amount: 42,
          ItemBasedExpenseLineDetail: {
            Qty: 6,
            UnitPrice: 7,
            ItemRef: { value: 'SKU-1', name: 'M8 Bolt' },
          },
        },
      ],
    });

    expect(mapped.externalId).toBe('123');
    expect(mapped.externalNumber).toBe('PO-1001');
    expect(mapped.supplier).toBe('Acme Supply');
    expect(mapped.totalAmount).toBe(52.5);
    expect(mapped.items).toHaveLength(1);
    expect(mapped.items[0].externalLineId).toBe('line-1');
    expect(mapped.items[0].quantity).toBe(6);
    expect(mapped.items[0].unitPrice).toBe(7);
    expect(mapped.updatedAt).toBe('2026-01-11T12:00:00.000Z');
  });

  it('maps Xero purchase orders with /Date(...) values', () => {
    const mapped = mapXeroPurchaseOrder({
      PurchaseOrderID: 'po-uuid',
      PurchaseOrderNumber: 'PO-900',
      Contact: { Name: 'Fastenal' },
      Status: 'AUTHORISED',
      Total: 130.25,
      Date: '/Date(1764806400000+0000)/',
      UpdatedDateUTC: '/Date(1764892800000+0000)/',
      LineItems: [
        {
          LineItemID: 'li-1',
          Description: 'Cutting fluid',
          Quantity: 2,
          UnitAmount: 15,
          LineAmount: 30,
          ItemCode: 'CF-12',
        },
      ],
    });

    expect(mapped.externalId).toBe('po-uuid');
    expect(mapped.externalNumber).toBe('PO-900');
    expect(mapped.supplier).toBe('Fastenal');
    expect(mapped.orderDate).toBe('2025-12-04T00:00:00.000Z');
    expect(mapped.updatedAt).toBe('2025-12-05T00:00:00.000Z');
    expect(mapped.items[0].itemCode).toBe('CF-12');
  });

  it('produces deterministic order IDs for idempotent upserts', () => {
    const first = buildProviderOrderId('user-1', 'quickbooks', 'realm-1', 'po-1');
    const second = buildProviderOrderId('user-1', 'quickbooks', 'realm-1', 'po-1');
    const third = buildProviderOrderId('user-1', 'xero', 'tenant-1', 'po-1');

    expect(first).toBe(second);
    expect(first).not.toBe(third);
  });

  it('flags deleted and voided statuses', () => {
    expect(isDeletedPurchaseOrderStatus('DELETED')).toBe(true);
    expect(isDeletedPurchaseOrderStatus('VOIDED')).toBe(true);
    expect(isDeletedPurchaseOrderStatus('AUTHORISED')).toBe(false);
  });

  it('retries QuickBooks queries after transient throttling and succeeds', async () => {
    vi.useFakeTimers();
    const fetchFn = vi
      .fn<typeof fetch>()
      .mockResolvedValueOnce(new Response(JSON.stringify({ Fault: {} }), { status: 429 }))
      .mockResolvedValueOnce(new Response(JSON.stringify({
        QueryResponse: {
          PurchaseOrder: [
            {
              Id: '123',
              DocNumber: 'PO-1001',
              VendorRef: { name: 'Acme Supply' },
              POStatus: 'Open',
              TotalAmt: 10,
              MetaData: { LastUpdatedTime: '2026-01-11T12:00:00Z' },
              Line: [],
            },
          ],
        },
      }), { status: 200 }));

    try {
      const adapter = new QuickBooksAdapter({ fetchFn });
      const resultPromise = adapter.listIncremental({
        realmId: 'realm-1',
        accessToken: 'token',
        changedSince: '2026-01-01T00:00:00.000Z',
        startPosition: 1,
        maxResults: 50,
      });

      await vi.runAllTimersAsync();
      const result = await resultPromise;

      expect(fetchFn).toHaveBeenCalledTimes(2);
      expect(result.orders).toHaveLength(1);
      expect(result.orders[0].externalNumber).toBe('PO-1001');
    } finally {
      vi.useRealTimers();
    }
  });

  it('retries Xero requests after transient 5xx and succeeds', async () => {
    vi.useFakeTimers();
    const fetchFn = vi
      .fn<typeof fetch>()
      .mockResolvedValueOnce(new Response(JSON.stringify({ Message: 'try later' }), { status: 503 }))
      .mockResolvedValueOnce(new Response(JSON.stringify({
        PurchaseOrders: [
          {
            PurchaseOrderID: 'po-uuid',
            PurchaseOrderNumber: 'PO-900',
            Contact: { Name: 'Fastenal' },
            Status: 'AUTHORISED',
            Total: 130.25,
            UpdatedDateUTC: '/Date(1764892800000+0000)/',
            LineItems: [],
          },
        ],
      }), { status: 200 }));

    try {
      const adapter = new XeroAdapter({ fetchFn });
      const resultPromise = adapter.listPurchaseOrders({
        tenantId: 'tenant-1',
        accessToken: 'token',
        page: 1,
        pageSize: 100,
        ifModifiedSince: '2026-01-01T00:00:00.000Z',
      });

      await vi.runAllTimersAsync();
      const result = await resultPromise;

      expect(fetchFn).toHaveBeenCalledTimes(2);
      expect(result.orders).toHaveLength(1);
      expect(result.orders[0].externalId).toBe('po-uuid');
    } finally {
      vi.useRealTimers();
    }
  });
});

```

### `server/src/services/integrations/providers/quickbooksAdapter.ts`

```typescript
import { CanonicalLineItem, CanonicalPurchaseOrder } from '../types.js';
import { IntegrationAuthError, parseJsonResponse } from '../errors.js';

const QUICKBOOKS_API_BASE_URL = 'https://quickbooks.api.intuit.com';

export interface QuickBooksAdapterOptions {
  fetchFn?: typeof fetch;
}

export interface QuickBooksListResult {
  orders: CanonicalPurchaseOrder[];
  hasMore: boolean;
  nextStartPosition: number;
  apiCalls: number;
  maxUpdatedAt?: string;
}

interface QuickBooksQueryParams {
  realmId: string;
  accessToken: string;
  query: string;
}

interface QuickBooksBackfillParams {
  realmId: string;
  accessToken: string;
  startDate: string;
  endDate: string;
  startPosition: number;
  maxResults: number;
}

interface QuickBooksIncrementalParams {
  realmId: string;
  accessToken: string;
  changedSince: string;
  startPosition: number;
  maxResults: number;
}

function parseQuickBooksDate(value: unknown): string | undefined {
  if (typeof value !== 'string' || !value.trim()) return undefined;
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) return undefined;
  return parsed.toISOString();
}

function pickLineName(line: Record<string, unknown>, detail: Record<string, unknown> | undefined): string {
  if (typeof line.Description === 'string' && line.Description.trim()) return line.Description;
  const itemRef = detail?.ItemRef as Record<string, unknown> | undefined;
  if (typeof itemRef?.name === 'string' && itemRef.name.trim()) return itemRef.name;
  if (typeof itemRef?.value === 'string' && itemRef.value.trim()) return itemRef.value;
  return 'Line item';
}

function toNumber(value: unknown): number | undefined {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string' && value.trim()) {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return undefined;
}

export function mapQuickBooksPurchaseOrder(raw: Record<string, unknown>): CanonicalPurchaseOrder {
  const lines = Array.isArray(raw.Line) ? raw.Line : [];
  const mappedLines: CanonicalLineItem[] = lines
    .filter((line): line is Record<string, unknown> => !!line && typeof line === 'object')
    .map((line) => {
      const detail =
        (line.ItemBasedExpenseLineDetail as Record<string, unknown> | undefined)
        || (line.SalesItemLineDetail as Record<string, unknown> | undefined)
        || undefined;
      const itemRef = detail?.ItemRef as Record<string, unknown> | undefined;
      const quantity = toNumber(detail?.Qty) ?? 1;
      const unitPrice = toNumber(detail?.UnitPrice);
      const totalPrice = toNumber(line.Amount) ?? (unitPrice !== undefined ? unitPrice * quantity : undefined);

      return {
        externalLineId: String(line.Id || `${raw.Id || raw.DocNumber || 'po'}:${Math.random().toString(36).slice(2, 8)}`),
        name: pickLineName(line, detail),
        quantity,
        unit: typeof detail?.Unit === 'string' ? detail.Unit : 'ea',
        unitPrice,
        totalPrice,
        sku: typeof itemRef?.value === 'string' ? itemRef.value : undefined,
        itemCode: typeof itemRef?.name === 'string' ? itemRef.name : undefined,
      };
    });

  const meta = (raw.MetaData as Record<string, unknown> | undefined) || {};

  return {
    externalId: String(raw.Id || raw.DocNumber || ''),
    externalNumber: String(raw.DocNumber || raw.Id || ''),
    supplier: String((raw.VendorRef as Record<string, unknown> | undefined)?.name || 'Unknown Supplier'),
    orderDate: parseQuickBooksDate(raw.TxnDate),
    status: String(raw.POStatus || raw.TxnStatus || raw.PrivateNote || 'UNKNOWN'),
    totalAmount: toNumber(raw.TotalAmt),
    updatedAt: parseQuickBooksDate(meta.LastUpdatedTime),
    items: mappedLines,
    raw,
  };
}

export class QuickBooksAdapter {
  private readonly fetchFn: typeof fetch;

  constructor(options: QuickBooksAdapterOptions = {}) {
    this.fetchFn = options.fetchFn || fetch;
  }

  private async fetchWithBackoff(url: string, accessToken: string): Promise<Response> {
    let lastResponse: Response | undefined;
    for (let attempt = 0; attempt < 3; attempt += 1) {
      const response = await this.fetchFn(url, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: 'application/json',
        },
      });

      if (response.status !== 429 && response.status < 500) {
        return response;
      }

      lastResponse = response;
      if (attempt < 2) {
        const delayMs = Math.pow(2, attempt) * 250 + Math.floor(Math.random() * 100);
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    }

    return lastResponse!;
  }

  async listBackfill(params: QuickBooksBackfillParams): Promise<QuickBooksListResult> {
    const where = `TxnDate >= '${params.startDate}' AND TxnDate <= '${params.endDate}'`;
    const query = `SELECT * FROM PurchaseOrder WHERE ${where} STARTPOSITION ${params.startPosition} MAXRESULTS ${params.maxResults}`;
    return this.queryPurchaseOrders({ realmId: params.realmId, accessToken: params.accessToken, query });
  }

  async listIncremental(params: QuickBooksIncrementalParams): Promise<QuickBooksListResult> {
    const where = `MetaData.LastUpdatedTime >= '${params.changedSince}'`;
    const query = `SELECT * FROM PurchaseOrder WHERE ${where} STARTPOSITION ${params.startPosition} MAXRESULTS ${params.maxResults}`;
    return this.queryPurchaseOrders({ realmId: params.realmId, accessToken: params.accessToken, query });
  }

  async listIncrementalViaCdc(params: {
    realmId: string;
    accessToken: string;
    changedSince: string;
  }): Promise<{ orders: CanonicalPurchaseOrder[]; apiCalls: number; maxUpdatedAt?: string }> {
    const url = new URL(`${QUICKBOOKS_API_BASE_URL}/v3/company/${encodeURIComponent(params.realmId)}/cdc`);
    url.searchParams.set('entities', 'PurchaseOrder');
    url.searchParams.set('changedSince', params.changedSince);
    url.searchParams.set('minorversion', '75');

    const response = await this.fetchWithBackoff(url.toString(), params.accessToken);

    const payload = await parseJsonResponse(response);
    if (response.status === 401) {
      throw new IntegrationAuthError('QUICKBOOKS_UNAUTHORIZED', 'QuickBooks token is unauthorized.');
    }
    if (!response.ok) {
      throw new Error(`QuickBooks CDC request failed (${response.status}).`);
    }

    const queryResponse = payload?.CDCResponse?.QueryResponse;
    const normalized = Array.isArray(queryResponse) ? queryResponse : [queryResponse].filter(Boolean);
    const rawOrders: Record<string, unknown>[] = [];

    for (const resultSet of normalized) {
      const purchaseOrders = (resultSet?.PurchaseOrder || []) as Record<string, unknown>[];
      if (Array.isArray(purchaseOrders)) {
        rawOrders.push(...purchaseOrders);
      }
    }

    const mapped = rawOrders.map(mapQuickBooksPurchaseOrder);
    const maxUpdatedAt = mapped
      .map((order) => order.updatedAt)
      .filter((value): value is string => !!value)
      .sort()
      .pop();

    return {
      orders: mapped,
      apiCalls: 1,
      maxUpdatedAt,
    };
  }

  async getPurchaseOrdersByIds(params: {
    realmId: string;
    accessToken: string;
    externalIds: string[];
  }): Promise<{ orders: CanonicalPurchaseOrder[]; apiCalls: number; maxUpdatedAt?: string }> {
    const ids = Array.from(new Set(params.externalIds.map((id) => id.trim()).filter(Boolean)));
    if (!ids.length) {
      return { orders: [], apiCalls: 0 };
    }

    const where = ids.length === 1
      ? `Id = '${ids[0].replace(/'/g, "''")}'`
      : `Id IN (${ids.map((id) => `'${id.replace(/'/g, "''")}'`).join(',')})`;

    const query = `SELECT * FROM PurchaseOrder WHERE ${where}`;
    const result = await this.queryPurchaseOrders({ realmId: params.realmId, accessToken: params.accessToken, query });

    return {
      orders: result.orders,
      apiCalls: result.apiCalls,
      maxUpdatedAt: result.maxUpdatedAt,
    };
  }

  private async queryPurchaseOrders(params: QuickBooksQueryParams): Promise<QuickBooksListResult> {
    const url = new URL(`${QUICKBOOKS_API_BASE_URL}/v3/company/${encodeURIComponent(params.realmId)}/query`);
    url.searchParams.set('query', params.query);
    url.searchParams.set('minorversion', '75');

    const response = await this.fetchWithBackoff(url.toString(), params.accessToken);

    const payload = await parseJsonResponse(response);

    if (response.status === 401) {
      throw new IntegrationAuthError('QUICKBOOKS_UNAUTHORIZED', 'QuickBooks token is unauthorized.');
    }

    if (!response.ok) {
      throw new Error(`QuickBooks query failed (${response.status}).`);
    }

    const rawOrders = Array.isArray(payload?.QueryResponse?.PurchaseOrder)
      ? payload.QueryResponse.PurchaseOrder as Record<string, unknown>[]
      : [];

    const mapped = rawOrders.map(mapQuickBooksPurchaseOrder);
    const maxUpdatedAt = mapped
      .map((order) => order.updatedAt)
      .filter((value): value is string => !!value)
      .sort()
      .pop();

    const maxResultsMatch = params.query.match(/MAXRESULTS\s+(\d+)/i);
    const requestedPageSize = maxResultsMatch ? Number(maxResultsMatch[1]) : rawOrders.length;

    return {
      orders: mapped,
      hasMore: rawOrders.length > 0 && rawOrders.length >= requestedPageSize,
      nextStartPosition: (() => {
        const match = params.query.match(/STARTPOSITION\s+(\d+)/i);
        const startPosition = match ? Number(match[1]) : 1;
        return startPosition + rawOrders.length;
      })(),
      apiCalls: 1,
      maxUpdatedAt,
    };
  }
}

```

### `server/src/services/integrations/providers/xeroAdapter.ts`

```typescript
import { CanonicalLineItem, CanonicalPurchaseOrder } from '../types.js';
import { IntegrationAuthError, parseJsonResponse } from '../errors.js';

const XERO_ACCOUNTING_BASE_URL = 'https://api.xero.com/api.xro/2.0';

export interface XeroAdapterOptions {
  fetchFn?: typeof fetch;
}

export interface XeroListResult {
  orders: CanonicalPurchaseOrder[];
  hasMore: boolean;
  nextPage: number;
  apiCalls: number;
  maxUpdatedAt?: string;
}

interface XeroListParams {
  tenantId: string;
  accessToken: string;
  page: number;
  pageSize: number;
  dateFrom?: string;
  dateTo?: string;
  ifModifiedSince?: string;
}

function parseXeroDate(value: unknown): string | undefined {
  if (typeof value !== 'string' || !value.trim()) return undefined;

  const msDate = value.match(/^\/Date\((\d+)(?:[+-]\d+)?\)\/$/);
  if (msDate) {
    const millis = Number(msDate[1]);
    if (Number.isFinite(millis)) {
      return new Date(millis).toISOString();
    }
  }

  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) return undefined;
  return parsed.toISOString();
}

function toNumber(value: unknown): number | undefined {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string' && value.trim()) {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return undefined;
}

export function mapXeroPurchaseOrder(raw: Record<string, unknown>): CanonicalPurchaseOrder {
  const lines = Array.isArray(raw.LineItems) ? raw.LineItems : [];

  const mappedLines: CanonicalLineItem[] = lines
    .filter((line): line is Record<string, unknown> => !!line && typeof line === 'object')
    .map((line, index) => {
      const quantity = toNumber(line.Quantity) ?? 1;
      const unitPrice = toNumber(line.UnitAmount);
      const totalPrice = toNumber(line.LineAmount) ?? (unitPrice !== undefined ? unitPrice * quantity : undefined);
      const item = (line.Item as Record<string, unknown> | undefined) || undefined;

      return {
        externalLineId: String(line.LineItemID || `${raw.PurchaseOrderID || raw.PurchaseOrderNumber || 'line'}:${index + 1}`),
        name: String(line.Description || item?.Name || item?.Code || 'Line item'),
        quantity,
        unit: typeof line.Unit === 'string' ? line.Unit : 'ea',
        unitPrice,
        totalPrice,
        sku: typeof item?.Code === 'string' ? item.Code : undefined,
        itemCode: typeof line.ItemCode === 'string' ? line.ItemCode : typeof item?.Code === 'string' ? item.Code : undefined,
      };
    });

  return {
    externalId: String(raw.PurchaseOrderID || raw.PurchaseOrderNumber || ''),
    externalNumber: String(raw.PurchaseOrderNumber || raw.PurchaseOrderID || ''),
    supplier: String((raw.Contact as Record<string, unknown> | undefined)?.Name || 'Unknown Supplier'),
    orderDate: parseXeroDate(raw.DateString || raw.Date),
    status: String(raw.Status || 'UNKNOWN'),
    totalAmount: toNumber(raw.Total),
    updatedAt: parseXeroDate(raw.UpdatedDateUTC),
    items: mappedLines,
    raw,
  };
}

export class XeroAdapter {
  private readonly fetchFn: typeof fetch;

  constructor(options: XeroAdapterOptions = {}) {
    this.fetchFn = options.fetchFn || fetch;
  }

  private async fetchWithBackoff(url: string, headers: Record<string, string>): Promise<Response> {
    let lastResponse: Response | undefined;
    for (let attempt = 0; attempt < 3; attempt += 1) {
      const response = await this.fetchFn(url, { headers });

      if (response.status !== 429 && response.status < 500) {
        return response;
      }

      lastResponse = response;
      if (attempt < 2) {
        const delayMs = Math.pow(2, attempt) * 250 + Math.floor(Math.random() * 100);
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    }

    return lastResponse!;
  }

  async listPurchaseOrders(params: XeroListParams): Promise<XeroListResult> {
    const url = new URL(`${XERO_ACCOUNTING_BASE_URL}/PurchaseOrders`);
    url.searchParams.set('page', String(params.page));
    url.searchParams.set('pageSize', String(params.pageSize));
    if (params.dateFrom) url.searchParams.set('DateFrom', params.dateFrom);
    if (params.dateTo) url.searchParams.set('DateTo', params.dateTo);

    const headers: Record<string, string> = {
      Authorization: `Bearer ${params.accessToken}`,
      'xero-tenant-id': params.tenantId,
      Accept: 'application/json',
    };

    if (params.ifModifiedSince) {
      headers['If-Modified-Since'] = new Date(params.ifModifiedSince).toUTCString();
    }

    const response = await this.fetchWithBackoff(url.toString(), headers);
    const payload = await parseJsonResponse(response);

    if (response.status === 401) {
      throw new IntegrationAuthError('XERO_UNAUTHORIZED', 'Xero token is unauthorized.');
    }

    if (!response.ok) {
      throw new Error(`Xero purchase order request failed (${response.status}).`);
    }

    const rawOrders = Array.isArray(payload?.PurchaseOrders)
      ? payload.PurchaseOrders as Record<string, unknown>[]
      : [];

    const orders = rawOrders.map(mapXeroPurchaseOrder);
    const maxUpdatedAt = orders
      .map((order) => order.updatedAt)
      .filter((value): value is string => !!value)
      .sort()
      .pop();

    return {
      orders,
      hasMore: rawOrders.length >= params.pageSize,
      nextPage: params.page + 1,
      apiCalls: 1,
      maxUpdatedAt,
    };
  }
}

```

### `server/src/services/integrations/quickbooksOAuth.ts`

```typescript
import { asDateFromExpiresIn, IntegrationAuthError, parseJsonResponse, requireEnv } from './errors.js';

const QUICKBOOKS_OAUTH_AUTHORIZE_URL = 'https://appcenter.intuit.com/connect/oauth2';
const QUICKBOOKS_OAUTH_TOKEN_URL = 'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer';
const QUICKBOOKS_API_BASE_URL = 'https://quickbooks.api.intuit.com';
const QUICKBOOKS_SCOPES = ['com.intuit.quickbooks.accounting'];

export interface QuickBooksTokenPayload {
  accessToken: string;
  refreshToken: string;
  tokenExpiresAt: Date;
  scope?: string;
}

function redirectUri(): string {
  const backendUrl = requireEnv('BACKEND_URL');
  return `${backendUrl.replace(/\/+$/, '')}/api/integrations/quickbooks/callback`;
}

function basicAuthHeader(clientId: string, clientSecret: string): string {
  return `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`;
}

function toTokenPayload(payload: any): QuickBooksTokenPayload {
  if (!payload?.access_token || !payload?.refresh_token) {
    throw new IntegrationAuthError('QUICKBOOKS_TOKEN_INVALID', 'QuickBooks token response is missing required fields.');
  }

  return {
    accessToken: payload.access_token,
    refreshToken: payload.refresh_token,
    tokenExpiresAt: asDateFromExpiresIn(payload.expires_in),
    scope: typeof payload.scope === 'string' ? payload.scope : undefined,
  };
}

export function buildQuickBooksAuthUrl(state: string): string {
  const clientId = requireEnv('QUICKBOOKS_CLIENT_ID');
  const params = new URLSearchParams({
    client_id: clientId,
    response_type: 'code',
    scope: QUICKBOOKS_SCOPES.join(' '),
    redirect_uri: redirectUri(),
    state,
  });
  return `${QUICKBOOKS_OAUTH_AUTHORIZE_URL}?${params.toString()}`;
}

export async function exchangeQuickBooksCodeForTokens(code: string): Promise<QuickBooksTokenPayload> {
  const clientId = requireEnv('QUICKBOOKS_CLIENT_ID');
  const clientSecret = requireEnv('QUICKBOOKS_CLIENT_SECRET');

  const body = new URLSearchParams({
    grant_type: 'authorization_code',
    code,
    redirect_uri: redirectUri(),
  });

  const response = await fetch(QUICKBOOKS_OAUTH_TOKEN_URL, {
    method: 'POST',
    headers: {
      Authorization: basicAuthHeader(clientId, clientSecret),
      'Content-Type': 'application/x-www-form-urlencoded',
      Accept: 'application/json',
    },
    body,
  });

  const payload = await parseJsonResponse(response);
  if (!response.ok) {
    throw new IntegrationAuthError(
      'QUICKBOOKS_TOKEN_EXCHANGE_FAILED',
      payload?.error_description || payload?.error || `QuickBooks token exchange failed (${response.status}).`,
    );
  }

  return toTokenPayload(payload);
}

export async function refreshQuickBooksTokens(refreshToken: string): Promise<QuickBooksTokenPayload> {
  const clientId = requireEnv('QUICKBOOKS_CLIENT_ID');
  const clientSecret = requireEnv('QUICKBOOKS_CLIENT_SECRET');

  const body = new URLSearchParams({
    grant_type: 'refresh_token',
    refresh_token: refreshToken,
  });

  const response = await fetch(QUICKBOOKS_OAUTH_TOKEN_URL, {
    method: 'POST',
    headers: {
      Authorization: basicAuthHeader(clientId, clientSecret),
      'Content-Type': 'application/x-www-form-urlencoded',
      Accept: 'application/json',
    },
    body,
  });

  const payload = await parseJsonResponse(response);
  if (!response.ok) {
    throw new IntegrationAuthError(
      'QUICKBOOKS_TOKEN_REFRESH_FAILED',
      payload?.error_description || payload?.error || `QuickBooks token refresh failed (${response.status}).`,
    );
  }

  return toTokenPayload(payload);
}

export async function fetchQuickBooksCompanyName(realmId: string, accessToken: string): Promise<string | undefined> {
  const response = await fetch(
    `${QUICKBOOKS_API_BASE_URL}/v3/company/${encodeURIComponent(realmId)}/companyinfo/${encodeURIComponent(realmId)}?minorversion=75`,
    {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: 'application/json',
      },
    },
  );

  const payload = await parseJsonResponse(response);
  if (!response.ok) {
    return undefined;
  }

  return payload?.CompanyInfo?.CompanyName || payload?.QueryResponse?.CompanyInfo?.[0]?.CompanyName;
}

export async function revokeQuickBooksToken(token: string): Promise<void> {
  const clientId = requireEnv('QUICKBOOKS_CLIENT_ID');
  const clientSecret = requireEnv('QUICKBOOKS_CLIENT_SECRET');

  const body = new URLSearchParams({
    token,
  });

  const response = await fetch('https://developer.api.intuit.com/v2/oauth2/tokens/revoke', {
    method: 'POST',
    headers: {
      Authorization: basicAuthHeader(clientId, clientSecret),
      'Content-Type': 'application/x-www-form-urlencoded',
      Accept: 'application/json',
    },
    body,
  });

  if (!response.ok) {
    const payload = await parseJsonResponse(response);
    throw new IntegrationAuthError(
      'QUICKBOOKS_TOKEN_REVOKE_FAILED',
      payload?.error_description || payload?.error || `QuickBooks token revoke failed (${response.status}).`,
    );
  }
}

```

### `server/src/services/integrations/store.ts`

```typescript
import { query } from '../../db/index.js';
import {
  IntegrationConnectionSummary,
  IntegrationProvider,
  ProviderConnection,
  ProviderSyncRun,
  ProviderSyncState,
  SyncRunCounters,
  SyncRunStatus,
  SyncTrigger,
} from './types.js';

interface ProviderConnectionRow {
  id: string;
  user_id: string;
  provider: IntegrationProvider;
  tenant_id: string;
  tenant_name: string | null;
  access_token_encrypted: string;
  refresh_token_encrypted: string;
  token_expires_at: string | Date;
  scope: string | null;
  status: ProviderConnection['status'];
  metadata: Record<string, unknown> | null;
  created_at: string | Date;
  updated_at: string | Date;
}

interface ProviderSyncStateRow {
  connection_id: string;
  backfill_started_at: string | Date | null;
  backfill_completed_at: string | Date | null;
  last_cursor_utc: string | Date | null;
  cursor_payload: Record<string, unknown> | null;
  last_successful_sync_at: string | Date | null;
  last_error: string | null;
  updated_at: string | Date;
}

interface ProviderSyncRunRow {
  id: string;
  connection_id: string;
  trigger: SyncTrigger;
  status: SyncRunStatus;
  orders_upserted: number;
  orders_deleted: number;
  items_upserted: number;
  api_calls: number;
  started_at: string | Date;
  finished_at: string | Date | null;
  error: string | null;
}

interface ConnectionSummaryRow {
  id: string;
  provider: IntegrationProvider;
  tenant_id: string;
  tenant_name: string | null;
  status: ProviderConnection['status'];
  token_expires_at: string | Date;
  created_at: string | Date;
  updated_at: string | Date;
  run_id: string | null;
  run_status: SyncRunStatus | null;
  run_trigger: SyncTrigger | null;
  run_started_at: string | Date | null;
  run_finished_at: string | Date | null;
  run_error: string | null;
}

export interface UpsertProviderConnectionInput {
  userId: string;
  provider: IntegrationProvider;
  tenantId: string;
  tenantName?: string;
  accessTokenEncrypted: string;
  refreshTokenEncrypted: string;
  tokenExpiresAt: Date;
  scope?: string;
  metadata?: Record<string, unknown>;
  status?: ProviderConnection['status'];
}

interface UpdateProviderConnectionTokensInput {
  id: string;
  accessTokenEncrypted: string;
  refreshTokenEncrypted: string;
  tokenExpiresAt: Date;
  scope?: string;
  status?: ProviderConnection['status'];
}

export interface UpsertSyncStateInput {
  connectionId: string;
  backfillStartedAt?: Date;
  backfillCompletedAt?: Date;
  lastCursorUtc?: Date;
  cursorPayload?: Record<string, unknown>;
  lastSuccessfulSyncAt?: Date;
  lastError?: string | null;
}

function asDate(value: string | Date): Date {
  return value instanceof Date ? value : new Date(value);
}

function mapConnection(row: ProviderConnectionRow): ProviderConnection {
  return {
    id: row.id,
    userId: row.user_id,
    provider: row.provider,
    tenantId: row.tenant_id,
    tenantName: row.tenant_name || undefined,
    accessTokenEncrypted: row.access_token_encrypted,
    refreshTokenEncrypted: row.refresh_token_encrypted,
    tokenExpiresAt: asDate(row.token_expires_at),
    scope: row.scope || undefined,
    status: row.status,
    metadata: row.metadata || undefined,
    createdAt: asDate(row.created_at),
    updatedAt: asDate(row.updated_at),
  };
}

function mapSyncState(row: ProviderSyncStateRow): ProviderSyncState {
  return {
    connectionId: row.connection_id,
    backfillStartedAt: row.backfill_started_at ? asDate(row.backfill_started_at) : undefined,
    backfillCompletedAt: row.backfill_completed_at ? asDate(row.backfill_completed_at) : undefined,
    lastCursorUtc: row.last_cursor_utc ? asDate(row.last_cursor_utc) : undefined,
    cursorPayload: row.cursor_payload || undefined,
    lastSuccessfulSyncAt: row.last_successful_sync_at ? asDate(row.last_successful_sync_at) : undefined,
    lastError: row.last_error || undefined,
    updatedAt: asDate(row.updated_at),
  };
}

function mapSyncRun(row: ProviderSyncRunRow): ProviderSyncRun {
  return {
    id: row.id,
    connectionId: row.connection_id,
    trigger: row.trigger,
    status: row.status,
    ordersUpserted: Number(row.orders_upserted || 0),
    ordersDeleted: Number(row.orders_deleted || 0),
    itemsUpserted: Number(row.items_upserted || 0),
    apiCalls: Number(row.api_calls || 0),
    startedAt: asDate(row.started_at),
    finishedAt: row.finished_at ? asDate(row.finished_at) : undefined,
    error: row.error || undefined,
  };
}

export async function upsertProviderConnection(input: UpsertProviderConnectionInput): Promise<ProviderConnection> {
  const result = await query<ProviderConnectionRow>(
    `
      INSERT INTO provider_connections (
        user_id,
        provider,
        tenant_id,
        tenant_name,
        access_token_encrypted,
        refresh_token_encrypted,
        token_expires_at,
        scope,
        status,
        metadata
      )
      VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)
      ON CONFLICT (user_id, provider)
      DO UPDATE SET
        tenant_id = EXCLUDED.tenant_id,
        tenant_name = EXCLUDED.tenant_name,
        access_token_encrypted = EXCLUDED.access_token_encrypted,
        refresh_token_encrypted = EXCLUDED.refresh_token_encrypted,
        token_expires_at = EXCLUDED.token_expires_at,
        scope = EXCLUDED.scope,
        status = EXCLUDED.status,
        metadata = EXCLUDED.metadata,
        updated_at = NOW()
      RETURNING *
    `,
    [
      input.userId,
      input.provider,
      input.tenantId,
      input.tenantName || null,
      input.accessTokenEncrypted,
      input.refreshTokenEncrypted,
      input.tokenExpiresAt,
      input.scope || null,
      input.status || 'connected',
      input.metadata ? JSON.stringify(input.metadata) : null,
    ],
  );

  return mapConnection(result.rows[0]);
}

export async function updateProviderConnectionTokens(
  input: UpdateProviderConnectionTokensInput,
): Promise<ProviderConnection | null> {
  const result = await query<ProviderConnectionRow>(
    `
      UPDATE provider_connections
      SET
        access_token_encrypted = $2,
        refresh_token_encrypted = $3,
        token_expires_at = $4,
        scope = COALESCE($5, scope),
        status = COALESCE($6, status),
        updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `,
    [
      input.id,
      input.accessTokenEncrypted,
      input.refreshTokenEncrypted,
      input.tokenExpiresAt,
      input.scope || null,
      input.status || null,
    ],
  );

  if (!result.rows.length) return null;
  return mapConnection(result.rows[0]);
}

export async function markProviderConnectionStatus(
  connectionId: string,
  status: ProviderConnection['status'],
): Promise<void> {
  await query(
    `UPDATE provider_connections SET status = $2, updated_at = NOW() WHERE id = $1`,
    [connectionId, status],
  );
}

export async function getProviderConnectionByIdForUser(
  connectionId: string,
  userId: string,
): Promise<ProviderConnection | null> {
  const result = await query<ProviderConnectionRow>(
    `SELECT * FROM provider_connections WHERE id = $1 AND user_id = $2`,
    [connectionId, userId],
  );
  if (!result.rows.length) return null;
  return mapConnection(result.rows[0]);
}

export async function getProviderConnectionByProviderTenant(
  provider: IntegrationProvider,
  tenantId: string,
): Promise<ProviderConnection | null> {
  const result = await query<ProviderConnectionRow>(
    `SELECT * FROM provider_connections WHERE provider = $1 AND tenant_id = $2 AND status = 'connected'`,
    [provider, tenantId],
  );
  if (!result.rows.length) return null;
  return mapConnection(result.rows[0]);
}

export async function listProviderConnectionsForUser(
  userId: string,
): Promise<IntegrationConnectionSummary[]> {
  const result = await query<ConnectionSummaryRow>(
    `
      SELECT
        pc.id,
        pc.provider,
        pc.tenant_id,
        pc.tenant_name,
        pc.status,
        pc.token_expires_at,
        pc.created_at,
        pc.updated_at,
        latest.id AS run_id,
        latest.status AS run_status,
        latest."trigger" AS run_trigger,
        latest.started_at AS run_started_at,
        latest.finished_at AS run_finished_at,
        latest.error AS run_error
      FROM provider_connections pc
      LEFT JOIN LATERAL (
        SELECT id, status, "trigger", started_at, finished_at, error
        FROM provider_sync_runs
        WHERE connection_id = pc.id
        ORDER BY started_at DESC
        LIMIT 1
      ) latest ON true
      WHERE pc.user_id = $1
      ORDER BY pc.provider ASC
    `,
    [userId],
  );

  return result.rows.map((row) => ({
    id: row.id,
    provider: row.provider,
    tenantId: row.tenant_id,
    tenantName: row.tenant_name || undefined,
    status: row.status,
    tokenExpiresAt: asDate(row.token_expires_at),
    createdAt: asDate(row.created_at),
    updatedAt: asDate(row.updated_at),
    lastRun: row.run_id
      ? {
        id: row.run_id,
        status: row.run_status!,
        trigger: row.run_trigger!,
        startedAt: asDate(row.run_started_at!),
        finishedAt: row.run_finished_at ? asDate(row.run_finished_at) : undefined,
        error: row.run_error || undefined,
      }
      : undefined,
  }));
}

export async function listActiveProviderConnections(): Promise<ProviderConnection[]> {
  const result = await query<ProviderConnectionRow>(
    `SELECT * FROM provider_connections WHERE status = 'connected' ORDER BY updated_at ASC`,
  );
  return result.rows.map(mapConnection);
}

export async function deleteProviderConnectionForUser(connectionId: string, userId: string): Promise<boolean> {
  const result = await query(
    `DELETE FROM provider_connections WHERE id = $1 AND user_id = $2`,
    [connectionId, userId],
  );
  return (result.rowCount || 0) > 0;
}

export async function createProviderSyncRun(
  connectionId: string,
  trigger: SyncTrigger,
): Promise<ProviderSyncRun> {
  const result = await query<ProviderSyncRunRow>(
    `
      INSERT INTO provider_sync_runs (connection_id, "trigger", status)
      VALUES ($1, $2, 'running')
      RETURNING *
    `,
    [connectionId, trigger],
  );

  return mapSyncRun(result.rows[0]);
}

export async function completeProviderSyncRun(
  runId: string,
  status: Exclude<SyncRunStatus, 'running'>,
  counters: SyncRunCounters,
  error?: string,
): Promise<void> {
  await query(
    `
      UPDATE provider_sync_runs
      SET
        status = $2,
        orders_upserted = $3,
        orders_deleted = $4,
        items_upserted = $5,
        api_calls = $6,
        error = $7,
        finished_at = NOW()
      WHERE id = $1
    `,
    [
      runId,
      status,
      counters.ordersUpserted,
      counters.ordersDeleted,
      counters.itemsUpserted,
      counters.apiCalls,
      error || null,
    ],
  );
}

export async function listProviderSyncRunsForConnection(
  connectionId: string,
  userId: string,
  limit = 20,
): Promise<ProviderSyncRun[]> {
  const result = await query<ProviderSyncRunRow>(
    `
      SELECT runs.*
      FROM provider_sync_runs runs
      JOIN provider_connections conn ON conn.id = runs.connection_id
      WHERE runs.connection_id = $1 AND conn.user_id = $2
      ORDER BY runs.started_at DESC
      LIMIT $3
    `,
    [connectionId, userId, limit],
  );

  return result.rows.map(mapSyncRun);
}

export async function getProviderSyncState(connectionId: string): Promise<ProviderSyncState | null> {
  const result = await query<ProviderSyncStateRow>(
    `SELECT * FROM provider_sync_state WHERE connection_id = $1`,
    [connectionId],
  );
  if (!result.rows.length) return null;
  return mapSyncState(result.rows[0]);
}

export async function upsertProviderSyncState(input: UpsertSyncStateInput): Promise<void> {
  await query(
    `
      INSERT INTO provider_sync_state (
        connection_id,
        backfill_started_at,
        backfill_completed_at,
        last_cursor_utc,
        cursor_payload,
        last_successful_sync_at,
        last_error
      )
      VALUES ($1,$2,$3,$4,$5,$6,$7)
      ON CONFLICT (connection_id)
      DO UPDATE SET
        backfill_started_at = COALESCE(EXCLUDED.backfill_started_at, provider_sync_state.backfill_started_at),
        backfill_completed_at = COALESCE(EXCLUDED.backfill_completed_at, provider_sync_state.backfill_completed_at),
        last_cursor_utc = COALESCE(EXCLUDED.last_cursor_utc, provider_sync_state.last_cursor_utc),
        cursor_payload = COALESCE(EXCLUDED.cursor_payload, provider_sync_state.cursor_payload),
        last_successful_sync_at = COALESCE(EXCLUDED.last_successful_sync_at, provider_sync_state.last_successful_sync_at),
        last_error = EXCLUDED.last_error,
        updated_at = NOW()
    `,
    [
      input.connectionId,
      input.backfillStartedAt || null,
      input.backfillCompletedAt || null,
      input.lastCursorUtc || null,
      input.cursorPayload ? JSON.stringify(input.cursorPayload) : null,
      input.lastSuccessfulSyncAt || null,
      input.lastError ?? null,
    ],
  );
}

export async function insertWebhookEvent(
  provider: IntegrationProvider,
  providerEventId: string,
  payload: Record<string, unknown>,
  connectionId: string | null,
  signatureValid: boolean,
): Promise<{ inserted: boolean; eventId: string | null }> {
  const inserted = await query<{ id: string }>(
    `
      INSERT INTO provider_webhook_events (provider, provider_event_id, connection_id, signature_valid, payload, status)
      VALUES ($1,$2,$3,$4,$5,'received')
      ON CONFLICT (provider, provider_event_id) DO NOTHING
      RETURNING id
    `,
    [provider, providerEventId, connectionId, signatureValid, JSON.stringify(payload)],
  );

  if (inserted.rows.length) {
    return { inserted: true, eventId: inserted.rows[0].id };
  }

  const existing = await query<{ id: string }>(
    `SELECT id FROM provider_webhook_events WHERE provider = $1 AND provider_event_id = $2`,
    [provider, providerEventId],
  );

  return { inserted: false, eventId: existing.rows[0]?.id || null };
}

export async function markWebhookEventProcessed(
  eventId: string,
  status: 'processed' | 'ignored' | 'failed',
): Promise<void> {
  await query(
    `
      UPDATE provider_webhook_events
      SET status = $2, processed_at = NOW()
      WHERE id = $1
    `,
    [eventId, status],
  );
}

```

### `server/src/services/integrations/syncOrchestrator.test.ts`

```typescript
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { IntegrationAuthError } from './errors.js';

const mocks = vi.hoisted(() => ({
  query: vi.fn(),
  decrypt: vi.fn(),
  encrypt: vi.fn(),
  getProviderConnectionByIdForUser: vi.fn(),
  getProviderConnectionByProviderTenant: vi.fn(),
  getProviderSyncState: vi.fn(),
  markProviderConnectionStatus: vi.fn(),
  upsertProviderSyncState: vi.fn(),
  updateProviderConnectionTokens: vi.fn(),
  createProviderSyncRun: vi.fn(),
  completeProviderSyncRun: vi.fn(),
  refreshQuickBooksTokens: vi.fn(),
  refreshXeroTokens: vi.fn(),
  quickBooksAdapter: {
    listBackfill: vi.fn(),
    listIncrementalViaCdc: vi.fn(),
    listIncremental: vi.fn(),
    getPurchaseOrdersByIds: vi.fn(),
  },
  xeroAdapter: {
    listPurchaseOrders: vi.fn(),
  },
  appLogger: {
    warn: vi.fn(),
    info: vi.fn(),
    debug: vi.fn(),
    error: vi.fn(),
  },
}));

vi.mock('../../db/index.js', () => ({
  query: mocks.query,
}));

vi.mock('../../utils/encryption.js', () => ({
  decrypt: mocks.decrypt,
  encrypt: mocks.encrypt,
}));

vi.mock('./store.js', () => ({
  getProviderConnectionByIdForUser: mocks.getProviderConnectionByIdForUser,
  getProviderConnectionByProviderTenant: mocks.getProviderConnectionByProviderTenant,
  getProviderSyncState: mocks.getProviderSyncState,
  markProviderConnectionStatus: mocks.markProviderConnectionStatus,
  upsertProviderSyncState: mocks.upsertProviderSyncState,
  updateProviderConnectionTokens: mocks.updateProviderConnectionTokens,
  createProviderSyncRun: mocks.createProviderSyncRun,
  completeProviderSyncRun: mocks.completeProviderSyncRun,
}));

vi.mock('./quickbooksOAuth.js', () => ({
  refreshQuickBooksTokens: mocks.refreshQuickBooksTokens,
}));

vi.mock('./xeroOAuth.js', () => ({
  refreshXeroTokens: mocks.refreshXeroTokens,
}));

vi.mock('./providers/quickbooksAdapter.js', () => ({
  QuickBooksAdapter: vi.fn(() => mocks.quickBooksAdapter),
}));

vi.mock('./providers/xeroAdapter.js', () => ({
  XeroAdapter: vi.fn(() => mocks.xeroAdapter),
}));

vi.mock('../../middleware/requestLogger.js', () => ({
  appLogger: mocks.appLogger,
}));

const baseConnection = {
  id: 'conn-1',
  userId: 'user-1',
  provider: 'quickbooks' as const,
  tenantId: 'realm-1',
  tenantName: 'Acme',
  accessTokenEncrypted: 'enc-access',
  refreshTokenEncrypted: 'enc-refresh',
  tokenExpiresAt: new Date(Date.now() + 60 * 60 * 1000),
  status: 'connected' as const,
  createdAt: new Date('2026-01-01T00:00:00.000Z'),
  updatedAt: new Date('2026-01-01T00:00:00.000Z'),
};

const runningRun = {
  id: 'run-1',
  connectionId: 'conn-1',
  trigger: 'manual' as const,
  status: 'running' as const,
  ordersUpserted: 0,
  ordersDeleted: 0,
  itemsUpserted: 0,
  apiCalls: 0,
  startedAt: new Date('2026-01-01T00:00:00.000Z'),
};

const sampleOrder = {
  externalId: 'po-1',
  externalNumber: 'PO-1',
  supplier: 'Acme Supply',
  orderDate: '2026-01-02T00:00:00.000Z',
  status: 'OPEN',
  totalAmount: 42,
  updatedAt: '2026-01-03T00:00:00.000Z',
  items: [
    {
      externalLineId: 'line-1',
      name: 'Bolt',
      quantity: 2,
      unit: 'ea',
      unitPrice: 21,
      totalPrice: 42,
    },
  ],
  raw: {},
};

describe('syncOrchestrator', () => {
  beforeEach(() => {
    vi.clearAllMocks();

    mocks.getProviderConnectionByIdForUser.mockResolvedValue(baseConnection);
    mocks.getProviderConnectionByProviderTenant.mockResolvedValue(baseConnection);
    mocks.createProviderSyncRun.mockResolvedValue(runningRun);
    mocks.decrypt.mockReturnValue('access-token');
    mocks.query.mockResolvedValue({ rows: [], rowCount: 1 });
    mocks.getProviderSyncState.mockResolvedValue({
      connectionId: 'conn-1',
      backfillStartedAt: new Date('2026-01-01T00:00:00.000Z'),
      backfillCompletedAt: new Date('2026-01-01T00:00:00.000Z'),
      lastCursorUtc: new Date('2026-01-01T00:00:00.000Z'),
      cursorPayload: {},
      updatedAt: new Date('2026-01-01T00:00:00.000Z'),
    });

    mocks.quickBooksAdapter.listBackfill.mockResolvedValue({
      orders: [sampleOrder],
      hasMore: false,
      nextStartPosition: 2,
      apiCalls: 1,
      maxUpdatedAt: '2026-01-03T00:00:00.000Z',
    });
    mocks.quickBooksAdapter.listIncrementalViaCdc.mockResolvedValue({
      orders: [sampleOrder],
      apiCalls: 1,
      maxUpdatedAt: '2026-01-03T00:00:00.000Z',
    });
  });

  it('runs backfill sync and upserts orders/items with success counters', async () => {
    mocks.getProviderSyncState.mockResolvedValueOnce(null);

    const { runProviderSyncNow } = await import('./syncOrchestrator.js');
    const result = await runProviderSyncNow('conn-1', 'user-1', 'backfill');

    expect(result.runId).toBe('run-1');
    expect(mocks.quickBooksAdapter.listBackfill).toHaveBeenCalledTimes(1);

    expect(
      mocks.query.mock.calls.some((call) => String(call[0]).includes('INSERT INTO orders')),
    ).toBe(true);
    expect(
      mocks.query.mock.calls.some((call) => String(call[0]).includes('INSERT INTO order_items')),
    ).toBe(true);

    expect(mocks.completeProviderSyncRun).toHaveBeenCalledWith(
      'run-1',
      'success',
      expect.objectContaining({
        ordersUpserted: 1,
        ordersDeleted: 0,
        itemsUpserted: 1,
        apiCalls: 1,
      }),
    );
    expect(mocks.upsertProviderSyncState).toHaveBeenCalledWith(
      expect.objectContaining({
        connectionId: 'conn-1',
        backfillCompletedAt: expect.any(Date),
        lastError: null,
      }),
    );
  });

  it('deletes local order when provider status is void/deleted', async () => {
    mocks.quickBooksAdapter.listIncrementalViaCdc.mockResolvedValueOnce({
      orders: [
        {
          ...sampleOrder,
          status: 'VOIDED',
          items: [],
        },
      ],
      apiCalls: 1,
      maxUpdatedAt: '2026-01-04T00:00:00.000Z',
    });

    const { runProviderSyncNow } = await import('./syncOrchestrator.js');
    await runProviderSyncNow('conn-1', 'user-1', 'manual');

    expect(
      mocks.query.mock.calls.some((call) => String(call[0]).includes('DELETE FROM orders')),
    ).toBe(true);
    expect(mocks.completeProviderSyncRun).toHaveBeenCalledWith(
      'run-1',
      'success',
      expect.objectContaining({
        ordersUpserted: 0,
        ordersDeleted: 1,
        itemsUpserted: 0,
        apiCalls: 1,
      }),
    );
  });

  it('marks connection reauth_required and records failed run on auth error', async () => {
    mocks.getProviderSyncState.mockResolvedValueOnce(null);
    mocks.quickBooksAdapter.listBackfill.mockRejectedValueOnce(
      new IntegrationAuthError('QUICKBOOKS_UNAUTHORIZED', 'QuickBooks token is unauthorized.'),
    );

    const { runProviderSyncNow } = await import('./syncOrchestrator.js');
    await runProviderSyncNow('conn-1', 'user-1', 'backfill');

    expect(mocks.markProviderConnectionStatus).toHaveBeenCalledWith('conn-1', 'reauth_required');
    expect(mocks.upsertProviderSyncState).toHaveBeenCalledWith(
      expect.objectContaining({
        connectionId: 'conn-1',
        lastError: 'QuickBooks token is unauthorized.',
      }),
    );
    expect(mocks.completeProviderSyncRun).toHaveBeenCalledWith(
      'run-1',
      'failed',
      expect.objectContaining({
        ordersUpserted: 0,
        ordersDeleted: 0,
        itemsUpserted: 0,
        apiCalls: 0,
      }),
      'QuickBooks token is unauthorized.',
    );
  });
});

```

### `server/src/services/integrations/syncOrchestrator.ts`

```typescript
import { v5 as uuidv5 } from 'uuid';
import { query } from '../../db/index.js';
import { decrypt, encrypt } from '../../utils/encryption.js';
import { appLogger } from '../../middleware/requestLogger.js';
import {
  completeProviderSyncRun,
  createProviderSyncRun,
  getProviderConnectionByIdForUser,
  getProviderConnectionByProviderTenant,
  getProviderSyncState,
  markProviderConnectionStatus,
  upsertProviderSyncState,
  updateProviderConnectionTokens,
} from './store.js';
import { QuickBooksAdapter } from './providers/quickbooksAdapter.js';
import { XeroAdapter } from './providers/xeroAdapter.js';
import { IntegrationAuthError } from './errors.js';
import { refreshQuickBooksTokens } from './quickbooksOAuth.js';
import { refreshXeroTokens } from './xeroOAuth.js';
import { CanonicalPurchaseOrder, ProviderConnection, SyncRunCounters, SyncTrigger } from './types.js';

const ORDER_ID_NAMESPACE = '27bf6e8b-0aa0-4123-98af-f4d1f20410d0';
const DEFAULT_BACKFILL_MONTHS = 12;
const QUICKBOOKS_MAX_RESULTS = 100;
const XERO_PAGE_SIZE = 100;
const runningConnectionIds = new Set<string>();

export interface SyncOptions {
  externalIds?: string[];
}

function toIsoDateOnly(date: Date): string {
  return date.toISOString().slice(0, 10);
}

function subtractMonths(now: Date, months: number): Date {
  const copy = new Date(now);
  copy.setMonth(copy.getMonth() - months);
  return copy;
}

function mergeMaxIso(existing: string | undefined, candidate: string | undefined): string | undefined {
  if (!candidate) return existing;
  if (!existing) return candidate;
  return candidate > existing ? candidate : existing;
}

export function isDeletedPurchaseOrderStatus(status: string): boolean {
  const normalized = status.trim().toLowerCase();
  return normalized.includes('deleted') || normalized.includes('void');
}

export function buildProviderOrderId(
  userId: string,
  provider: ProviderConnection['provider'],
  tenantId: string,
  externalId: string,
): string {
  return uuidv5(`${userId}:${provider}:${tenantId}:${externalId}`, ORDER_ID_NAMESPACE);
}

function normalizeLineQuantity(value: number | undefined): number {
  if (!Number.isFinite(value || 0)) return 1;
  return Math.max(1, Math.round(value || 1));
}

async function persistCanonicalOrder(connection: ProviderConnection, order: CanonicalPurchaseOrder): Promise<SyncRunCounters> {
  const counters: SyncRunCounters = {
    ordersUpserted: 0,
    ordersDeleted: 0,
    itemsUpserted: 0,
    apiCalls: 0,
  };

  const orderId = buildProviderOrderId(connection.userId, connection.provider, connection.tenantId, order.externalId);

  if (isDeletedPurchaseOrderStatus(order.status)) {
    const deleted = await query(
      `DELETE FROM orders WHERE id = $1 AND user_id = $2`,
      [orderId, connection.userId],
    );
    counters.ordersDeleted = deleted.rowCount || 0;
    return counters;
  }

  await query(
    `
      INSERT INTO orders (id, user_id, original_email_id, supplier, order_date, total_amount, confidence, raw_data)
      VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
      ON CONFLICT (id) DO UPDATE SET
        supplier = EXCLUDED.supplier,
        order_date = EXCLUDED.order_date,
        total_amount = EXCLUDED.total_amount,
        confidence = EXCLUDED.confidence,
        raw_data = EXCLUDED.raw_data
    `,
    [
      orderId,
      connection.userId,
      `${connection.provider}:${order.externalNumber}`,
      order.supplier,
      order.orderDate ? order.orderDate.slice(0, 10) : null,
      order.totalAmount ?? null,
      1,
      JSON.stringify({
        provider: connection.provider,
        tenantId: connection.tenantId,
        externalId: order.externalId,
        externalNumber: order.externalNumber,
        status: order.status,
        updatedAt: order.updatedAt,
        raw: order.raw,
      }),
    ],
  );

  counters.ordersUpserted = 1;

  await query(`DELETE FROM order_items WHERE order_id = $1`, [orderId]);

  for (const line of order.items) {
    const quantity = normalizeLineQuantity(line.quantity);
    const unitPrice = line.unitPrice ?? null;
    const totalPrice = line.totalPrice ?? (line.unitPrice !== undefined ? line.unitPrice * quantity : null);

    await query(
      `
        INSERT INTO order_items (order_id, name, quantity, unit, unit_price, total_price)
        VALUES ($1,$2,$3,$4,$5,$6)
      `,
      [
        orderId,
        line.name || line.itemCode || line.externalLineId,
        quantity,
        line.unit || 'ea',
        unitPrice,
        totalPrice,
      ],
    );

    counters.itemsUpserted += 1;
  }

  return counters;
}

async function refreshConnectionIfNeeded(connection: ProviderConnection): Promise<ProviderConnection> {
  const refreshWindowMs = 60_000;
  if (connection.tokenExpiresAt.getTime() > Date.now() + refreshWindowMs) {
    return connection;
  }

  try {
    const refreshToken = decrypt(connection.refreshTokenEncrypted);
    if (!refreshToken) {
      throw new IntegrationAuthError('INTEGRATION_REFRESH_TOKEN_MISSING', 'Missing refresh token.');
    }

    const tokenPayload = connection.provider === 'quickbooks'
      ? await refreshQuickBooksTokens(refreshToken)
      : await refreshXeroTokens(refreshToken);

    const updated = await updateProviderConnectionTokens({
      id: connection.id,
      accessTokenEncrypted: encrypt(tokenPayload.accessToken),
      refreshTokenEncrypted: encrypt(tokenPayload.refreshToken),
      tokenExpiresAt: tokenPayload.tokenExpiresAt,
      scope: tokenPayload.scope,
      status: 'connected',
    });

    if (!updated) {
      throw new Error('Connection not found during token refresh.');
    }

    return updated;
  } catch (error) {
    await markProviderConnectionStatus(connection.id, 'reauth_required');
    throw error;
  }
}

async function fetchQuickBooksOrders(
  connection: ProviderConnection,
  accessToken: string,
  state: Awaited<ReturnType<typeof getProviderSyncState>>,
  trigger: SyncTrigger,
  options: SyncOptions,
): Promise<{ orders: CanonicalPurchaseOrder[]; apiCalls: number; maxUpdatedAt?: string; isBackfill: boolean }> {
  const adapter = new QuickBooksAdapter();
  const now = new Date();
  const isBackfill = !state?.backfillCompletedAt;

  if (trigger === 'webhook' && options.externalIds?.length) {
    const byIds = await adapter.getPurchaseOrdersByIds({
      realmId: connection.tenantId,
      accessToken,
      externalIds: options.externalIds,
    });

    return {
      orders: byIds.orders,
      apiCalls: byIds.apiCalls,
      maxUpdatedAt: byIds.maxUpdatedAt,
      isBackfill,
    };
  }

  if (!isBackfill) {
    const changedSince = state?.lastCursorUtc?.toISOString() || new Date(Date.now() - (15 * 60 * 1000)).toISOString();

    try {
      const cdc = await adapter.listIncrementalViaCdc({
        realmId: connection.tenantId,
        accessToken,
        changedSince,
      });

      return {
        orders: cdc.orders,
        apiCalls: cdc.apiCalls,
        maxUpdatedAt: cdc.maxUpdatedAt,
        isBackfill,
      };
    } catch (error) {
      appLogger.warn({ err: error, connectionId: connection.id }, 'QuickBooks CDC failed; falling back to query polling');

      let apiCalls = 0;
      let maxUpdatedAt: string | undefined;
      const allOrders: CanonicalPurchaseOrder[] = [];
      let startPosition = 1;

      while (true) {
        const page = await adapter.listIncremental({
          realmId: connection.tenantId,
          accessToken,
          changedSince,
          startPosition,
          maxResults: QUICKBOOKS_MAX_RESULTS,
        });

        apiCalls += page.apiCalls;
        allOrders.push(...page.orders);
        maxUpdatedAt = mergeMaxIso(maxUpdatedAt, page.maxUpdatedAt);

        if (!page.hasMore) break;
        startPosition = page.nextStartPosition;
      }

      return { orders: allOrders, apiCalls, maxUpdatedAt, isBackfill };
    }
  }

  let startPosition = 1;
  let apiCalls = 0;
  let maxUpdatedAt: string | undefined;
  const allOrders: CanonicalPurchaseOrder[] = [];
  const startDate = toIsoDateOnly(subtractMonths(now, DEFAULT_BACKFILL_MONTHS));
  const endDate = toIsoDateOnly(now);

  while (true) {
    const page = await adapter.listBackfill({
      realmId: connection.tenantId,
      accessToken,
      startDate,
      endDate,
      startPosition,
      maxResults: QUICKBOOKS_MAX_RESULTS,
    });

    apiCalls += page.apiCalls;
    allOrders.push(...page.orders);
    maxUpdatedAt = mergeMaxIso(maxUpdatedAt, page.maxUpdatedAt);

    if (!page.hasMore) break;
    startPosition = page.nextStartPosition;
  }

  return { orders: allOrders, apiCalls, maxUpdatedAt, isBackfill };
}

async function fetchXeroOrders(
  connection: ProviderConnection,
  accessToken: string,
  state: Awaited<ReturnType<typeof getProviderSyncState>>,
): Promise<{ orders: CanonicalPurchaseOrder[]; apiCalls: number; maxUpdatedAt?: string; isBackfill: boolean }> {
  const adapter = new XeroAdapter();
  const now = new Date();
  const isBackfill = !state?.backfillCompletedAt;

  let page = 1;
  let apiCalls = 0;
  let maxUpdatedAt: string | undefined;
  const allOrders: CanonicalPurchaseOrder[] = [];

  const dateFrom = isBackfill ? toIsoDateOnly(subtractMonths(now, DEFAULT_BACKFILL_MONTHS)) : undefined;
  const dateTo = isBackfill ? toIsoDateOnly(now) : undefined;
  const ifModifiedSince = !isBackfill ? state?.lastCursorUtc?.toISOString() : undefined;

  while (true) {
    const result = await adapter.listPurchaseOrders({
      tenantId: connection.tenantId,
      accessToken,
      page,
      pageSize: XERO_PAGE_SIZE,
      dateFrom,
      dateTo,
      ifModifiedSince,
    });

    apiCalls += result.apiCalls;
    allOrders.push(...result.orders);
    maxUpdatedAt = mergeMaxIso(maxUpdatedAt, result.maxUpdatedAt);

    if (!result.hasMore) break;
    page = result.nextPage;
  }

  return { orders: allOrders, apiCalls, maxUpdatedAt, isBackfill };
}

async function performSync(
  connection: ProviderConnection,
  runId: string,
  trigger: SyncTrigger,
  options: SyncOptions,
): Promise<void> {
  const counters: SyncRunCounters = {
    ordersUpserted: 0,
    ordersDeleted: 0,
    itemsUpserted: 0,
    apiCalls: 0,
  };

  const state = await getProviderSyncState(connection.id);
  if (!state?.backfillStartedAt) {
    await upsertProviderSyncState({
      connectionId: connection.id,
      backfillStartedAt: new Date(),
    });
  }

  const currentConnection = await refreshConnectionIfNeeded(connection);
  const accessToken = decrypt(currentConnection.accessTokenEncrypted);

  if (!accessToken) {
    throw new IntegrationAuthError('INTEGRATION_ACCESS_TOKEN_INVALID', 'Stored access token could not be decrypted.');
  }

  const fetched = currentConnection.provider === 'quickbooks'
    ? await fetchQuickBooksOrders(currentConnection, accessToken, state, trigger, options)
    : await fetchXeroOrders(currentConnection, accessToken, state);

  counters.apiCalls += fetched.apiCalls;

  for (const order of fetched.orders) {
    const rowCounters = await persistCanonicalOrder(currentConnection, order);
    counters.ordersUpserted += rowCounters.ordersUpserted;
    counters.ordersDeleted += rowCounters.ordersDeleted;
    counters.itemsUpserted += rowCounters.itemsUpserted;
  }

  const lastCursorIso = fetched.maxUpdatedAt || new Date().toISOString();

  await upsertProviderSyncState({
    connectionId: currentConnection.id,
    lastCursorUtc: new Date(lastCursorIso),
    lastSuccessfulSyncAt: new Date(),
    lastError: null,
    backfillCompletedAt: fetched.isBackfill ? new Date() : undefined,
    cursorPayload: {
      provider: currentConnection.provider,
      lastCursorUtc: lastCursorIso,
    },
  });

  await markProviderConnectionStatus(currentConnection.id, 'connected');
  await completeProviderSyncRun(runId, 'success', counters);
}

async function executeSyncRun(
  connection: ProviderConnection,
  runId: string,
  trigger: SyncTrigger,
  options: SyncOptions,
): Promise<void> {
  if (runningConnectionIds.has(connection.id)) {
    await completeProviderSyncRun(runId, 'failed', {
      ordersUpserted: 0,
      ordersDeleted: 0,
      itemsUpserted: 0,
      apiCalls: 0,
    }, 'Sync already running for this connection.');
    return;
  }

  runningConnectionIds.add(connection.id);

  try {
    await performSync(connection, runId, trigger, options);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown sync error';
    const isAuthError = error instanceof IntegrationAuthError;

    if (isAuthError) {
      await markProviderConnectionStatus(connection.id, 'reauth_required');
    }

    await upsertProviderSyncState({
      connectionId: connection.id,
      lastError: message,
    });

    await completeProviderSyncRun(
      runId,
      'failed',
      {
        ordersUpserted: 0,
        ordersDeleted: 0,
        itemsUpserted: 0,
        apiCalls: 0,
      },
      message,
    );

    appLogger.error({ err: error, connectionId: connection.id, runId, trigger }, 'Provider sync failed');
  } finally {
    runningConnectionIds.delete(connection.id);
  }
}

export async function enqueueProviderSync(
  connectionId: string,
  userId: string,
  trigger: SyncTrigger,
  options: SyncOptions = {},
): Promise<{ runId: string }> {
  const connection = await getProviderConnectionByIdForUser(connectionId, userId);
  if (!connection) {
    throw new Error('Provider connection not found.');
  }

  const run = await createProviderSyncRun(connection.id, trigger);

  queueMicrotask(() => {
    void executeSyncRun(connection, run.id, trigger, options);
  });

  return { runId: run.id };
}

export async function runProviderSyncNow(
  connectionId: string,
  userId: string,
  trigger: SyncTrigger,
  options: SyncOptions = {},
): Promise<{ runId: string }> {
  const connection = await getProviderConnectionByIdForUser(connectionId, userId);
  if (!connection) {
    throw new Error('Provider connection not found.');
  }

  const run = await createProviderSyncRun(connection.id, trigger);
  await executeSyncRun(connection, run.id, trigger, options);

  return { runId: run.id };
}

export async function enqueueProviderSyncByTenant(
  provider: ProviderConnection['provider'],
  tenantId: string,
  trigger: SyncTrigger,
  options: SyncOptions = {},
): Promise<{ runId: string } | null> {
  const connection = await getProviderConnectionByProviderTenant(provider, tenantId);
  if (!connection) return null;

  const run = await createProviderSyncRun(connection.id, trigger);

  queueMicrotask(() => {
    void executeSyncRun(connection, run.id, trigger, options);
  });

  return { runId: run.id };
}

```

### `server/src/services/integrations/syncScheduler.test.ts`

```typescript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

interface SchedulerTestSetup {
  redisClient: { set: ReturnType<typeof vi.fn>; del: ReturnType<typeof vi.fn> } | null;
  enableAccountingConnectors?: boolean;
  accountingSyncIntervalMinutes?: number;
  connections?: Array<{ id: string; userId: string; provider: 'quickbooks' | 'xero' }>;
  enqueueImpl?: (connectionId: string, userId: string, trigger: 'scheduled') => Promise<unknown>;
}

async function setupSchedulerTest(options: SchedulerTestSetup) {
  vi.resetModules();

  const listActiveProviderConnections = vi.fn().mockResolvedValue(options.connections || []);
  const enqueueProviderSync = vi.fn(
    options.enqueueImpl || (() => Promise.resolve({ runId: 'run-1' })),
  );

  const appLogger = {
    info: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
    error: vi.fn(),
  };

  vi.doMock('../../utils/redisClient.js', () => ({
    default: options.redisClient,
  }));

  vi.doMock('../../config.js', () => ({
    enableAccountingConnectors: options.enableAccountingConnectors ?? true,
    accountingSyncIntervalMinutes: options.accountingSyncIntervalMinutes ?? 15,
  }));

  vi.doMock('./store.js', () => ({
    listActiveProviderConnections,
  }));

  vi.doMock('./syncOrchestrator.js', () => ({
    enqueueProviderSync,
  }));

  vi.doMock('../../middleware/requestLogger.js', () => ({
    appLogger,
  }));

  const scheduler = await import('./syncScheduler.js');
  return {
    ...scheduler,
    listActiveProviderConnections,
    enqueueProviderSync,
    appLogger,
  };
}

async function flushAsyncWork(): Promise<void> {
  await Promise.resolve();
  await Promise.resolve();
  await Promise.resolve();
}

describe('syncScheduler', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('logs and exits when connectors are disabled', async () => {
    const scheduler = await setupSchedulerTest({
      redisClient: {
        set: vi.fn().mockResolvedValue('OK'),
        del: vi.fn().mockResolvedValue(1),
      },
      enableAccountingConnectors: false,
    });

    scheduler.startProviderSyncScheduler();
    await flushAsyncWork();
    scheduler.stopProviderSyncScheduler();

    expect(scheduler.appLogger.info).toHaveBeenCalledWith(
      'Accounting connector scheduler disabled via ENABLE_ACCOUNTING_CONNECTORS=false',
    );
    expect(scheduler.listActiveProviderConnections).not.toHaveBeenCalled();
  });

  it('warns and skips when Redis is unavailable', async () => {
    const scheduler = await setupSchedulerTest({
      redisClient: null,
      enableAccountingConnectors: true,
    });

    scheduler.startProviderSyncScheduler();
    await flushAsyncWork();
    scheduler.stopProviderSyncScheduler();

    expect(scheduler.appLogger.warn).toHaveBeenCalledWith(
      'Redis unavailable; skipping scheduled accounting sync tick',
    );
    expect(scheduler.listActiveProviderConnections).not.toHaveBeenCalled();
  });

  it('skips tick when lock is not acquired', async () => {
    const redisClient = {
      set: vi.fn().mockResolvedValue(null),
      del: vi.fn().mockResolvedValue(1),
    };

    const scheduler = await setupSchedulerTest({
      redisClient,
      enableAccountingConnectors: true,
    });

    scheduler.startProviderSyncScheduler();
    await flushAsyncWork();
    scheduler.stopProviderSyncScheduler();

    expect(redisClient.set).toHaveBeenCalledTimes(1);
    expect(scheduler.appLogger.debug).toHaveBeenCalledWith(
      'Accounting sync tick skipped because another instance holds the lock',
    );
    expect(scheduler.listActiveProviderConnections).not.toHaveBeenCalled();
  });

  it('enqueues scheduled sync for active connections and releases lock', async () => {
    const redisClient = {
      set: vi.fn().mockResolvedValue('OK'),
      del: vi.fn().mockResolvedValue(1),
    };

    const scheduler = await setupSchedulerTest({
      redisClient,
      enableAccountingConnectors: true,
      connections: [
        { id: 'conn-1', userId: 'user-1', provider: 'quickbooks' },
        { id: 'conn-2', userId: 'user-2', provider: 'xero' },
      ],
    });

    scheduler.startProviderSyncScheduler();
    await flushAsyncWork();
    scheduler.stopProviderSyncScheduler();

    expect(scheduler.enqueueProviderSync).toHaveBeenCalledWith('conn-1', 'user-1', 'scheduled');
    expect(scheduler.enqueueProviderSync).toHaveBeenCalledWith('conn-2', 'user-2', 'scheduled');
    expect(redisClient.del).toHaveBeenCalledWith('orderpulse:integrations:sync:lock');
  });

  it('continues when a single enqueue fails and still releases lock', async () => {
    const redisClient = {
      set: vi.fn().mockResolvedValue('OK'),
      del: vi.fn().mockResolvedValue(1),
    };

    const scheduler = await setupSchedulerTest({
      redisClient,
      enableAccountingConnectors: true,
      connections: [
        { id: 'conn-1', userId: 'user-1', provider: 'quickbooks' },
        { id: 'conn-2', userId: 'user-2', provider: 'xero' },
      ],
      enqueueImpl: async (connectionId) => {
        if (connectionId === 'conn-1') {
          throw new Error('boom');
        }
        return { runId: 'run-2' };
      },
    });

    scheduler.startProviderSyncScheduler();
    await flushAsyncWork();
    scheduler.stopProviderSyncScheduler();

    expect(scheduler.enqueueProviderSync).toHaveBeenCalledTimes(2);
    expect(scheduler.appLogger.error).toHaveBeenCalledWith(
      expect.objectContaining({
        connectionId: 'conn-1',
        provider: 'quickbooks',
      }),
      'Failed to enqueue scheduled provider sync',
    );
    expect(redisClient.del).toHaveBeenCalledWith('orderpulse:integrations:sync:lock');
  });
});

```

### `server/src/services/integrations/syncScheduler.ts`

```typescript
import redisClient from '../../utils/redisClient.js';
import { accountingSyncIntervalMinutes, enableAccountingConnectors } from '../../config.js';
import { appLogger } from '../../middleware/requestLogger.js';
import { listActiveProviderConnections } from './store.js';
import { enqueueProviderSync } from './syncOrchestrator.js';

const LOCK_KEY = 'orderpulse:integrations:sync:lock';
const LOCK_TTL_MS = 1000 * 60 * 10;

let intervalHandle: ReturnType<typeof setInterval> | null = null;

async function runScheduledSyncTick(): Promise<void> {
  if (!redisClient) {
    appLogger.warn('Redis unavailable; skipping scheduled accounting sync tick');
    return;
  }

  const lock = await redisClient.set(LOCK_KEY, 'locked', 'PX', LOCK_TTL_MS, 'NX');
  if (!lock) {
    appLogger.debug('Accounting sync tick skipped because another instance holds the lock');
    return;
  }

  try {
    const connections = await listActiveProviderConnections();
    for (const connection of connections) {
      try {
        await enqueueProviderSync(connection.id, connection.userId, 'scheduled');
      } catch (error) {
        appLogger.error(
          { err: error, connectionId: connection.id, provider: connection.provider },
          'Failed to enqueue scheduled provider sync',
        );
      }
    }
  } finally {
    await redisClient.del(LOCK_KEY).catch((error: Error) => {
      appLogger.error({ err: error }, 'Failed to release accounting sync lock');
    });
  }
}

export function startProviderSyncScheduler(): void {
  if (intervalHandle) return;
  if (!enableAccountingConnectors) {
    appLogger.info('Accounting connector scheduler disabled via ENABLE_ACCOUNTING_CONNECTORS=false');
    return;
  }

  const intervalMs = Math.max(1, accountingSyncIntervalMinutes) * 60 * 1000;
  appLogger.info({ intervalMinutes: accountingSyncIntervalMinutes }, 'Starting accounting provider sync scheduler');

  intervalHandle = setInterval(() => {
    void runScheduledSyncTick();
  }, intervalMs);

  void runScheduledSyncTick();
}

export function stopProviderSyncScheduler(): void {
  if (intervalHandle) {
    clearInterval(intervalHandle);
    intervalHandle = null;
  }
}

```

### `server/src/services/integrations/types.ts`

```typescript
export type IntegrationProvider = 'quickbooks' | 'xero';

export type ConnectionStatus = 'connected' | 'reauth_required' | 'error' | 'disconnected';

export type SyncTrigger = 'manual' | 'scheduled' | 'webhook' | 'backfill';

export type SyncRunStatus = 'running' | 'success' | 'failed';

export interface CanonicalLineItem {
  externalLineId: string;
  name: string;
  quantity: number;
  unit?: string;
  unitPrice?: number;
  totalPrice?: number;
  sku?: string;
  itemCode?: string;
}

export interface CanonicalPurchaseOrder {
  externalId: string;
  externalNumber: string;
  supplier: string;
  orderDate?: string;
  status: string;
  totalAmount?: number;
  updatedAt?: string;
  items: CanonicalLineItem[];
  raw: Record<string, unknown>;
}

export interface ProviderConnection {
  id: string;
  userId: string;
  provider: IntegrationProvider;
  tenantId: string;
  tenantName?: string;
  accessTokenEncrypted: string;
  refreshTokenEncrypted: string;
  tokenExpiresAt: Date;
  scope?: string;
  status: ConnectionStatus;
  metadata?: Record<string, unknown>;
  createdAt: Date;
  updatedAt: Date;
}

export interface ProviderSyncState {
  connectionId: string;
  backfillStartedAt?: Date;
  backfillCompletedAt?: Date;
  lastCursorUtc?: Date;
  cursorPayload?: Record<string, unknown>;
  lastSuccessfulSyncAt?: Date;
  lastError?: string;
  updatedAt: Date;
}

export interface ProviderSyncRun {
  id: string;
  connectionId: string;
  trigger: SyncTrigger;
  status: SyncRunStatus;
  ordersUpserted: number;
  ordersDeleted: number;
  itemsUpserted: number;
  apiCalls: number;
  startedAt: Date;
  finishedAt?: Date;
  error?: string;
}

export interface SyncRunCounters {
  ordersUpserted: number;
  ordersDeleted: number;
  itemsUpserted: number;
  apiCalls: number;
}

export interface SyncRunSummary extends ProviderSyncRun {
  provider: IntegrationProvider;
  tenantId: string;
  tenantName?: string;
}

export interface IntegrationConnectionSummary {
  id: string;
  provider: IntegrationProvider;
  tenantId: string;
  tenantName?: string;
  status: ConnectionStatus;
  tokenExpiresAt: Date;
  createdAt: Date;
  updatedAt: Date;
  lastRun?: {
    id: string;
    status: SyncRunStatus;
    trigger: SyncTrigger;
    startedAt: Date;
    finishedAt?: Date;
    error?: string;
  };
}

```

### `server/src/services/integrations/xeroOAuth.ts`

```typescript
import { asDateFromExpiresIn, IntegrationAuthError, parseJsonResponse, requireEnv } from './errors.js';

const XERO_AUTHORIZE_URL = 'https://login.xero.com/identity/connect/authorize';
const XERO_TOKEN_URL = 'https://identity.xero.com/connect/token';
const XERO_CONNECTIONS_URL = 'https://api.xero.com/connections';
const XERO_ACCOUNTING_BASE_URL = 'https://api.xero.com/api.xro/2.0';
const XERO_SCOPES = ['openid', 'profile', 'email', 'offline_access', 'accounting.transactions.read'];

export interface XeroTokenPayload {
  accessToken: string;
  refreshToken: string;
  tokenExpiresAt: Date;
  scope?: string;
}

export interface XeroTenantConnection {
  id: string;
  tenantId: string;
  tenantName: string;
  tenantType: string;
}

function redirectUri(): string {
  const backendUrl = requireEnv('BACKEND_URL');
  return `${backendUrl.replace(/\/+$/, '')}/api/integrations/xero/callback`;
}

function basicAuthHeader(clientId: string, clientSecret: string): string {
  return `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`;
}

function toTokenPayload(payload: any): XeroTokenPayload {
  if (!payload?.access_token || !payload?.refresh_token) {
    throw new IntegrationAuthError('XERO_TOKEN_INVALID', 'Xero token response is missing required fields.');
  }

  return {
    accessToken: payload.access_token,
    refreshToken: payload.refresh_token,
    tokenExpiresAt: asDateFromExpiresIn(payload.expires_in),
    scope: typeof payload.scope === 'string' ? payload.scope : undefined,
  };
}

export function buildXeroAuthUrl(state: string): string {
  const clientId = requireEnv('XERO_CLIENT_ID');
  const params = new URLSearchParams({
    response_type: 'code',
    client_id: clientId,
    redirect_uri: redirectUri(),
    scope: XERO_SCOPES.join(' '),
    state,
  });

  return `${XERO_AUTHORIZE_URL}?${params.toString()}`;
}

export async function exchangeXeroCodeForTokens(code: string): Promise<XeroTokenPayload> {
  const clientId = requireEnv('XERO_CLIENT_ID');
  const clientSecret = requireEnv('XERO_CLIENT_SECRET');

  const body = new URLSearchParams({
    grant_type: 'authorization_code',
    code,
    redirect_uri: redirectUri(),
  });

  const response = await fetch(XERO_TOKEN_URL, {
    method: 'POST',
    headers: {
      Authorization: basicAuthHeader(clientId, clientSecret),
      'Content-Type': 'application/x-www-form-urlencoded',
      Accept: 'application/json',
    },
    body,
  });

  const payload = await parseJsonResponse(response);
  if (!response.ok) {
    throw new IntegrationAuthError(
      'XERO_TOKEN_EXCHANGE_FAILED',
      payload?.error_description || payload?.error || `Xero token exchange failed (${response.status}).`,
    );
  }

  return toTokenPayload(payload);
}

export async function refreshXeroTokens(refreshToken: string): Promise<XeroTokenPayload> {
  const clientId = requireEnv('XERO_CLIENT_ID');
  const clientSecret = requireEnv('XERO_CLIENT_SECRET');

  const body = new URLSearchParams({
    grant_type: 'refresh_token',
    refresh_token: refreshToken,
  });

  const response = await fetch(XERO_TOKEN_URL, {
    method: 'POST',
    headers: {
      Authorization: basicAuthHeader(clientId, clientSecret),
      'Content-Type': 'application/x-www-form-urlencoded',
      Accept: 'application/json',
    },
    body,
  });

  const payload = await parseJsonResponse(response);
  if (!response.ok) {
    throw new IntegrationAuthError(
      'XERO_TOKEN_REFRESH_FAILED',
      payload?.error_description || payload?.error || `Xero token refresh failed (${response.status}).`,
    );
  }

  return toTokenPayload(payload);
}

export async function fetchXeroTenants(accessToken: string): Promise<XeroTenantConnection[]> {
  const response = await fetch(XERO_CONNECTIONS_URL, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/json',
    },
  });

  const payload = await parseJsonResponse(response);
  if (!response.ok) {
    throw new IntegrationAuthError('XERO_CONNECTIONS_FAILED', `Unable to read Xero tenant connections (${response.status}).`);
  }

  if (!Array.isArray(payload)) return [];

  return payload
    .filter((row) => typeof row?.tenantId === 'string')
    .map((row) => ({
      id: String(row.id || row.tenantId),
      tenantId: String(row.tenantId),
      tenantName: String(row.tenantName || row.tenantId),
      tenantType: String(row.tenantType || ''),
    }));
}

export async function fetchXeroOrganizationName(tenantId: string, accessToken: string): Promise<string | undefined> {
  const response = await fetch(`${XERO_ACCOUNTING_BASE_URL}/Organisation`, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'xero-tenant-id': tenantId,
      Accept: 'application/json',
    },
  });

  const payload = await parseJsonResponse(response);
  if (!response.ok) {
    return undefined;
  }

  const org = Array.isArray(payload?.Organisations) ? payload.Organisations[0] : undefined;
  return typeof org?.Name === 'string' ? org.Name : undefined;
}

export async function revokeXeroConnection(connectionId: string, accessToken: string): Promise<void> {
  if (!connectionId) return;

  const response = await fetch(`${XERO_CONNECTIONS_URL}/${encodeURIComponent(connectionId)}`, {
    method: 'DELETE',
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/json',
    },
  });

  if (!response.ok) {
    const payload = await parseJsonResponse(response);
    throw new IntegrationAuthError(
      'XERO_CONNECTION_REVOKE_FAILED',
      payload?.message || payload?.error || `Xero connection revoke failed (${response.status}).`,
    );
  }
}

```

### `server/src/services/jobManager.test.ts`

```typescript
// Unit tests for jobManager service
import { describe, it, expect, beforeEach } from 'vitest';
import { 
  createJob, 
  getJob, 
  getJobForUser, 
  updateJob, 
  addJobLog, 
  addJobOrder,
  replaceJobOrders,
  setJobCurrentEmail,
  updateJobProgress,
  cleanupOldJobs 
} from './jobManager.js';

describe('jobManager', () => {
  beforeEach(() => {
    // Clean up between tests by running cleanup with old date mock
    cleanupOldJobs();
  });

  describe('createJob', () => {
    it('should create a job with correct initial state', () => {
      const job = createJob('user-123');
      
      expect(job).toBeDefined();
      expect(job.id).toBeDefined();
      expect(job.userId).toBe('user-123');
      expect(job.status).toBe('pending');
      expect(job.progress.total).toBe(0);
      expect(job.progress.processed).toBe(0);
      expect(job.progress.currentTask).toBe('Queued...');
      expect(job.orders).toEqual([]);
      expect(job.logs).toEqual([]);
      expect(job.currentEmail).toBeNull();
    });

    it('should generate unique job IDs', () => {
      const job1 = createJob('user-1');
      const job2 = createJob('user-2');
      
      expect(job1.id).not.toBe(job2.id);
    });

    it('should cancel previous running job when creating new one for same user', () => {
      const job1 = createJob('user-same');
      updateJob(job1.id, { status: 'running' });
      
      const job2 = createJob('user-same');
      
      const updatedJob1 = getJob(job1.id);
      expect(updatedJob1?.status).toBe('failed');
      expect(updatedJob1?.error).toBe('Cancelled - new job started');
      expect(job2.status).toBe('pending');
    });
  });

  describe('getJob', () => {
    it('should return job by ID', () => {
      const created = createJob('user-get');
      const retrieved = getJob(created.id);
      
      expect(retrieved).toBeDefined();
      expect(retrieved?.id).toBe(created.id);
    });

    it('should return undefined for non-existent job', () => {
      const result = getJob('non-existent-id');
      expect(result).toBeUndefined();
    });
  });

  describe('getJobForUser', () => {
    it('should return latest job for user', () => {
      const _job1 = createJob('user-multi');
      const job2 = createJob('user-multi');
      
      const result = getJobForUser('user-multi');
      expect(result?.id).toBe(job2.id);
    });

    it('should return undefined for user with no jobs', () => {
      const result = getJobForUser('no-jobs-user');
      expect(result).toBeUndefined();
    });
  });

  describe('updateJob', () => {
    it('should update job properties', () => {
      const job = createJob('user-update');
      
      updateJob(job.id, { status: 'running' });
      
      const updated = getJob(job.id);
      expect(updated?.status).toBe('running');
    });

    it('should update updatedAt timestamp', () => {
      const job = createJob('user-time');
      const originalTime = job.updatedAt;
      
      // Small delay to ensure different timestamp
      updateJob(job.id, { status: 'completed' });
      
      const updated = getJob(job.id);
      expect(updated?.updatedAt.getTime()).toBeGreaterThanOrEqual(originalTime.getTime());
    });

    it('should return undefined for non-existent job', () => {
      const result = updateJob('fake-id', { status: 'running' });
      expect(result).toBeUndefined();
    });
  });

  describe('addJobLog', () => {
    it('should add log entry to job', () => {
      const job = createJob('user-log');
      
      addJobLog(job.id, 'Test message');
      
      const updated = getJob(job.id);
      expect(updated?.logs.length).toBe(1);
      expect(updated?.logs[0]).toContain('Test message');
    });

    it('should prepend new logs (most recent first)', () => {
      const job = createJob('user-log-order');
      
      addJobLog(job.id, 'First');
      addJobLog(job.id, 'Second');
      
      const updated = getJob(job.id);
      expect(updated?.logs[0]).toContain('Second');
      expect(updated?.logs[1]).toContain('First');
    });

    it('should limit logs to 100 entries', () => {
      const job = createJob('user-log-limit');
      
      for (let i = 0; i < 110; i++) {
        addJobLog(job.id, `Log ${i}`);
      }
      
      const updated = getJob(job.id);
      expect(updated?.logs.length).toBe(100);
    });
  });

  describe('addJobOrder', () => {
    it('should add order to job', () => {
      const job = createJob('user-order');
      const order = {
        id: 'order-1',
        supplier: 'Test Supplier',
        orderDate: '2024-01-15',
        totalAmount: 100,
        items: [],
        confidence: 0.9
      };
      
      addJobOrder(job.id, order);
      
      const updated = getJob(job.id);
      expect(updated?.orders.length).toBe(1);
      expect(updated?.orders[0].supplier).toBe('Test Supplier');
    });
  });

  describe('replaceJobOrders', () => {
    it('should replace all existing orders in a job', () => {
      const job = createJob('user-replace-orders');
      addJobOrder(job.id, {
        id: 'order-1',
        supplier: 'Supplier A',
        orderDate: '2024-01-01',
        totalAmount: 10,
        items: [],
        confidence: 0.9,
      });

      replaceJobOrders(job.id, [{
        id: 'order-2',
        supplier: 'Supplier B',
        orderDate: '2024-02-01',
        totalAmount: 20,
        items: [],
        confidence: 0.95,
      }]);

      const updated = getJob(job.id);
      expect(updated?.orders).toHaveLength(1);
      expect(updated?.orders[0].id).toBe('order-2');
      expect(updated?.orders[0].supplier).toBe('Supplier B');
    });

    it('should support replacing with an empty order list', () => {
      const job = createJob('user-replace-empty');
      addJobOrder(job.id, {
        id: 'order-1',
        supplier: 'Supplier A',
        orderDate: '2024-01-01',
        totalAmount: 10,
        items: [],
        confidence: 0.9,
      });

      replaceJobOrders(job.id, []);

      const updated = getJob(job.id);
      expect(updated?.orders).toEqual([]);
    });
  });

  describe('setJobCurrentEmail', () => {
    it('should set current email being processed', () => {
      const job = createJob('user-email');
      const email = { id: 'email-1', subject: 'Test', sender: 'test@test.com' };
      
      setJobCurrentEmail(job.id, email);
      
      const updated = getJob(job.id);
      expect(updated?.currentEmail).toEqual(email);
    });

    it('should allow setting to null', () => {
      const job = createJob('user-email-null');
      setJobCurrentEmail(job.id, { id: 'e1', subject: 'S', sender: 's@s.com' });
      setJobCurrentEmail(job.id, null);
      
      const updated = getJob(job.id);
      expect(updated?.currentEmail).toBeNull();
    });
  });

  describe('updateJobProgress', () => {
    it('should update progress fields', () => {
      const job = createJob('user-progress');
      
      updateJobProgress(job.id, { total: 10, processed: 5, currentTask: 'Processing...' });
      
      const updated = getJob(job.id);
      expect(updated?.progress.total).toBe(10);
      expect(updated?.progress.processed).toBe(5);
      expect(updated?.progress.currentTask).toBe('Processing...');
    });

    it('should merge with existing progress', () => {
      const job = createJob('user-progress-merge');
      updateJobProgress(job.id, { total: 20 });
      updateJobProgress(job.id, { processed: 10 });
      
      const updated = getJob(job.id);
      expect(updated?.progress.total).toBe(20);
      expect(updated?.progress.processed).toBe(10);
    });
  });
});

```

### `server/src/services/jobManager.ts`

```typescript
// Job Manager - Background processing for email analysis
import { v4 as uuidv4 } from 'uuid';
import redisClient from '../utils/redisClient.js';
import { requireRedis } from '../config.js';

export interface JobProgress {
  total: number;
  processed: number;
  success: number;
  failed: number;
  currentTask: string;
}

export interface EmailPreview {
  id: string;
  subject: string;
  sender: string;
  snippet?: string;
}

export interface AmazonEnrichedData {
  asin: string;
  itemName?: string;
  humanizedName?: string;  // Shop-floor friendly name from LLM
  price?: string;
  imageUrl?: string;
  amazonUrl?: string;
  unitCount?: number;
  unitPrice?: number;
  upc?: string;
}

export interface ProcessedOrderItem {
  id: string;
  name: string;
  quantity: number;
  unit: string;
  unitPrice: number;
  asin?: string;
  amazonEnriched?: AmazonEnrichedData;
}

export interface ProcessedOrder {
  id: string;
  supplier: string;
  orderDate: string;
  shippedDate?: string;
  deliveredDate?: string;
  leadTimeDays?: number;
  totalAmount: number;
  items: ProcessedOrderItem[];
  confidence: number;
}

export interface Job {
  id: string;
  userId: string;
  jobType?: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  progress: JobProgress;
  currentEmail: EmailPreview | null;
  orders: ProcessedOrder[];
  logs: string[];
  createdAt: Date;
  updatedAt: Date;
  error?: string;
}

// In-memory job storage (would be Redis/DB in production)
const jobs = new Map<string, Job>();
const userJobs = new Map<string, string>(); // userId -> latest jobId
const userJobsByType = new Map<string, Map<string, string>>(); // userId -> (jobType -> jobId)
const jobPersistenceCache = new Map<string, string>();

const JOB_KEY_PREFIX = 'orderpulse:job:';
const USER_JOB_KEY = 'orderpulse:user';

function jobKey(jobId: string): string {
  return `${JOB_KEY_PREFIX}${jobId}`;
}

function serializeJob(job: Job) {
  return {
    ...job,
    createdAt: job.createdAt.toISOString(),
    updatedAt: job.updatedAt.toISOString(),
  };
}

function deserializeJob(payload: string): Job {
  const parsed = JSON.parse(payload);
  return {
    ...parsed,
    createdAt: new Date(parsed.createdAt),
    updatedAt: new Date(parsed.updatedAt),
  };
}

function persistJob(job: Job) {
  const payload = JSON.stringify(serializeJob(job));
  if (jobPersistenceCache.get(job.id) === payload) {
    return;
  }
  jobPersistenceCache.set(job.id, payload);

  if (!redisClient) return;
  redisClient.set(jobKey(job.id), payload).catch((err: Error) => {
    console.error('Failed to persist job to Redis:', err);
  });
}

function persistUserJob(userId: string, jobId: string) {
  if (!redisClient) return;
  redisClient.hset(USER_JOB_KEY, userId, jobId).catch((err: Error) => {
    console.error('Failed to persist user job mapping:', err);
  });
}

function cleanupRedisMapping(userId: string, jobId: string) {
  if (!redisClient) return;
  redisClient.hget(USER_JOB_KEY, userId).then((existing: string | null) => {
    if (existing === jobId) {
      return redisClient!.hdel(USER_JOB_KEY, userId);
    }
  }).catch((err: Error) => {
    console.error('Failed to clean up user job mapping:', err);
  });
}

export function createJob(
  userId: string,
  options?: { jobType?: string; allowConcurrent?: boolean }
): Job {
  const jobType = options?.jobType || 'general';
  const allowConcurrent = options?.allowConcurrent || false;
  const jobsForUser = userJobsByType.get(userId) || new Map<string, string>();

  console.log(`🔧 Creating job: type=${jobType}, userId=${userId.substring(0, 8)}...`);
  console.log(`   Current jobs for user by type:`, Array.from(jobsForUser.entries()).map(([t, id]) => `${t}=${id.substring(0, 8)}`).join(', ') || 'none');

  // Cancel any existing running job for this user + type (unless concurrent allowed)
  const existingJobId = jobsForUser.get(jobType);
  if (existingJobId && !allowConcurrent) {
    const existingJob = jobs.get(existingJobId);
    if (existingJob && existingJob.status === 'running') {
      console.log(`   ⚠️ Cancelling existing ${jobType} job: ${existingJobId.substring(0, 8)}`);
      existingJob.status = 'failed';
      existingJob.error = 'Cancelled - new job started';
      existingJob.updatedAt = new Date();
    }
  }

  const job: Job = {
    id: uuidv4(),
    userId,
    jobType,
    status: 'pending',
    progress: {
      total: 0,
      processed: 0,
      success: 0,
      failed: 0,
      currentTask: 'Queued...',
    },
    currentEmail: null,
    orders: [],
    logs: [],
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  jobs.set(job.id, job);
  jobsForUser.set(jobType, job.id);
  userJobsByType.set(userId, jobsForUser);
  userJobs.set(userId, job.id);
  persistJob(job);
  persistUserJob(userId, job.id);

  return job;
}

export function getJob(jobId: string): Job | undefined {
  return jobs.get(jobId);
}

export function getJobForUser(userId: string): Job | undefined {
  const jobId = userJobs.get(userId);
  if (jobId) {
    return jobs.get(jobId);
  }
  return undefined;
}

export function updateJob(jobId: string, updates: Partial<Job>): Job | undefined {
  const job = jobs.get(jobId);
  if (!job) return undefined;

  Object.assign(job, updates, { updatedAt: new Date() });
  persistJob(job);
  return job;
}

export function addJobLog(jobId: string, message: string): void {
  const job = jobs.get(jobId);
  if (job) {
    const timestamp = new Date().toLocaleTimeString();
    job.logs.unshift(`[${timestamp}] ${message}`);
    job.updatedAt = new Date();
    // Keep only last 100 logs
    if (job.logs.length > 100) {
      job.logs = job.logs.slice(0, 100);
    }
    persistJob(job);
  }
}

export function addJobOrder(jobId: string, order: ProcessedOrder): void {
  const job = jobs.get(jobId);
  if (job) {
    job.orders.push(order);
    job.updatedAt = new Date();
    persistJob(job);
  }
}

export function replaceJobOrders(jobId: string, orders: ProcessedOrder[]): void {
  const job = jobs.get(jobId);
  if (job) {
    job.orders = [...orders];
    job.updatedAt = new Date();
    persistJob(job);
  }
}

export function setJobCurrentEmail(jobId: string, email: EmailPreview | null): void {
  const job = jobs.get(jobId);
  if (job) {
    job.currentEmail = email;
    job.updatedAt = new Date();
    persistJob(job);
  }
}

export function updateJobProgress(jobId: string, progress: Partial<JobProgress>): void {
  const job = jobs.get(jobId);
  if (job) {
    Object.assign(job.progress, progress);
    job.updatedAt = new Date();
    persistJob(job);
  }
}

// Cleanup old jobs (jobs older than 1 hour)
export function cleanupOldJobs(): void {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
  for (const [jobId, job] of jobs.entries()) {
    if (job.updatedAt < oneHourAgo && job.status !== 'running') {
      jobs.delete(jobId);
      // Clean up user mapping if this was their latest job
      if (userJobs.get(job.userId) === jobId) {
        userJobs.delete(job.userId);
        cleanupRedisMapping(job.userId, jobId);
      }
      const jobType = job.jobType || 'general';
      const jobsForUser = userJobsByType.get(job.userId);
      if (jobsForUser && jobsForUser.get(jobType) === jobId) {
        jobsForUser.delete(jobType);
        if (jobsForUser.size === 0) {
          userJobsByType.delete(job.userId);
        }
      }
      if (redisClient) {
        redisClient.del(jobKey(jobId)).catch((err: Error) => {
          console.error('Failed to remove job from Redis:', err);
        });
      }
    }
  }
}

let cleanupInterval: ReturnType<typeof setInterval> | null = null;

function startCleanupScheduler(): void {
  if (cleanupInterval) return;
  cleanupInterval = setInterval(cleanupOldJobs, 10 * 60 * 1000);
}

export function stopCleanupScheduler(): void {
  if (cleanupInterval) {
    clearInterval(cleanupInterval);
    cleanupInterval = null;
  }
}

export const jobManager = {
  createJob,
  getJob,
  getJobForUser,
  updateJob,
  addJobLog,
  addJobOrder,
  replaceJobOrders,
  setJobCurrentEmail,
  updateJobProgress,
  cleanupOldJobs,
};

export async function initializeJobManager(): Promise<void> {
  if (!redisClient) {
    if (requireRedis) {
      throw new Error('Redis is required for job manager in production');
    }
    console.log('⚠️ Redis unavailable – job store will remain in-memory only');
    startCleanupScheduler();
    return;
  }

  try {
    const keys = await redisClient.keys(`${JOB_KEY_PREFIX}*`);
    for (const key of keys) {
      const payload = await redisClient.get(key);
      if (!payload) continue;
      const job = deserializeJob(payload);
      jobs.set(job.id, job);
    }

    const userEntries = await redisClient.hgetall(USER_JOB_KEY);
    for (const [userId, jobId] of Object.entries(userEntries) as [string, string][]) {
      if (!jobs.has(jobId)) {
        await redisClient.hdel(USER_JOB_KEY, userId);
        continue;
      }
      userJobs.set(userId, jobId);
    }

    // Rehydrate per-type mappings from jobs (best effort)
    for (const job of jobs.values()) {
      const jobType = job.jobType || 'general';
      const jobsForUser = userJobsByType.get(job.userId) || new Map<string, string>();
      const existingId = jobsForUser.get(jobType);
      if (!existingId) {
        jobsForUser.set(jobType, job.id);
      } else {
        const existingJob = jobs.get(existingId);
        if (!existingJob || existingJob.updatedAt < job.updatedAt) {
          jobsForUser.set(jobType, job.id);
        }
      }
      userJobsByType.set(job.userId, jobsForUser);
    }

    console.log(`✅ Job manager hydrated ${jobs.size} jobs from Redis`);
  } catch (error) {
    console.error('Failed to hydrate jobs from Redis:', error);
  }

  startCleanupScheduler();
}

export function shutdownJobManager(): void {
  stopCleanupScheduler();
}

```

### `server/src/services/urlScraper.test.ts`

```typescript
import { beforeEach, describe, expect, it, vi } from 'vitest';

const mocks = vi.hoisted(() => ({
  extractAsinFromUrl: vi.fn(),
  enrichItemWithAmazon: vi.fn(),
  createAffiliateUrl: vi.fn((asin: string) => `https://www.amazon.com/dp/${asin}`),
}));

vi.mock('./amazon.js', () => ({
  amazonService: {
    extractAsinFromUrl: mocks.extractAsinFromUrl,
    enrichItemWithAmazon: mocks.enrichItemWithAmazon,
  },
  createAffiliateUrl: mocks.createAffiliateUrl,
}));

import { createUrlScraper, validatePublicHttpUrl } from './urlScraper.js';

function mockResponse(options: {
  body: string;
  url: string;
  status?: number;
  headers?: Record<string, string>;
}) {
  const headers = new Headers(options.headers || { 'content-type': 'text/html' });
  return {
    ok: (options.status || 200) >= 200 && (options.status || 200) < 300,
    status: options.status || 200,
    url: options.url,
    headers,
    text: async () => options.body,
  } as unknown as Response;
}

describe('urlScraper', () => {
  beforeEach(() => {
    mocks.extractAsinFromUrl.mockReset();
    mocks.enrichItemWithAmazon.mockReset();
  });

  it('uses Amazon PAAPI enrichment for valid ASIN URLs', async () => {
    mocks.extractAsinFromUrl.mockReturnValue('B012345678');
    mocks.enrichItemWithAmazon.mockResolvedValue({
      ASIN: 'B012345678',
      ItemName: 'Shop Towels',
      Price: '$19.99',
      UnitPrice: 19.99,
      ImageURL: 'https://images.amazon.com/towel.jpg',
      AmazonURL: 'https://www.amazon.com/dp/B012345678?tag=arda06-20',
      UPC: '123456789012',
    });

    const scraper = createUrlScraper({
      fetchFn: vi.fn(async () => mockResponse({
        body: '<html><title>Amazon</title></html>',
        url: 'https://www.amazon.com/dp/B012345678',
      })) as unknown as typeof fetch,
      createModel: () => null as any,
    });

    const result = await scraper.scrapeUrls(['https://www.amazon.com/dp/B012345678']);

    expect(result.processed).toBe(1);
    expect(result.results[0].status).toBe('success');
    expect(result.results[0].item.asin).toBe('B012345678');
    expect(result.results[0].item.itemName).toBe('Shop Towels');
    expect(result.results[0].item.extractionSource).toBe('amazon-paapi');
  });

  it('resolves redirected Amazon short links before ASIN extraction', async () => {
    mocks.extractAsinFromUrl.mockImplementation((url: string) => (
      url.includes('/dp/B099999999') ? 'B099999999' : null
    ));
    mocks.enrichItemWithAmazon.mockResolvedValue({
      ASIN: 'B099999999',
      ItemName: 'Cordless Drill',
      UnitPrice: 129.0,
      AmazonURL: 'https://www.amazon.com/dp/B099999999?tag=arda06-20',
      ImageURL: 'https://images.amazon.com/drill.jpg',
    });

    const scraper = createUrlScraper({
      fetchFn: vi.fn(async () => mockResponse({
        body: '<html></html>',
        url: 'https://www.amazon.com/dp/B099999999',
      })) as unknown as typeof fetch,
      createModel: () => null as any,
    });

    const result = await scraper.scrapeUrls(['https://amzn.to/abc']);

    expect(result.results[0].item.asin).toBe('B099999999');
    expect(result.results[0].status).toBe('success');
  });

  it('extracts non-Amazon product data from JSON-LD without AI fallback', async () => {
    const html = `
      <html>
        <head>
          <script type="application/ld+json">
            {
              "@context": "https://schema.org",
              "@type": "Product",
              "name": "Industrial Gloves",
              "description": "Heavy duty nitrile gloves",
              "sku": "GLV-100",
              "brand": { "@type": "Brand", "name": "SafeCo" },
              "image": "https://example.com/glove.jpg",
              "offers": { "@type": "Offer", "price": "24.50", "priceCurrency": "USD" }
            }
          </script>
        </head>
        <body><h1>Industrial Gloves</h1></body>
      </html>
    `;

    const scraper = createUrlScraper({
      fetchFn: vi.fn(async () => mockResponse({
        body: html,
        url: 'https://example.com/products/gloves',
      })) as unknown as typeof fetch,
      createModel: () => ({
        generateContent: vi.fn(async () => ({ response: { text: () => '{}' } })),
      }),
    });

    const result = await scraper.scrapeUrls(['https://example.com/products/gloves']);
    const item = result.results[0].item;

    expect(item.itemName).toBe('Industrial Gloves');
    expect(item.supplier).toBe('SafeCo');
    expect(item.price).toBe(24.5);
    expect(item.vendorSku).toBe('GLV-100');
    expect(result.results[0].extractionSource).toBe('html-metadata');
  });

  it('uses AI fallback when deterministic extraction is missing key fields', async () => {
    const model = {
      generateContent: vi.fn(async () => ({
        response: {
          text: () => JSON.stringify({
            itemName: 'AI Parsed Item',
            supplier: 'Acme Corp',
            price: 89.99,
            currency: 'USD',
            description: 'AI description',
            vendorSku: 'ACME-99',
            imageUrl: 'https://example.com/ai-image.jpg',
          }),
        },
      })),
    };

    const scraper = createUrlScraper({
      fetchFn: vi.fn(async () => mockResponse({
        body: '<html><head><title>Product page</title></head><body>Minimal content</body></html>',
        url: 'https://supplier.com/item/99',
      })) as unknown as typeof fetch,
      createModel: () => model,
    });

    const result = await scraper.scrapeUrls(['https://supplier.com/item/99']);

    expect(model.generateContent).toHaveBeenCalled();
    expect(result.results[0].item.itemName).toBe('AI Parsed Item');
    expect(result.results[0].item.vendorSku).toBe('ACME-99');
    expect(result.results[0].extractionSource).toBe('hybrid-ai');
  });

  it('returns per-URL failures without failing the whole batch', async () => {
    const fetchFn = vi.fn(async (url: string) => {
      if (url.includes('bad.example')) {
        throw new Error('timeout');
      }
      return mockResponse({
        body: '<html><head><meta property="og:title" content="Good Item"/></head></html>',
        url,
      });
    }) as unknown as typeof fetch;

    const scraper = createUrlScraper({
      fetchFn,
      createModel: () => null as any,
    });

    const result = await scraper.scrapeUrls([
      'https://bad.example/item',
      'https://good.example/item',
    ]);

    expect(result.processed).toBe(2);
    expect(result.results.some(entry => entry.status === 'failed')).toBe(true);
    expect(result.results.some(entry => entry.status !== 'failed')).toBe(true);
  });

  it('rejects local/private URLs via validation guard', () => {
    expect(validatePublicHttpUrl('http://127.0.0.1:8080').valid).toBe(false);
    expect(validatePublicHttpUrl('http://localhost/test').valid).toBe(false);
    expect(validatePublicHttpUrl('https://192.168.1.2').valid).toBe(false);
    expect(validatePublicHttpUrl('https://example.com').valid).toBe(true);
  });
});

```

### `server/src/services/urlScraper.ts`

```typescript
import { isIP } from 'node:net';
import {
  createAffiliateUrl,
  amazonService,
} from './amazon.js';
import { createGeminiExtractionModel } from './emailExtraction.js';
import {
  cleanUrlCandidate,
  extractImageUrlsFromHtml,
  looksLikeImageUrl,
} from '../utils/urlExtraction.js';

const MAX_HTML_BYTES = 2_000_000;
const FETCH_TIMEOUT_MS = 10_000;
const CONCURRENCY_LIMIT = 5;

export type UrlExtractionSource = 'amazon-paapi' | 'html-metadata' | 'hybrid-ai' | 'error';

export interface UrlScrapedItem {
  sourceUrl: string;
  productUrl?: string;
  imageUrl?: string;
  itemName?: string;
  supplier?: string;
  price?: number;
  currency?: string;
  description?: string;
  vendorSku?: string;
  asin?: string;
  needsReview: boolean;
  extractionSource: UrlExtractionSource;
  confidence: number;
}

export interface UrlScrapeResult {
  sourceUrl: string;
  normalizedUrl?: string;
  status: 'success' | 'partial' | 'failed';
  message?: string;
  extractionSource: UrlExtractionSource;
  item: UrlScrapedItem;
}

export interface UrlScrapeResponse {
  requested: number;
  processed: number;
  results: UrlScrapeResult[];
  items: UrlScrapedItem[];
}

export interface UrlScraperDeps {
  fetchFn?: typeof fetch;
  createModel?: () => AiModel | null;
}

export interface AiModel {
  generateContent: (prompt: string) => Promise<{ response: { text: () => string } }>;
}

interface PageFetchResult {
  finalUrl: string;
  html: string;
  contentType: string;
}

interface DeterministicExtraction {
  productUrl?: string;
  imageUrl?: string;
  itemName?: string;
  supplier?: string;
  price?: number;
  currency?: string;
  description?: string;
  vendorSku?: string;
  extractionSource: UrlExtractionSource;
}

const AI_FALLBACK_PROMPT = `You extract ecommerce product details from webpage text and metadata.

Return strict JSON only with this exact shape:
{
  "itemName": string | null,
  "supplier": string | null,
  "price": number | null,
  "currency": string | null,
  "description": string | null,
  "vendorSku": string | null,
  "imageUrl": string | null
}

Rules:
- Do not invent information.
- If unknown, return null for that field.
- price must be numeric only (no symbols).
- supplier should be the brand/manufacturer/vendor name if present.`;

function timeoutSignal(ms: number): AbortSignal {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), ms);
  controller.signal.addEventListener('abort', () => clearTimeout(timeout), { once: true });
  return controller.signal;
}

function titleCaseWord(word: string): string {
  if (!word) return word;
  return `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`;
}

function inferSupplierFromUrl(url: string): string | undefined {
  try {
    const hostname = new URL(url).hostname.replace(/^www\./i, '');
    const root = hostname.split('.')[0] || '';
    if (!root) return undefined;
    return root
      .split(/[-_]+/g)
      .filter(Boolean)
      .map(titleCaseWord)
      .join(' ');
  } catch {
    return undefined;
  }
}

function normalizeAsNumber(input: unknown): number | undefined {
  if (typeof input === 'number' && Number.isFinite(input)) {
    return input;
  }

  if (typeof input !== 'string') return undefined;
  const match = input.match(/-?\d+(?:\.\d+)?/);
  if (!match) return undefined;
  const value = Number.parseFloat(match[0]);
  return Number.isFinite(value) ? value : undefined;
}

function decodeHtmlEntities(value: string): string {
  return value
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'");
}

function stripHtmlTags(html: string): string {
  return decodeHtmlEntities(
    html
      .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, ' ')
      .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, ' ')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
  ).trim();
}

function extractTitle(html: string): string | undefined {
  const match = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
  if (!match?.[1]) return undefined;
  return decodeHtmlEntities(match[1]).trim();
}

function extractH1(html: string): string | undefined {
  const match = html.match(/<h1[^>]*>([\s\S]*?)<\/h1>/i);
  if (!match?.[1]) return undefined;
  return decodeHtmlEntities(match[1].replace(/<[^>]+>/g, ' ')).replace(/\s+/g, ' ').trim();
}

function readMetaContent(html: string, key: string): string | undefined {
  const escaped = key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const patterns = [
    new RegExp(`<meta[^>]*property=["']${escaped}["'][^>]*content=["']([^"']+)["'][^>]*>`, 'i'),
    new RegExp(`<meta[^>]*name=["']${escaped}["'][^>]*content=["']([^"']+)["'][^>]*>`, 'i'),
    new RegExp(`<meta[^>]*content=["']([^"']+)["'][^>]*(?:property|name)=["']${escaped}["'][^>]*>`, 'i'),
  ];

  for (const pattern of patterns) {
    const match = html.match(pattern);
    if (match?.[1]) {
      return decodeHtmlEntities(match[1]).trim();
    }
  }
  return undefined;
}

function readCanonicalUrl(html: string): string | undefined {
  const match = html.match(/<link[^>]*rel=["']canonical["'][^>]*href=["']([^"']+)["'][^>]*>/i)
    || html.match(/<link[^>]*href=["']([^"']+)["'][^>]*rel=["']canonical["'][^>]*>/i);
  if (!match?.[1]) return undefined;
  return cleanUrlCandidate(match[1]) || undefined;
}

function parseJson<T>(value: string): T | null {
  try {
    return JSON.parse(value) as T;
  } catch {
    return null;
  }
}

function normalizeJsonLdNode(node: unknown): unknown[] {
  if (!node) return [];
  if (Array.isArray(node)) {
    return node.flatMap(entry => normalizeJsonLdNode(entry));
  }

  if (typeof node !== 'object') return [];

  const obj = node as Record<string, unknown>;
  if (Array.isArray(obj['@graph'])) {
    return normalizeJsonLdNode(obj['@graph']);
  }

  return [obj];
}

function isProductNode(node: Record<string, unknown>): boolean {
  const t = node['@type'];
  if (typeof t === 'string') {
    return t.toLowerCase().includes('product');
  }
  if (Array.isArray(t)) {
    return t.some(entry => typeof entry === 'string' && entry.toLowerCase().includes('product'));
  }
  return false;
}

function firstString(value: unknown): string | undefined {
  if (typeof value === 'string' && value.trim()) return value.trim();
  if (Array.isArray(value)) {
    for (const entry of value) {
      if (typeof entry === 'string' && entry.trim()) return entry.trim();
      if (entry && typeof entry === 'object') {
        const nested = firstString((entry as Record<string, unknown>).url);
        if (nested) return nested;
      }
    }
  }
  if (value && typeof value === 'object') {
    const obj = value as Record<string, unknown>;
    const nested = firstString(obj.url) || firstString(obj.contentUrl);
    if (nested) return nested;
  }
  return undefined;
}

function normalizeCurrency(value: unknown): string | undefined {
  if (typeof value !== 'string') return undefined;
  const trimmed = value.trim();
  if (!trimmed) return undefined;
  if (trimmed.length <= 5) return trimmed.toUpperCase();
  return trimmed;
}

function extractPriceFromText(text: string): number | undefined {
  const match = text.match(/(?:\$|USD\s*)\s*(\d{1,6}(?:\.\d{1,2})?)/i);
  if (!match?.[1]) return undefined;
  const value = Number.parseFloat(match[1]);
  return Number.isFinite(value) ? value : undefined;
}

function extractJsonLdProduct(html: string): Partial<DeterministicExtraction> {
  const scripts = Array.from(
    html.matchAll(/<script[^>]*type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi)
  ).map(match => match[1]?.trim()).filter(Boolean) as string[];

  for (const scriptContent of scripts) {
    const parsed = parseJson<unknown>(scriptContent);
    if (!parsed) continue;

    const nodes = normalizeJsonLdNode(parsed);
    const productNode = nodes.find(node => {
      if (!node || typeof node !== 'object') return false;
      return isProductNode(node as Record<string, unknown>);
    }) as Record<string, unknown> | undefined;

    if (!productNode) continue;

    const offersRaw = productNode.offers;
    const offers = Array.isArray(offersRaw)
      ? (offersRaw[0] as Record<string, unknown> | undefined)
      : (offersRaw as Record<string, unknown> | undefined);

    const brand = productNode.brand;
    const brandName = typeof brand === 'string'
      ? brand
      : typeof brand === 'object' && brand !== null
        ? firstString((brand as Record<string, unknown>).name)
        : undefined;

    const supplier = brandName
      || firstString(productNode.manufacturer)
      || firstString(productNode.seller)
      || firstString(productNode.vendor);

    return {
      itemName: firstString(productNode.name),
      description: firstString(productNode.description),
      vendorSku: firstString(productNode.sku) || firstString(productNode.mpn) || firstString(productNode.productID),
      supplier,
      productUrl: cleanUrlCandidate(firstString(productNode.url) || '') || undefined,
      imageUrl: cleanUrlCandidate(firstString(productNode.image) || '') || undefined,
      price: normalizeAsNumber(offers?.price),
      currency: normalizeCurrency(offers?.priceCurrency),
    };
  }

  return {};
}

function mergeDeterministicData(html: string, finalUrl: string): DeterministicExtraction {
  const jsonLd = extractJsonLdProduct(html);

  const ogTitle = readMetaContent(html, 'og:title');
  const ogDescription = readMetaContent(html, 'og:description') || readMetaContent(html, 'description');
  const ogImage = readMetaContent(html, 'og:image') || readMetaContent(html, 'twitter:image');
  const ogPrice = readMetaContent(html, 'product:price:amount') || readMetaContent(html, 'og:price:amount');
  const ogCurrency = readMetaContent(html, 'product:price:currency') || readMetaContent(html, 'og:price:currency');
  const title = extractTitle(html);
  const h1 = extractH1(html);

  const imageCandidates = extractImageUrlsFromHtml(html);
  const imageFromMeta = cleanUrlCandidate(ogImage || '');
  const imageUrl = jsonLd.imageUrl
    || imageFromMeta
    || imageCandidates.find(looksLikeImageUrl)
    || imageCandidates[0];

  const productUrl = jsonLd.productUrl
    || readCanonicalUrl(html)
    || cleanUrlCandidate(finalUrl)
    || finalUrl;

  const itemName = jsonLd.itemName || ogTitle || h1 || title;
  const description = jsonLd.description || ogDescription;
  const price = jsonLd.price ?? normalizeAsNumber(ogPrice) ?? extractPriceFromText(stripHtmlTags(html));
  const currency = jsonLd.currency || normalizeCurrency(ogCurrency);

  return {
    productUrl,
    imageUrl,
    itemName,
    supplier: jsonLd.supplier || inferSupplierFromUrl(finalUrl),
    price,
    currency,
    description,
    vendorSku: jsonLd.vendorSku,
    extractionSource: 'html-metadata',
  };
}

function parseAiJson(raw: string): Partial<DeterministicExtraction> {
  const jsonMatch = raw.match(/\{[\s\S]*\}/);
  if (!jsonMatch) return {};

  const parsed = parseJson<Record<string, unknown>>(jsonMatch[0]);
  if (!parsed) return {};

  return {
    itemName: firstString(parsed.itemName),
    supplier: firstString(parsed.supplier),
    price: normalizeAsNumber(parsed.price),
    currency: normalizeCurrency(parsed.currency),
    description: firstString(parsed.description),
    vendorSku: firstString(parsed.vendorSku),
    imageUrl: cleanUrlCandidate(firstString(parsed.imageUrl) || '') || undefined,
  };
}

async function maybeFillWithAi(
  model: AiModel | null,
  html: string,
  finalUrl: string,
  deterministic: DeterministicExtraction
): Promise<Partial<DeterministicExtraction>> {
  if (!model) return {};

  const missingFields = [
    !deterministic.itemName,
    !deterministic.supplier,
    deterministic.price === undefined,
    !deterministic.description,
    !deterministic.vendorSku,
    !deterministic.imageUrl,
  ].some(Boolean);

  if (!missingFields) return {};

  const prompt = `${AI_FALLBACK_PROMPT}\n\nURL: ${finalUrl}\n\nDeterministic metadata:\n${JSON.stringify(deterministic)}\n\nPage text:\n${stripHtmlTags(html).slice(0, 5000)}`;

  try {
    const result = await model.generateContent(prompt);
    const text = result.response.text();
    return parseAiJson(text);
  } catch {
    return {};
  }
}

async function fetchPage(fetchFn: typeof fetch, rawUrl: string): Promise<PageFetchResult> {
  const response = await fetchFn(rawUrl, {
    method: 'GET',
    redirect: 'follow',
    signal: timeoutSignal(FETCH_TIMEOUT_MS),
    headers: {
      'User-Agent': 'OrderPulseBot/1.0 (+https://orderpulse.local)',
      Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    },
  });

  if (!response.ok) {
    throw new Error(`Fetch failed with status ${response.status}`);
  }

  const contentLength = Number.parseInt(response.headers.get('content-length') || '0', 10);
  if (Number.isFinite(contentLength) && contentLength > MAX_HTML_BYTES) {
    throw new Error('Page exceeds maximum size');
  }

  const html = await response.text();
  if (html.length > MAX_HTML_BYTES) {
    throw new Error('Page exceeds maximum size');
  }

  return {
    finalUrl: response.url || rawUrl,
    html,
    contentType: response.headers.get('content-type') || '',
  };
}

function isAmazonLikeHost(hostname: string): boolean {
  const lower = hostname.toLowerCase();
  return lower.includes('amazon.') || lower === 'amzn.to' || lower === 'a.co';
}

function isPrivateIpv4(hostname: string): boolean {
  const parts = hostname.split('.').map(segment => Number.parseInt(segment, 10));
  if (parts.length !== 4 || parts.some(Number.isNaN)) return false;

  const [a, b] = parts;
  if (a === 10 || a === 127 || a === 0) return true;
  if (a === 169 && b === 254) return true;
  if (a === 172 && b >= 16 && b <= 31) return true;
  if (a === 192 && b === 168) return true;
  return false;
}

function isPrivateIpv6(hostname: string): boolean {
  const lower = hostname.toLowerCase();
  if (lower === '::1') return true;
  if (lower.startsWith('fe80:')) return true;
  if (lower.startsWith('fc') || lower.startsWith('fd')) return true;
  return false;
}

export function validatePublicHttpUrl(rawUrl: string): { valid: true; normalized: string } | { valid: false; reason: string } {
  const normalized = cleanUrlCandidate(rawUrl || '');
  if (!normalized) {
    return { valid: false, reason: 'URL must be a valid http/https URL' };
  }

  try {
    const parsed = new URL(normalized);
    if (!['http:', 'https:'].includes(parsed.protocol)) {
      return { valid: false, reason: 'URL must use http or https' };
    }

    const hostname = parsed.hostname.toLowerCase();
    if (!hostname) {
      return { valid: false, reason: 'URL hostname is missing' };
    }

    if (
      hostname === 'localhost'
      || hostname.endsWith('.local')
      || hostname === '0.0.0.0'
      || hostname === '::1'
    ) {
      return { valid: false, reason: 'Local and loopback hosts are not allowed' };
    }

    const ipVersion = isIP(hostname);
    if (ipVersion === 4 && isPrivateIpv4(hostname)) {
      return { valid: false, reason: 'Private-network hosts are not allowed' };
    }
    if (ipVersion === 6 && isPrivateIpv6(hostname)) {
      return { valid: false, reason: 'Private-network hosts are not allowed' };
    }

    return { valid: true, normalized };
  } catch {
    return { valid: false, reason: 'Invalid URL' };
  }
}

function buildFailureItem(sourceUrl: string, normalizedUrl: string | undefined, supplier?: string): UrlScrapedItem {
  return {
    sourceUrl,
    productUrl: normalizedUrl || sourceUrl,
    itemName: supplier ? `${supplier} Product` : undefined,
    supplier,
    needsReview: true,
    extractionSource: 'error',
    confidence: 0,
  };
}

function toResultStatus(item: UrlScrapedItem): 'success' | 'partial' | 'failed' {
  const hasCore = Boolean(item.itemName && item.supplier && item.productUrl);
  const hasDetails = item.price !== undefined || Boolean(item.imageUrl || item.description || item.vendorSku);
  if (hasCore && hasDetails && !item.needsReview) return 'success';
  if (hasCore || hasDetails) return 'partial';
  return 'failed';
}

async function scrapeOneUrl(
  fetchFn: typeof fetch,
  model: AiModel | null,
  sourceUrl: string
): Promise<UrlScrapeResult> {
  const validation = validatePublicHttpUrl(sourceUrl);
  if (!validation.valid) {
    const item = buildFailureItem(sourceUrl, undefined, undefined);
    return {
      sourceUrl,
      status: 'failed',
      message: validation.reason,
      extractionSource: 'error',
      item,
    };
  }

  const normalizedUrl = validation.normalized;

  try {
    const fetched = await fetchPage(fetchFn, normalizedUrl);
    const finalUrl = cleanUrlCandidate(fetched.finalUrl) || normalizedUrl;

    const finalHost = new URL(finalUrl).hostname;
    if (isAmazonLikeHost(finalHost)) {
      const asin = amazonService.extractAsinFromUrl(finalUrl) || amazonService.extractAsinFromUrl(normalizedUrl);
      if (!asin) {
        const supplier = inferSupplierFromUrl(finalUrl) || 'Amazon';
        const item: UrlScrapedItem = {
          ...buildFailureItem(sourceUrl, finalUrl, supplier),
          extractionSource: 'amazon-paapi',
          confidence: 0.45,
        };
        return {
          sourceUrl,
          normalizedUrl,
          status: 'partial',
          message: 'Amazon URL detected but ASIN was not found',
          extractionSource: 'amazon-paapi',
          item,
        };
      }

      const enriched = await amazonService.enrichItemWithAmazon(asin);
      const price = enriched?.UnitPrice ?? normalizeAsNumber(enriched?.Price);
      const productUrl = enriched?.AmazonURL || createAffiliateUrl(asin);
      const item: UrlScrapedItem = {
        sourceUrl,
        productUrl,
        imageUrl: enriched?.ImageURL,
        itemName: enriched?.ItemName || `Amazon Item ${asin}`,
        supplier: 'Amazon',
        price,
        currency: 'USD',
        description: undefined,
        vendorSku: enriched?.UPC,
        asin,
        needsReview: !(enriched?.ItemName && price !== undefined && enriched?.ImageURL),
        extractionSource: 'amazon-paapi',
        confidence: enriched ? 0.95 : 0.7,
      };

      return {
        sourceUrl,
        normalizedUrl,
        status: toResultStatus(item),
        extractionSource: 'amazon-paapi',
        item,
      };
    }

    const deterministic = mergeDeterministicData(fetched.html, finalUrl);
    const aiFill = await maybeFillWithAi(model, fetched.html, finalUrl, deterministic);

    const finalExtraction: DeterministicExtraction = {
      ...deterministic,
      ...Object.fromEntries(
        Object.entries(aiFill).filter(([, value]) => value !== undefined)
      ),
      extractionSource: Object.keys(aiFill).length > 0 ? 'hybrid-ai' : 'html-metadata',
    };

    const supplier = finalExtraction.supplier || inferSupplierFromUrl(finalUrl);
    const item: UrlScrapedItem = {
      sourceUrl,
      productUrl: finalExtraction.productUrl || finalUrl,
      imageUrl: finalExtraction.imageUrl,
      itemName: finalExtraction.itemName,
      supplier,
      price: finalExtraction.price,
      currency: finalExtraction.currency,
      description: finalExtraction.description,
      vendorSku: finalExtraction.vendorSku,
      needsReview: !(
        finalExtraction.itemName
        && supplier
        && finalExtraction.price !== undefined
        && finalExtraction.imageUrl
      ),
      extractionSource: finalExtraction.extractionSource,
      confidence: finalExtraction.extractionSource === 'hybrid-ai' ? 0.72 : 0.64,
    };

    return {
      sourceUrl,
      normalizedUrl,
      status: toResultStatus(item),
      extractionSource: finalExtraction.extractionSource,
      item,
      message: fetched.contentType && !fetched.contentType.toLowerCase().includes('html')
        ? `Non-HTML content type: ${fetched.contentType}`
        : undefined,
    };
  } catch (error) {
    const supplier = inferSupplierFromUrl(normalizedUrl);
    const item: UrlScrapedItem = {
      ...buildFailureItem(sourceUrl, normalizedUrl, supplier),
      extractionSource: 'error',
      confidence: 0,
    };

    return {
      sourceUrl,
      normalizedUrl,
      status: 'failed',
      message: error instanceof Error ? error.message : 'Failed to scrape URL',
      extractionSource: 'error',
      item,
    };
  }
}

async function mapWithConcurrency<T, R>(
  values: T[],
  concurrency: number,
  mapper: (value: T, index: number) => Promise<R>
): Promise<R[]> {
  const results = new Array<R>(values.length);
  let nextIndex = 0;

  const workers = Array.from({ length: Math.min(concurrency, values.length) }).map(async () => {
    while (true) {
      const current = nextIndex;
      nextIndex += 1;
      if (current >= values.length) {
        return;
      }
      results[current] = await mapper(values[current], current);
    }
  });

  await Promise.all(workers);
  return results;
}

export function createUrlScraper(deps: UrlScraperDeps = {}) {
  const fetchFn = deps.fetchFn || fetch;
  const createModel = deps.createModel || (() => {
    if (!process.env.GEMINI_API_KEY) return null;
    return createGeminiExtractionModel();
  });

  async function scrapeUrls(urls: string[]): Promise<UrlScrapeResponse> {
    const model = createModel ? createModel() : null;
    const results = await mapWithConcurrency(urls, CONCURRENCY_LIMIT, async (url) => (
      scrapeOneUrl(fetchFn, model, url)
    ));

    return {
      requested: urls.length,
      processed: results.length,
      results,
      items: results.map(result => result.item),
    };
  }

  return { scrapeUrls };
}

export const urlScraper = createUrlScraper();

```

### `server/src/services/userStore.ts`

```typescript
import { pool } from '../db/index.js'
import redisClient from '../utils/redisClient.js'
import type { Pool, PoolClient } from 'pg'

export interface StoredUser {
  id: string
  googleId?: string | null
  googleEmail?: string | null
  email: string
  name: string
  picture: string
  accessToken: string
  refreshToken: string
  expiresAt: Date
  passwordHash?: string | null
}

interface StoredUserRow {
  id: string
  google_id: string | null
  google_email: string | null
  email: string
  name: string
  picture: string
  access_token: string
  refresh_token: string
  expires_at: string | Date
  password_hash: string | null
}

const CACHE_KEY = (id: string) => `auth:user:${id}`

// Ensure the users table exists (idempotent) so we have durable storage for auth users
async function ensureTable() {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY,
      google_id TEXT,
      google_email TEXT,
      email TEXT NOT NULL,
      name TEXT DEFAULT '' NOT NULL,
      picture TEXT DEFAULT '' NOT NULL,
      access_token TEXT DEFAULT '' NOT NULL,
      refresh_token TEXT DEFAULT '' NOT NULL,
      password_hash TEXT,
      expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
      created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
      updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
    );
  `)

  // Backfill older installations where users table existed before google_email/token columns were added.
  await pool.query(`
    ALTER TABLE users ADD COLUMN IF NOT EXISTS google_id TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS google_email TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS email TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS name TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS picture TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS access_token TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS refresh_token TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS password_hash TEXT;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS expires_at TIMESTAMP WITH TIME ZONE;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ;
    ALTER TABLE users ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ;
  `)

  await pool.query(`
    UPDATE users
    SET name = COALESCE(name, ''),
        picture = COALESCE(picture, ''),
        access_token = COALESCE(access_token, ''),
        refresh_token = COALESCE(refresh_token, ''),
        created_at = COALESCE(created_at, now()),
        updated_at = COALESCE(updated_at, now()),
        expires_at = COALESCE(expires_at, now());
  `)

  await pool.query(`
    ALTER TABLE users ALTER COLUMN name SET DEFAULT '';
    ALTER TABLE users ALTER COLUMN picture SET DEFAULT '';
    ALTER TABLE users ALTER COLUMN access_token SET DEFAULT '';
    ALTER TABLE users ALTER COLUMN refresh_token SET DEFAULT '';
    ALTER TABLE users ALTER COLUMN created_at SET DEFAULT now();
    ALTER TABLE users ALTER COLUMN updated_at SET DEFAULT now();
  `)

  await pool.query(`
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    CREATE INDEX IF NOT EXISTS idx_users_google_id ON users(google_id);
    CREATE INDEX IF NOT EXISTS idx_users_google_email ON users(google_email);
  `)
}

let ensureTablePromise: Promise<void> | null = null

async function ensureTableReady(): Promise<void> {
  if (!ensureTablePromise) {
    ensureTablePromise = ensureTable().catch((error) => {
      ensureTablePromise = null
      throw error
    })
  }
  return ensureTablePromise
}

// Kick table creation on module load, but do not crash process if DB is temporarily unavailable.
void ensureTableReady().catch((error) => {
  console.error('Failed to ensure auth users table on startup:', error)
})

async function cacheUser(user: StoredUser) {
  if (!redisClient) return
  await redisClient.set(CACHE_KEY(user.id), JSON.stringify(user))
}

function mapUser(row: StoredUserRow): StoredUser {
  return {
    id: row.id,
    googleId: row.google_id,
    googleEmail: row.google_email,
    email: row.email,
    name: row.name,
    picture: row.picture,
    accessToken: row.access_token,
    refreshToken: row.refresh_token,
    expiresAt: new Date(row.expires_at),
    passwordHash: row.password_hash,
  }
}

export async function saveUser(user: StoredUser): Promise<void> {
  await ensureTableReady()
  await pool.query(
    `INSERT INTO users (id, google_id, google_email, email, name, picture, access_token, refresh_token, password_hash, expires_at, updated_at)
     VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10, now())
     ON CONFLICT (id) DO UPDATE SET
       google_id = EXCLUDED.google_id,
       google_email = EXCLUDED.google_email,
       email = EXCLUDED.email,
       name = EXCLUDED.name,
       picture = EXCLUDED.picture,
       access_token = EXCLUDED.access_token,
       refresh_token = EXCLUDED.refresh_token,
       password_hash = EXCLUDED.password_hash,
       expires_at = EXCLUDED.expires_at,
       updated_at = now()
    `,
    [
      user.id,
      user.googleId ?? null,
      user.googleEmail ?? null,
      user.email,
      user.name,
      user.picture,
      user.accessToken,
      user.refreshToken,
      user.passwordHash ?? null,
      user.expiresAt,
    ]
  )
  await cacheUser(user)
}

export async function deleteUser(userId: string): Promise<void> {
  await ensureTableReady()
  await pool.query('DELETE FROM users WHERE id = $1', [userId])
  if (redisClient) {
    await redisClient.del(CACHE_KEY(userId))
  }
}

export async function getUserById(userId: string): Promise<StoredUser | null> {
  await ensureTableReady()
  // Redis cache first
  if (redisClient) {
    const cached = await redisClient.get(CACHE_KEY(userId))
    if (cached) {
      const parsed = JSON.parse(cached) as StoredUser
      parsed.expiresAt = new Date(parsed.expiresAt)
      return parsed
    }
  }

  const result = await pool.query<StoredUserRow>('SELECT * FROM users WHERE id = $1', [userId])
  if (result.rowCount === 0) return null

  const user = mapUser(result.rows[0])

  await cacheUser(user)
  return user
}

export async function getUserByEmail(email: string): Promise<StoredUser | null> {
  await ensureTableReady()
  const result = await pool.query<StoredUserRow>('SELECT * FROM users WHERE email = $1', [email])
  if (result.rowCount === 0) return null
  const user = mapUser(result.rows[0])
  await cacheUser(user)
  return user
}

export async function getUserByGoogleId(googleId: string): Promise<StoredUser | null> {
  await ensureTableReady()
  const result = await pool.query<StoredUserRow>('SELECT * FROM users WHERE google_id = $1', [googleId])
  if (result.rowCount === 0) return null
  const user = mapUser(result.rows[0])
  await cacheUser(user)
  return user
}

async function tableExists(tableName: string, client: Pool | PoolClient = pool): Promise<boolean> {
  const result = await client.query<{ name: string | null }>('SELECT to_regclass($1) as name', [tableName])
  return Boolean(result.rows[0]?.name)
}

export async function mergeUsers(sourceUserId: string, targetUserId: string): Promise<void> {
  if (sourceUserId === targetUserId) return
  await ensureTableReady()

  const client = await pool.connect()
  try {
    await client.query('BEGIN')

    if (await tableExists('orders', client)) {
      await client.query('UPDATE orders SET user_id = $1 WHERE user_id = $2', [targetUserId, sourceUserId])
    }

    if (await tableExists('provider_connections', client)) {
      await client.query(
        `DELETE FROM provider_connections
         WHERE user_id = $2
           AND provider IN (SELECT provider FROM provider_connections WHERE user_id = $1)`,
        [targetUserId, sourceUserId],
      )
      await client.query('UPDATE provider_connections SET user_id = $1 WHERE user_id = $2', [targetUserId, sourceUserId])
    }

    if (await tableExists('oauth_tokens', client)) {
      await client.query('UPDATE oauth_tokens SET user_id = $1 WHERE user_id = $2', [targetUserId, sourceUserId])
    }

    await client.query('DELETE FROM users WHERE id = $1', [sourceUserId])

    await client.query('COMMIT')
  } catch (error) {
    await client.query('ROLLBACK')
    throw error
  } finally {
    client.release()
  }

  if (redisClient) {
    await redisClient.del(CACHE_KEY(sourceUserId))
    await redisClient.del(CACHE_KEY(targetUserId))
  }
}

export async function getUserEmail(userId: string): Promise<string | null> {
  const user = await getUserById(userId)
  return user?.email || null
}

```

### `server/src/types/amazon-paapi.d.ts`

```typescript
declare module 'amazon-paapi' {
  interface CommonParameters {
    AccessKey: string;
    SecretKey: string;
    PartnerTag: string;
    PartnerType: 'Associates';
    Marketplace: string;
  }

  interface GetItemsRequestParameters {
    ItemIds: string[];
    ItemIdType?: 'ASIN' | 'UPC' | 'EAN';
    Condition?: 'Any' | 'New' | 'Used' | 'Collectible' | 'Refurbished';
    Resources?: string[];
  }

  interface ItemResult {
    ASIN: string;
    DetailPageURL?: string;
    ItemInfo?: {
      Title?: {
        DisplayValue?: string;
      };
      ProductInfo?: {
        UnitCount?: {
          DisplayValue?: number;
        };
      };
      ExternalIds?: {
        UPCs?: {
          DisplayValues?: string[];
        };
      };
    };
    Images?: {
      Primary?: {
        Large?: {
          URL?: string;
        };
      };
    };
    Offers?: {
      Listings?: Array<{
        Price?: {
          DisplayAmount?: string;
          Amount?: number;
        };
      }>;
    };
  }

  interface GetItemsResponse {
    ItemsResult?: {
      Items?: ItemResult[];
    };
    Errors?: Array<{
      Code?: string;
      Message?: string;
    }>;
  }

  function GetItems(
    commonParameters: CommonParameters,
    requestParameters: GetItemsRequestParameters
  ): Promise<GetItemsResponse>;

  export default {
    GetItems,
  };
}

```

### `server/src/utils/encryption.ts`

```typescript
import CryptoJS from 'crypto-js';
import dotenv from 'dotenv';

dotenv.config();

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'default-dev-key-change-in-prod';

export function encrypt(text: string): string {
  return CryptoJS.AES.encrypt(text, ENCRYPTION_KEY).toString();
}

export function decrypt(ciphertext: string): string {
  const bytes = CryptoJS.AES.decrypt(ciphertext, ENCRYPTION_KEY);
  return bytes.toString(CryptoJS.enc.Utf8);
}

```

### `server/src/utils/loadEnv.ts`

```typescript
// Load environment variables from .env file in development
import { config } from 'dotenv';

// Only load .env in non-production (Railway sets env vars directly)
if (process.env.NODE_ENV !== 'production' && !process.env.RAILWAY_ENVIRONMENT) {
  config();
}

```

### `server/src/utils/orderConsolidation.ts`

```typescript
/**
 * Order Consolidation Utility
 * 
 * Deduplicates orders from the same vendor by:
 * 1. Detecting order numbers across multiple emails
 * 2. Matching items across emails from the same supplier
 * 3. Identifying email types (order, shipped, delivered)
 * 4. Calculating lead times from order to delivery
 */

export type OrderEmailType = 'order' | 'shipped' | 'delivered' | 'unknown';

export interface OrderEmail {
  emailId: string;
  emailType: OrderEmailType;
  date: string;
  subject: string;
}

export interface RawOrderData {
  id: string;
  emailId: string;
  subject: string;
  supplier: string;
  orderNumber?: string;
  orderDate: string;
  totalAmount?: number;
  items: Array<{
    id: string;
    name: string;
    normalizedName?: string;
    quantity: number;
    unit: string;
    unitPrice?: number;
    asin?: string;
    sku?: string;
    productUrl?: string;
    imageUrl?: string;
    amazonEnriched?: any;
  }>;
  confidence: number;
}

export interface ConsolidatedOrder {
  id: string;
  originalEmailId: string;
  supplier: string;
  orderNumber?: string;
  orderDate: string;
  shippedDate?: string;
  deliveredDate?: string;
  leadTimeDays?: number;
  totalAmount?: number;
  items: Array<{
    id: string;
    name: string;
    normalizedName?: string;
    quantity: number;
    unit: string;
    unitPrice?: number;
    asin?: string;
    sku?: string;
    productUrl?: string;
    imageUrl?: string;
    amazonEnriched?: any;
  }>;
  confidence: number;
  relatedEmails: OrderEmail[];
}

/**
 * Detect email type from subject line
 */
export function detectEmailType(subject: string): OrderEmailType {
  const lowerSubject = subject.toLowerCase();
  
  // Delivery keywords (check first as they're most specific)
  if (
    lowerSubject.includes('delivered') ||
    lowerSubject.includes('delivery confirmation') ||
    lowerSubject.includes('has arrived') ||
    lowerSubject.includes('was delivered') ||
    lowerSubject.includes('package delivered')
  ) {
    return 'delivered';
  }
  
  // Shipping keywords
  if (
    lowerSubject.includes('shipped') ||
    lowerSubject.includes('shipment') ||
    lowerSubject.includes('on its way') ||
    lowerSubject.includes('out for delivery') ||
    lowerSubject.includes('tracking') ||
    lowerSubject.includes('dispatched') ||
    lowerSubject.includes('in transit')
  ) {
    return 'shipped';
  }
  
  // Order confirmation keywords
  if (
    lowerSubject.includes('order confirmation') ||
    lowerSubject.includes('order received') ||
    lowerSubject.includes('order placed') ||
    lowerSubject.includes('thank you for your order') ||
    lowerSubject.includes('order #') ||
    lowerSubject.includes('purchase confirmation') ||
    lowerSubject.includes('invoice') ||
    lowerSubject.includes('receipt')
  ) {
    return 'order';
  }
  
  return 'unknown';
}

/**
 * Extract order number from email subject or body
 */
export function extractOrderNumber(subject: string, body?: string): string | undefined {
  const text = `${subject} ${body || ''}`;
  
  // Common order number patterns
  const patterns = [
    // Amazon: 123-1234567-1234567
    /(?:order|confirmation)\s*#?\s*:?\s*(\d{3}-\d{7}-\d{7})/i,
    // Generic: Order #12345 or Order: 12345
    /(?:order|confirmation|invoice)\s*#?\s*:?\s*([A-Z0-9-]{5,20})/i,
    // PO number: PO-12345 or PO#12345
    /(?:po|purchase\s*order)\s*#?\s*:?\s*([A-Z0-9-]{4,15})/i,
    // Reference number
    /(?:reference|ref)\s*#?\s*:?\s*([A-Z0-9-]{5,15})/i,
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  
  return undefined;
}

/**
 * Normalize item name for matching
 */
export function normalizeItemName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '') // Remove special characters
    .replace(/\s+/g, ' ')         // Normalize whitespace
    .trim()
    .substring(0, 50);            // Limit length for comparison
}

/**
 * Check if two items are likely the same
 */
function areItemsSimilar(item1: RawOrderData['items'][0], item2: RawOrderData['items'][0]): boolean {
  // Match by ASIN (most reliable for Amazon)
  if (item1.asin && item2.asin && item1.asin === item2.asin) {
    return true;
  }
  
  // Match by SKU
  if (item1.sku && item2.sku && item1.sku === item2.sku) {
    return true;
  }
  
  // Match by normalized name
  const name1 = item1.normalizedName || normalizeItemName(item1.name);
  const name2 = item2.normalizedName || normalizeItemName(item2.name);
  
  if (name1 === name2) {
    return true;
  }
  
  // Fuzzy match: check if one name contains the other (for partial matches)
  if (name1.length > 10 && name2.length > 10) {
    if (name1.includes(name2) || name2.includes(name1)) {
      return true;
    }
  }
  
  return false;
}

/**
 * Check if two orders are related (same order from different emails)
 */
function areOrdersRelated(order1: RawOrderData, order2: RawOrderData): boolean {
  // Different suppliers = not related
  if (order1.supplier.toLowerCase() !== order2.supplier.toLowerCase()) {
    return false;
  }
  
  // Same order number = definitely related
  if (order1.orderNumber && order2.orderNumber && order1.orderNumber === order2.orderNumber) {
    return true;
  }
  
  // Check if items match (at least 50% overlap)
  const items1 = order1.items;
  const items2 = order2.items;
  
  if (items1.length === 0 || items2.length === 0) {
    return false;
  }
  
  let matchCount = 0;
  for (const item1 of items1) {
    for (const item2 of items2) {
      if (areItemsSimilar(item1, item2)) {
        matchCount++;
        break;
      }
    }
  }
  
  const overlapRatio = matchCount / Math.min(items1.length, items2.length);
  return overlapRatio >= 0.5;
}

/**
 * Calculate lead time in days between two dates
 */
function calculateLeadTime(orderDate: string, deliveryDate: string): number {
  const order = new Date(orderDate);
  const delivery = new Date(deliveryDate);
  
  if (isNaN(order.getTime()) || isNaN(delivery.getTime())) {
    return 0;
  }
  
  const diffMs = delivery.getTime() - order.getTime();
  return Math.max(0, Math.round(diffMs / (1000 * 60 * 60 * 24)));
}

/**
 * Consolidate orders from the same vendor
 * Deduplicates and calculates lead times
 */
export function consolidateOrders(orders: RawOrderData[]): ConsolidatedOrder[] {
  if (orders.length === 0) return [];
  
  // Group orders by supplier
  const ordersBySupplier = new Map<string, RawOrderData[]>();
  for (const order of orders) {
    const key = order.supplier.toLowerCase();
    const existing = ordersBySupplier.get(key) || [];
    existing.push(order);
    ordersBySupplier.set(key, existing);
  }
  
  const consolidatedOrders: ConsolidatedOrder[] = [];
  
  for (const [_supplier, supplierOrders] of ordersBySupplier) {
    // Sort by date (oldest first)
    supplierOrders.sort((a, b) => new Date(a.orderDate).getTime() - new Date(b.orderDate).getTime());
    
    // Track which orders have been merged
    const merged = new Set<string>();
    
    for (let i = 0; i < supplierOrders.length; i++) {
      const order = supplierOrders[i];
      if (merged.has(order.id)) continue;
      
      const emailType = detectEmailType(order.subject);
      
      // Find related orders
      const relatedOrders: RawOrderData[] = [];
      for (let j = i + 1; j < supplierOrders.length; j++) {
        const otherOrder = supplierOrders[j];
        if (merged.has(otherOrder.id)) continue;
        
        if (areOrdersRelated(order, otherOrder)) {
          relatedOrders.push(otherOrder);
          merged.add(otherOrder.id);
        }
      }
      
      // Collect all related emails
      const relatedEmails: OrderEmail[] = [
        {
          emailId: order.emailId,
          emailType,
          date: order.orderDate,
          subject: order.subject,
        },
      ];
      
      // Merge items from related orders (deduplicate)
      const mergedItems: Map<string, RawOrderData['items'][0]> = new Map();
      
      // Add items from primary order
      for (const item of order.items) {
        const key = item.asin || item.sku || normalizeItemName(item.name);
        if (!mergedItems.has(key)) {
          mergedItems.set(key, { ...item });
        }
      }
      
      // Track dates for lead time calculation
      let orderDate = order.orderDate;
      let shippedDate: string | undefined;
      let deliveredDate: string | undefined;
      
      if (emailType === 'order') {
        orderDate = order.orderDate;
      } else if (emailType === 'shipped') {
        shippedDate = order.orderDate;
      } else if (emailType === 'delivered') {
        deliveredDate = order.orderDate;
      }
      
      // Process related orders
      for (const relatedOrder of relatedOrders) {
        const relatedEmailType = detectEmailType(relatedOrder.subject);
        
        relatedEmails.push({
          emailId: relatedOrder.emailId,
          emailType: relatedEmailType,
          date: relatedOrder.orderDate,
          subject: relatedOrder.subject,
        });
        
        // Update dates based on email type
        if (relatedEmailType === 'order' && !orderDate) {
          orderDate = relatedOrder.orderDate;
        } else if (relatedEmailType === 'shipped') {
          if (!shippedDate || new Date(relatedOrder.orderDate) < new Date(shippedDate)) {
            shippedDate = relatedOrder.orderDate;
          }
        } else if (relatedEmailType === 'delivered') {
          if (!deliveredDate || new Date(relatedOrder.orderDate) > new Date(deliveredDate)) {
            deliveredDate = relatedOrder.orderDate;
          }
        }
        
        // Merge items (prefer items with more data)
        for (const item of relatedOrder.items) {
          const key = item.asin || item.sku || normalizeItemName(item.name);
          const existing = mergedItems.get(key);
          
          if (!existing) {
            mergedItems.set(key, { ...item });
          } else {
            // Merge: keep the item with more data
            if (item.amazonEnriched && !existing.amazonEnriched) {
              mergedItems.set(key, { ...item });
            } else if (item.unitPrice && !existing.unitPrice) {
              existing.unitPrice = item.unitPrice;
            }
          }
        }
      }
      
      // Calculate lead time
      let leadTimeDays: number | undefined;
      if (orderDate && deliveredDate) {
        leadTimeDays = calculateLeadTime(orderDate, deliveredDate);
      }
      
      // Create consolidated order
      const consolidated: ConsolidatedOrder = {
        id: order.id,
        originalEmailId: order.emailId,
        supplier: order.supplier,
        orderNumber: order.orderNumber || relatedOrders.find(r => r.orderNumber)?.orderNumber,
        orderDate,
        shippedDate,
        deliveredDate,
        leadTimeDays,
        totalAmount: order.totalAmount || relatedOrders.reduce((sum, r) => sum + (r.totalAmount || 0), 0),
        items: Array.from(mergedItems.values()),
        confidence: Math.max(order.confidence, ...relatedOrders.map(r => r.confidence)),
        relatedEmails,
      };
      
      consolidatedOrders.push(consolidated);
    }
  }
  
  return consolidatedOrders;
}

/**
 * Log consolidation summary for debugging
 */
export function logConsolidationSummary(
  originalCount: number,
  consolidatedOrders: ConsolidatedOrder[]
): void {
  const deduped = originalCount - consolidatedOrders.length;
  const withLeadTime = consolidatedOrders.filter(o => o.leadTimeDays !== undefined).length;
  const avgLeadTime = consolidatedOrders
    .filter(o => o.leadTimeDays !== undefined)
    .reduce((sum, o) => sum + (o.leadTimeDays || 0), 0) / (withLeadTime || 1);
  
  console.log(`📊 Order Consolidation:`);
  console.log(`   Original: ${originalCount} orders`);
  console.log(`   Consolidated: ${consolidatedOrders.length} orders (${deduped} duplicates removed)`);
  console.log(`   With lead time: ${withLeadTime} orders (avg ${avgLeadTime.toFixed(1)} days)`);
}

```

### `server/src/utils/redisClient.ts`

```typescript
import Redis from 'ioredis';
import type { Redis as RedisClient } from 'ioredis';

const redisUrl = process.env.REDIS_URL;
let redisClient: RedisClient | null = null;

if (redisUrl) {
  try {
    const RedisCtor = Redis as unknown as new (url: string) => RedisClient;
    redisClient = new RedisCtor(redisUrl);
    redisClient.on('error', (error: Error) => {
      console.error('Redis connection error:', error);
    });
    redisClient.on('connect', () => {
      console.log('✅ Connected to Redis');
    });
  } catch (error) {
    console.warn('⚠️ Failed to connect to Redis:', error);
    redisClient = null;
  }
} else {
  // Redis is optional - app will use in-memory storage
  console.warn('⚠️ REDIS_URL not set; using in-memory storage (data will not persist across restarts)');
}

export default redisClient;

export async function closeRedisClient(): Promise<void> {
  if (!redisClient) return;
  try {
    await redisClient.quit();
  } catch (error) {
    console.error('Error closing Redis client:', error);
  }
}

```

### `server/src/utils/urlExtraction.ts`

```typescript
export function uniqueStrings(values: string[]): string[] {
  return Array.from(new Set(values));
}

export function cleanUrlCandidate(raw: string): string | null {
  const value = (raw || '')
    .trim()
    .replace(/&amp;/g, '&')
    .replace(/&#x2F;/g, '/')
    .replace(/&#47;/g, '/')
    .replace(/&#x3D;/g, '=')
    .replace(/&#61;/g, '=')
    .replace(/[)\],.;]+$/g, '');

  if (!/^https?:\/\//i.test(value)) {
    return null;
  }

  try {
    const parsed = new URL(value);
    stripTrackingParams(parsed);
    parsed.hash = '';
    return parsed.toString();
  } catch {
    return null;
  }
}

function stripTrackingParams(url: URL): void {
  const trackingKeys = new Set(['gclid', 'fbclid', 'mc_cid', 'mc_eid']);
  for (const key of Array.from(url.searchParams.keys())) {
    const normalized = key.toLowerCase();
    if (normalized.startsWith('utm_') || trackingKeys.has(normalized)) {
      url.searchParams.delete(key);
    }
  }
}

export function extractUrlsFromText(text: string): string[] {
  if (!text) return [];
  const re = /\bhttps?:\/\/[^\s"'<>]+/gi;
  const matches = Array.from(text.matchAll(re)).map(m => m[0]);
  const cleaned = matches.map(cleanUrlCandidate).filter((u): u is string => Boolean(u));
  return uniqueStrings(cleaned);
}

export function extractUrlsFromHtml(html: string): string[] {
  if (!html) return [];
  const hrefs = Array.from(html.matchAll(/href\s*=\s*["']([^"']+)["']/gi)).map(m => m[1]);
  const candidates = [...hrefs, ...extractUrlsFromText(html)];
  const cleaned = candidates.map(cleanUrlCandidate).filter((u): u is string => Boolean(u));
  return uniqueStrings(cleaned);
}

export function extractImageUrlsFromHtml(html: string): string[] {
  if (!html) return [];

  const imgSrcs = Array.from(html.matchAll(/<img[^>]*\ssrc\s*=\s*["']([^"']+)["']/gi)).map(m => m[1]);
  const ogImages = Array.from(
    html.matchAll(/<meta[^>]*property\s*=\s*["']og:image["'][^>]*content\s*=\s*["']([^"']+)["']/gi)
  ).map(m => m[1]);
  const twitterImages = Array.from(
    html.matchAll(/<meta[^>]*(?:name|property)\s*=\s*["']twitter:image["'][^>]*content\s*=\s*["']([^"']+)["']/gi)
  ).map(m => m[1]);

  const candidates = [...imgSrcs, ...ogImages, ...twitterImages];
  const cleaned = candidates.map(cleanUrlCandidate).filter((u): u is string => Boolean(u));
  return uniqueStrings(cleaned);
}

export function looksLikeImageUrl(url: string): boolean {
  try {
    const parsed = new URL(url);
    const pathname = parsed.pathname.toLowerCase();
    return /\.(png|jpe?g|webp|gif|svg|avif)$/.test(pathname);
  } catch {
    return false;
  }
}

export function isJunkUrl(url: string): boolean {
  const lower = url.toLowerCase();
  const junkFragments = [
    'unsubscribe',
    'preferences',
    'privacy',
    'terms',
    'support',
    'help',
    'account',
    'login',
    'signup',
    'doubleclick',
    'mailchimp',
    'mandrillapp',
    'sendgrid',
    'constantcontact',
    'campaign-archive',
  ];

  return junkFragments.some(fragment => lower.includes(fragment));
}

interface BestProductUrlParams {
  vendorDomain?: string;
  itemName: string;
  sku?: string;
}

export function pickBestProductUrlForItem(params: BestProductUrlParams, urls: string[]): string | undefined {
  if (urls.length === 0) return undefined;

  const vendorDomain = (params.vendorDomain || '').toLowerCase();
  const vendorUrls = vendorDomain && vendorDomain !== 'unknown'
    ? urls.filter(url => url.toLowerCase().includes(vendorDomain))
    : urls;
  const pool = vendorUrls.length > 0 ? vendorUrls : urls;

  const sku = params.sku?.trim();
  if (sku) {
    const skuMatch = pool.find(url => url.toLowerCase().includes(sku.toLowerCase()));
    if (skuMatch) return skuMatch;
  }

  const tokens = params.itemName
    .toLowerCase()
    .split(/[^a-z0-9]+/g)
    .filter(token => token.length >= 4)
    .slice(0, 3);

  for (const token of tokens) {
    const tokenMatch = pool.find(url => url.toLowerCase().includes(token));
    if (tokenMatch) return tokenMatch;
  }

  const nonRoot = pool.find(url => {
    try {
      const parsed = new URL(url);
      return parsed.pathname && parsed.pathname !== '/';
    } catch {
      return false;
    }
  });

  return nonRoot || pool[0];
}

export function pickBestImageUrlForItem(
  params: { vendorDomain?: string },
  urls: string[]
): string | undefined {
  if (urls.length === 0) return undefined;

  const vendorDomain = (params.vendorDomain || '').toLowerCase();
  const vendorUrls = vendorDomain && vendorDomain !== 'unknown'
    ? urls.filter(url => url.toLowerCase().includes(vendorDomain))
    : urls;
  const pool = vendorUrls.length > 0 ? vendorUrls : urls;

  const imageLike = pool.filter(looksLikeImageUrl);
  if (imageLike.length > 0) return imageLike[0];

  return pool[0];
}

```

### `server/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

```

### `server/vitest.config.ts`

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['src/**/*.test.ts'],
    coverage: {
      reporter: ['text', 'html'],
    },
  },
});

```

### `src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

### `src/App.tsx`

```tsx
import { useState, useEffect } from 'react';
import { LoginScreen } from './views/LoginScreen';
import { OnboardingFlow } from './views/OnboardingFlow';
import { MobileScanner } from './views/MobileScanner';
import { GoogleUserProfile } from './types';
import {
  ardaApi,
  ArdaSyncedTenantContext,
  authApi,
  buildArdaOpenUrl,
  getLastSuccessfulSyncTenant,
  SESSION_EXPIRED_EVENT,
} from './services/api';
import { Icons } from './components/Icons';
import { InstructionCard } from './components/InstructionCard';

export default function App() {
  // Auth State
  const [isCheckingAuth, setIsCheckingAuth] = useState(true);
  const [userProfile, setUserProfile] = useState<GoogleUserProfile | null>(null);
  
  // Track if user has completed onboarding
  const [hasCompletedOnboarding, setHasCompletedOnboarding] = useState(false);
  const [importedItemCount, setImportedItemCount] = useState(0);
  const [syncedTenant, setSyncedTenant] = useState<ArdaSyncedTenantContext | null>(null);

  const loadSyncedTenant = async () => {
    try {
      const status = await ardaApi.getSyncStatus();
      setSyncedTenant(getLastSuccessfulSyncTenant(status));
    } catch {
      // Keep completion UX resilient when sync-status can't be fetched.
      setSyncedTenant(null);
    }
  };

  useEffect(() => {
    const handleSessionExpired = () => {
      setUserProfile(null);
      setHasCompletedOnboarding(false);
      setImportedItemCount(0);
      localStorage.removeItem('orderPulse_onboardingComplete');
    };

    window.addEventListener(SESSION_EXPIRED_EVENT, handleSessionExpired);
    return () => {
      window.removeEventListener(SESSION_EXPIRED_EVENT, handleSessionExpired);
    };
  }, []);

  useEffect(() => {
    if (!userProfile) {
      setSyncedTenant(null);
      return;
    }
    void loadSyncedTenant();
  }, [userProfile?.id]);

  // Check auth on mount
  useEffect(() => {
    const checkAuth = async () => {
      try {
        // Check for auth token in URL (from OAuth callback)
        const urlParams = new URLSearchParams(window.location.search);
        const authToken = urlParams.get('token');
        
        let data;
        if (authToken) {
          // Exchange token for session
          console.log('🔑 Exchanging auth token...');
          data = await authApi.exchangeToken(authToken);
          // Clean up URL
          window.history.replaceState({}, '', window.location.pathname);
          if (!data.user) return;
        } else {
          // Normal auth check
          data = await authApi.getCurrentUser();
          if (!data.user) return;
        }

        setUserProfile({
          id: data.user.id,
          email: data.user.email,
          name: data.user.name,
          picture: data.user.picture_url,
        });
        // Check if user has completed onboarding before
        const completed = localStorage.getItem('orderPulse_onboardingComplete');
        if (completed === 'true') {
          setHasCompletedOnboarding(true);
        }
      } catch {
        // Not authenticated
      } finally {
        setIsCheckingAuth(false);
      }
    };
    checkAuth();
  }, []);

  const handleLogout = async () => {
    try {
      await authApi.logout();
    } catch {
      // Ignore logout errors
    }
    setUserProfile(null);
    setHasCompletedOnboarding(false);
    localStorage.removeItem('orderPulse_onboardingComplete');
  };

  const handleOnboardingComplete = (items: unknown[]) => {
    setImportedItemCount(items.length);
    setHasCompletedOnboarding(true);
    localStorage.setItem('orderPulse_onboardingComplete', 'true');
    void loadSyncedTenant();
  };

  const handleStartOver = () => {
    setHasCompletedOnboarding(false);
    setImportedItemCount(0);
    localStorage.removeItem('orderPulse_onboardingComplete');
  };

  const handleOpenArda = () => {
    const targetUrl = buildArdaOpenUrl(syncedTenant?.tenantId);
    window.open(targetUrl, '_blank', 'noopener,noreferrer');
  };

  // Check for mobile scanner routes (no auth required for scanning)
  const path = window.location.pathname;
  const scanMatch = path.match(/^\/scan\/([^/]+)$/);
  const photoMatch = path.match(/^\/photo\/([^/]+)$/);
  
  if (scanMatch) {
    return <MobileScanner sessionId={scanMatch[1]} mode="barcode" />;
  }
  
  if (photoMatch) {
    return <MobileScanner sessionId={photoMatch[1]} mode="photo" />;
  }

  // Show login screen if not authenticated
  if (isCheckingAuth) {
    return <LoginScreen onCheckingAuth={true} />;
  }
  
  if (!userProfile) {
    return <LoginScreen />;
  }

  // Show completion screen if onboarding is done
  if (hasCompletedOnboarding) {
    return (
      <div className="relative min-h-screen arda-mesh flex flex-col">
        <div className="absolute inset-0 pointer-events-none overflow-hidden">
          <div className="absolute -top-10 left-10 w-56 h-56 rounded-full bg-orange-400/15 blur-3xl animate-float" />
          <div className="absolute top-32 right-12 w-72 h-72 rounded-full bg-blue-500/10 blur-3xl animate-float" />
        </div>

        <header className="relative z-10 bg-white/80 backdrop-blur border-b border-arda-border px-6 py-4">
          <div className="max-w-5xl mx-auto flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 bg-gradient-to-br from-orange-500 to-orange-600 rounded-lg flex items-center justify-center shadow-arda">
                <Icons.Package className="w-6 h-6 text-white" />
              </div>
              <div>
                <h1 className="font-bold text-arda-text-primary">Order Pulse</h1>
                <p className="text-xs text-arda-text-muted">Inventory Import Complete</p>
              </div>
            </div>
            <div className="flex items-center gap-4">
              <span className="text-sm text-arda-text-secondary">{userProfile.email}</span>
              <button
                onClick={handleLogout}
                className="text-sm text-arda-text-muted hover:text-arda-text-primary"
              >
                Logout
              </button>
            </div>
          </div>
        </header>

        <div className="relative z-10 flex-1 flex items-center justify-center p-8">
          <div className="w-full max-w-lg text-center arda-glass rounded-2xl p-8">
            <div className="w-20 h-20 mx-auto bg-green-100 rounded-full flex items-center justify-center mb-6">
              <Icons.CheckCircle2 className="w-10 h-10 text-green-500" />
            </div>
            <h2 className="text-2xl font-bold text-arda-text-primary mb-3">
              Setup Complete!
            </h2>
            <p className="text-arda-text-secondary mb-6">
              {importedItemCount > 0 
                ? `You've successfully imported ${importedItemCount} items to Arda.`
                : 'Your inventory setup is complete.'}
            </p>

            <InstructionCard
              title="What to do"
              icon="ExternalLink"
              steps={[
                'Open Arda to continue in your synced tenant.',
                'If Arda asks you to sign in, use this same account email.',
                'You can return anytime to import more items.',
              ]}
              className="mb-6 text-left"
            />

            <div className="mb-6 rounded-lg border border-arda-border bg-white p-4 text-left">
              <p className="text-xs uppercase tracking-wide text-arda-text-muted mb-1">Synced tenant</p>
              {syncedTenant ? (
                <>
                  <p className="font-mono text-sm text-arda-text-primary break-all">{syncedTenant.tenantId}</p>
                  {syncedTenant.email && (
                    <p className="text-xs text-arda-text-muted mt-1">Synced as {syncedTenant.email}</p>
                  )}
                </>
              ) : (
                <p className="text-xs text-arda-text-muted">Opening Arda home (no synced tenant detected).</p>
              )}
            </div>
            <div className="flex flex-col gap-3">
              <button
                onClick={handleOpenArda}
                className="btn-arda-primary w-full px-6 py-3 flex items-center justify-center gap-2"
              >
                <Icons.ExternalLink className="w-5 h-5" />
                Open Arda
              </button>
              <button
                onClick={handleStartOver}
                className="btn-arda-outline w-full px-6 py-3"
              >
                Import More Items
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Show onboarding flow
  return (
    <OnboardingFlow
      onComplete={handleOnboardingComplete}
      onSkip={() => setHasCompletedOnboarding(true)}
      userProfile={{ name: userProfile.name, email: userProfile.email }}
    />
  );
}

```

### `src/__tests__/appAuth.test.tsx`

```tsx
import { act, fireEvent, render, screen } from '@testing-library/react';
import { beforeEach, describe, expect, it, vi } from 'vitest';

const mocks = vi.hoisted(() => ({
  getCurrentUser: vi.fn(),
  exchangeToken: vi.fn(),
  logout: vi.fn(),
  getSyncStatus: vi.fn(),
}));

vi.mock('../services/api', () => ({
  authApi: {
    getCurrentUser: mocks.getCurrentUser,
    exchangeToken: mocks.exchangeToken,
    logout: mocks.logout,
  },
  ardaApi: {
    getSyncStatus: mocks.getSyncStatus,
  },
  buildArdaOpenUrl: (tenantId?: string | null) =>
    tenantId ? `https://live.app.arda.cards/?tenantId=${tenantId}` : 'https://live.app.arda.cards',
  getLastSuccessfulSyncTenant: (syncStatus: { recent?: Array<{ success: boolean; tenantId?: string; email?: string; timestamp: string }> }) => {
    for (const event of syncStatus?.recent ?? []) {
      if (event.success && event.tenantId) {
        return {
          tenantId: event.tenantId,
          email: event.email,
          timestamp: event.timestamp,
        };
      }
    }
    return null;
  },
  SESSION_EXPIRED_EVENT: 'orderpulse:session-expired',
}));

vi.mock('../views/LoginScreen', () => ({
  LoginScreen: ({ onCheckingAuth }: { onCheckingAuth?: boolean }) => (
    <div>{onCheckingAuth ? 'checking-auth' : 'login-screen'}</div>
  ),
}));

vi.mock('../views/OnboardingFlow', () => ({
  OnboardingFlow: () => <div>onboarding-flow</div>,
}));

vi.mock('../views/MobileScanner', () => ({
  MobileScanner: () => <div>mobile-scanner</div>,
}));

vi.mock('../components/Icons', () => ({
  Icons: new Proxy(
    {},
    {
      get: () => () => null,
    },
  ),
}));

import App from '../App';

describe('App auth session handling', () => {
  beforeEach(() => {
    localStorage.clear();
    mocks.getCurrentUser.mockReset();
    mocks.exchangeToken.mockReset();
    mocks.logout.mockReset();
    mocks.getSyncStatus.mockReset();
  });

  it('returns to login when the session-expired signal is dispatched', async () => {
    mocks.getCurrentUser.mockResolvedValue({
      user: {
        id: 'user-1',
        email: 'user@example.com',
        name: 'User',
        picture_url: '',
      },
    });

    render(<App />);

    await screen.findByText('onboarding-flow');
    act(() => {
      window.dispatchEvent(new CustomEvent('orderpulse:session-expired'));
    });
    await screen.findByText('login-screen');
    expect(screen.queryByText('onboarding-flow')).not.toBeInTheDocument();
  });

  it('opens Arda with the last successful sync tenant in completion view', async () => {
    localStorage.setItem('orderPulse_onboardingComplete', 'true');
    mocks.getCurrentUser.mockResolvedValue({
      user: {
        id: 'user-1',
        email: 'user@example.com',
        name: 'User',
        picture_url: '',
      },
    });
    mocks.getSyncStatus.mockResolvedValue({
      recent: [
        {
          id: 'event-1',
          operation: 'item_create',
          success: true,
          requested: 1,
          successful: 1,
          failed: 0,
          timestamp: '2026-02-20T10:02:51.324Z',
          tenantId: 'tenant-abc',
          email: 'user@example.com',
        },
      ],
    });

    const openSpy = vi.spyOn(window, 'open').mockImplementation(() => null);
    render(<App />);

    await screen.findByText('Setup Complete!');
    await screen.findByText('tenant-abc');
    await screen.findByText('If Arda asks you to sign in, use this same account email.');
    fireEvent.click(screen.getByRole('button', { name: 'Open Arda' }));

    expect(openSpy).toHaveBeenCalledWith(
      'https://live.app.arda.cards/?tenantId=tenant-abc',
      '_blank',
      'noopener,noreferrer',
    );
  });

  it('falls back to Arda home when no successful tenant is available', async () => {
    localStorage.setItem('orderPulse_onboardingComplete', 'true');
    mocks.getCurrentUser.mockResolvedValue({
      user: {
        id: 'user-1',
        email: 'user@example.com',
        name: 'User',
        picture_url: '',
      },
    });
    mocks.getSyncStatus.mockResolvedValue({
      recent: [
        {
          id: 'event-1',
          operation: 'item_create',
          success: false,
          requested: 1,
          successful: 0,
          failed: 1,
          timestamp: '2026-02-20T10:02:51.324Z',
        },
      ],
    });

    const openSpy = vi.spyOn(window, 'open').mockImplementation(() => null);
    render(<App />);

    await screen.findByText('Opening Arda home (no synced tenant detected).');
    fireEvent.click(screen.getByRole('button', { name: 'Open Arda' }));

    expect(openSpy).toHaveBeenCalledWith(
      'https://live.app.arda.cards',
      '_blank',
      'noopener,noreferrer',
    );
  });
});

```

### `src/assets/react.svg`

```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
```

### `src/components/AlertCard.tsx`

```tsx
import React from 'react';
import { InventoryItem, ItemVelocityProfile } from '../types';
import { Icons } from './Icons';

export type AlertType = 'overdue' | 'upcoming' | 'high-velocity';

export interface Alert {
  type: AlertType;
  profile: ItemVelocityProfile;
  daysUntil: number;
}

interface AlertCardProps {
  alert: Alert;
  onReorder?: (item: InventoryItem) => void;
  inventory: InventoryItem[];
}

export const AlertCard: React.FC<AlertCardProps> = ({ alert, onReorder, inventory }) => {
  const { type, profile, daysUntil } = alert;
  
  // Find matching inventory item
  const matchingInventoryItem = inventory.find(
    i => i.name.toLowerCase().trim() === profile.normalizedName
  );

  const getAlertConfig = () => {
    switch (type) {
      case 'overdue':
        return {
          icon: Icons.AlertCircle,
          iconColor: 'text-red-400',
          bgColor: 'bg-red-500/10',
          borderColor: 'border-red-500/30',
          label: 'Overdue',
          timeText: daysUntil === 0 ? 'Today' : `${Math.abs(daysUntil)} day${Math.abs(daysUntil) !== 1 ? 's' : ''} ago`,
        };
      case 'upcoming':
        return {
          icon: Icons.Clock,
          iconColor: 'text-yellow-400',
          bgColor: 'bg-yellow-500/10',
          borderColor: 'border-yellow-500/30',
          label: 'Upcoming',
          timeText: daysUntil === 0 ? 'Today' : `${daysUntil} day${daysUntil !== 1 ? 's' : ''}`,
        };
      case 'high-velocity':
        return {
          icon: Icons.Zap,
          iconColor: 'text-orange-400',
          bgColor: 'bg-orange-500/10',
          borderColor: 'border-orange-500/30',
          label: 'High Velocity',
          timeText: `${profile.dailyBurnRate.toFixed(1)} units/day`,
        };
    }
  };

  const config = getAlertConfig();
  const Icon = config.icon;

  return (
    <div className={`p-3 rounded-lg border ${config.bgColor} ${config.borderColor} flex items-start gap-3`}>
      <div className={`flex-shrink-0 mt-0.5 ${config.iconColor}`}>
        <Icon className="w-5 h-5" />
      </div>
      <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between gap-2">
          <div className="flex-1 min-w-0">
            <div className="text-sm font-medium text-arda-text-primary truncate">
              {profile.displayName}
            </div>
            <div className="text-xs text-arda-text-secondary mt-0.5">
              {profile.supplier}
            </div>
            <div className="flex items-center gap-2 mt-2">
              <span className={`text-xs px-2 py-0.5 rounded ${config.bgColor} ${config.iconColor} font-medium`}>
                {config.label}
              </span>
              <span className="text-xs text-arda-text-secondary">
                {config.timeText}
              </span>
            </div>
          </div>
          {matchingInventoryItem && onReorder && (
            <button
              onClick={() => onReorder(matchingInventoryItem)}
              className="flex-shrink-0 px-3 py-1.5 bg-arda-accent hover:bg-arda-accent-hover text-white text-xs font-medium rounded transition-colors flex items-center gap-1.5"
              title="Create reorder email"
            >
              <Icons.Send className="w-3 h-3" />
              Reorder
            </button>
          )}
        </div>
      </div>
    </div>
  );
};

```

### `src/components/ErrorBoundary.tsx`

```tsx
import { Component, ErrorInfo, ReactNode } from 'react';
import { Icons } from './Icons';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error, errorInfo: null };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
    this.setState({ errorInfo });
  }

  handleRetry = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-[300px] flex flex-col items-center justify-center p-8 bg-arda-bg-secondary border border-red-500/30 rounded-lg">
          <div className="w-16 h-16 bg-red-500/10 rounded-full flex items-center justify-center mb-4">
            <Icons.AlertCircle className="w-8 h-8 text-red-400" />
          </div>
          <h3 className="text-lg font-bold text-arda-text-primary mb-2">Something went wrong</h3>
          <p className="text-sm text-arda-text-muted text-center max-w-md mb-4">
            {this.state.error?.message || 'An unexpected error occurred while rendering this component.'}
          </p>
          <button 
            onClick={this.handleRetry}
            className="bg-arda-bg-tertiary hover:bg-arda-border text-arda-text-primary px-4 py-2 rounded-md text-sm font-medium flex items-center gap-2 transition-colors"
          >
            <Icons.RefreshCw className="w-4 h-4" />
            Try Again
          </button>
          {import.meta.env.DEV && this.state.errorInfo && (
            <details className="mt-4 p-4 bg-arda-bg-secondary rounded text-xs text-arda-text-muted max-w-full overflow-auto">
              <summary className="cursor-pointer text-arda-text-secondary mb-2">Stack Trace</summary>
              <pre className="whitespace-pre-wrap break-words">
                {this.state.errorInfo.componentStack}
              </pre>
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

```

### `src/components/Icons.tsx`

```tsx
import { 
  LayoutDashboard, 
  Inbox, 
  Package, 
  BarChart3, 
  Settings, 
  CheckCircle2, 
  AlertCircle,
  Loader2,
  RefreshCw,
  Search,
  ArrowRight,
  TrendingUp,
  Calendar,
  DollarSign,
  Send,
  User,
  Mail,
  X,
  Upload,
  Download,
  Check,
  CreditCard,
  Clock,
  LogOut,
  ChevronLeft,
  ChevronRight,
  ChevronDown,
  Zap,
  GitBranch,
  GitMerge,
  Box,
  FileText,
  Activity,
  Building2,
  Sparkles,
  Power,
  ScanLine,
  ScanBarcode,
  ExternalLink,
  Link,
  ShieldCheck,
  Lock,
  Lightbulb,
  BookOpen,
  Camera,
  Smartphone,
  Circle,
  QrCode,
  ListChecks,
  PartyPopper,
  FileSpreadsheet,
  MapPin,
  Pencil,
  Trash2,
  XCircle,
  AlertTriangle,
} from 'lucide-react';

export const Icons = {
  LayoutDashboard,
  Inbox,
  Package,
  BarChart3,
  Settings,
  CheckCircle2,
  AlertCircle,
  Loader2,
  RefreshCw,
  Search,
  ArrowRight,
  TrendingUp,
  Calendar,
  DollarSign,
  Send,
  User,
  Mail,
  X,
  Upload,
  Download,
  Check,
  CreditCard,
  Clock,
  LogOut,
  ChevronLeft,
  ChevronRight,
  ChevronDown,
  Zap,
  GitBranch,
  GitMerge,
  Box,
  FileText,
  Activity,
  Building2,
  Sparkles,
  Power,
  ScanLine,
  Barcode: ScanBarcode,
  ExternalLink,
  Link,
  ShieldCheck,
  Lock,
  Lightbulb,
  BookOpen,
  Camera,
  Smartphone,
  Circle,
  QrCode,
  ListChecks,
  PartyPopper,
  FileSpreadsheet,
  MapPin,
  Pencil,
  Trash2,
  XCircle,
  AlertTriangle,
};


```

### `src/components/InstructionCard.tsx`

```tsx
import { Icons } from './Icons';

interface InstructionCardProps {
  title?: string;
  steps: string[];
  icon?: keyof typeof Icons;
  className?: string;
  variant?: 'card' | 'compact';
}

export const InstructionCard: React.FC<InstructionCardProps> = ({
  title = 'What to do',
  steps,
  icon = 'Lightbulb',
  className = '',
  variant = 'card',
}) => {
  const Icon = Icons[icon] || Icons.Lightbulb;
  const isCompact = variant === 'compact';

  return (
    <div className={`card-arda ${isCompact ? 'p-3' : 'p-4'} ${className}`.trim()}>
      <div className="flex items-start gap-3">
        <div
          className={[
            'flex items-center justify-center text-arda-accent bg-orange-50 border border-orange-100',
            isCompact ? 'w-8 h-8 rounded-lg' : 'w-9 h-9 rounded-xl',
          ].join(' ')}
        >
          <Icon className={isCompact ? 'w-3.5 h-3.5' : 'w-4 h-4'} />
        </div>

        <div className="min-w-0">
          <p className={isCompact ? 'text-[11px] font-semibold text-arda-text-muted uppercase tracking-wide' : 'text-sm font-semibold text-arda-text-primary'}>
            {title}
          </p>

          {isCompact ? (
            <p className="mt-1 text-xs text-arda-text-secondary leading-relaxed">
              {steps.map((step, index) => (
                <span key={`${step}-${index}`}>
                  {step}
                  {index < steps.length - 1 ? ' • ' : ''}
                </span>
              ))}
            </p>
          ) : (
            <ul className="mt-2 text-sm text-arda-text-secondary space-y-1 list-disc list-inside">
              {steps.map((step, index) => (
                <li key={`${step}-${index}`}>{step}</li>
              ))}
            </ul>
          )}
        </div>
      </div>
    </div>
  );
};

```

### `src/components/ItemDetailPanel.tsx`

```tsx
import React, { useEffect, useState } from 'react';
import { ItemVelocityProfile, InventoryItem } from '../types';
import { Icons } from './Icons';

interface ItemDetailPanelProps {
  itemProfile: ItemVelocityProfile;
  inventoryItem?: InventoryItem;
  onClose: () => void;
  onReorder?: (item: InventoryItem) => void;
  onPushToArda?: (profile: ItemVelocityProfile) => void;
}

export const ItemDetailPanel: React.FC<ItemDetailPanelProps> = ({
  itemProfile,
  inventoryItem,
  onClose,
  onReorder,
  onPushToArda,
}) => {
  const [isOpen, setIsOpen] = useState(false);

  useEffect(() => {
    // Trigger slide-in animation on mount
    const timer = setTimeout(() => setIsOpen(true), 10);
    return () => clearTimeout(timer);
  }, []);

  const handleClose = () => {
    setIsOpen(false);
    // Wait for animation to complete before calling onClose
    setTimeout(() => onClose(), 300);
  };

  return (
    <>
      {/* Backdrop */}
      <div
        className={`fixed inset-0 bg-black/50 z-40 transition-opacity duration-300 ${
          isOpen ? 'opacity-100' : 'opacity-0'
        }`}
        onClick={handleClose}
      />

      {/* Slide-out Panel */}
      <div
        className={`fixed right-0 top-0 h-full w-96 bg-white border-l border-arda-border z-50 flex flex-col shadow-2xl transform transition-transform duration-300 ease-out ${
          isOpen ? 'translate-x-0' : 'translate-x-full'
        }`}
      >
        {/* Header */}
        <div className="p-4 border-b border-arda-border flex items-start justify-between flex-shrink-0">
          <div className="flex-1 min-w-0 pr-2">
            <h3 className="text-lg font-semibold text-arda-text-primary truncate">
              {itemProfile.displayName}
            </h3>
            <p className="text-sm text-arda-text-muted mt-1">
              {itemProfile.supplier}
            </p>
            {itemProfile.sku && (
              <span className="inline-block mt-2 px-2 py-0.5 bg-arda-bg-tertiary text-arda-text-secondary text-xs rounded">
                SKU: {itemProfile.sku}
              </span>
            )}
          </div>
          <button
            onClick={handleClose}
            className="p-1 text-arda-text-muted hover:text-arda-text-primary transition-colors flex-shrink-0"
            aria-label="Close panel"
          >
            <Icons.X className="w-5 h-5" />
          </button>
        </div>

        {/* Scrollable Content */}
        <div className="flex-1 overflow-y-auto">
          {/* Velocity Stats Grid */}
          <div className="grid grid-cols-2 gap-3 p-4 border-b border-arda-border">
            <div className="bg-arda-bg-secondary rounded-lg p-3">
              <div className="text-2xl font-bold text-orange-400">
                {itemProfile.dailyBurnRate.toFixed(1)}
              </div>
              <div className="text-xs text-arda-text-muted mt-1">Daily Burn Rate</div>
            </div>
            <div className="bg-arda-bg-secondary rounded-lg p-3">
              <div className="text-2xl font-bold text-blue-400">
                {Math.round(itemProfile.averageCadenceDays)}
              </div>
              <div className="text-xs text-arda-text-muted mt-1">Cadence (Days)</div>
            </div>
            <div className="bg-arda-bg-secondary rounded-lg p-3">
              <div className="text-2xl font-bold text-green-400">
                {itemProfile.totalQuantityOrdered}
              </div>
              <div className="text-xs text-arda-text-muted mt-1">Total Ordered</div>
            </div>
            <div className="bg-arda-bg-secondary rounded-lg p-3">
              <div className="text-2xl font-bold text-purple-400">
                {itemProfile.orderCount}
              </div>
              <div className="text-xs text-arda-text-muted mt-1">Order Count</div>
            </div>
          </div>

          {/* Kanban Recommendations */}
          <div className="p-4 border-b border-arda-border">
            <h4 className="text-sm font-medium text-arda-text-secondary mb-3 flex items-center gap-2">
              <Icons.Box className="w-4 h-4" />
              Kanban Recommendations
            </h4>
            <div className="space-y-2">
              <div className="flex items-center justify-between text-sm">
                <span className="text-arda-text-muted">Min Qty (Reorder Point)</span>
                <span className="font-medium text-arda-text-primary">{itemProfile.recommendedMin}</span>
              </div>
              <div className="flex items-center justify-between text-sm">
                <span className="text-arda-text-muted">Order Qty (EOQ)</span>
                <span className="font-medium text-arda-text-primary">{itemProfile.recommendedOrderQty}</span>
              </div>
              {itemProfile.nextPredictedOrder && (
                <div className="flex items-center justify-between text-sm">
                  <span className="text-arda-text-muted">Next Predicted Order</span>
                  <span className="font-medium text-yellow-600">
                    {new Date(itemProfile.nextPredictedOrder).toLocaleDateString()}
                  </span>
                </div>
              )}
            </div>
          </div>

          {/* Order History */}
          <div className="p-4">
            <h4 className="text-sm font-medium text-arda-text-secondary mb-3 flex items-center gap-2">
              <Icons.FileText className="w-4 h-4" />
              Order History
            </h4>
            <div className="space-y-2">
              {itemProfile.orders.length === 0 ? (
                <div className="text-center py-8 text-arda-text-muted text-sm">
                  <Icons.Package className="w-8 h-8 mx-auto mb-2 opacity-50" />
                  <p>No order history available</p>
                </div>
              ) : (
                itemProfile.orders
                  .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
                  .map((order, idx) => (
                    <div
                      key={`${order.orderId}-${idx}`}
                      className="flex items-center justify-between p-3 bg-arda-bg-secondary rounded-lg hover:bg-arda-bg-tertiary transition-colors"
                    >
                      <div className="flex-1 min-w-0">
                        <div className="text-sm text-arda-text-primary font-medium">
                          {new Date(order.date).toLocaleDateString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                          })}
                        </div>
                        <div className="text-xs text-arda-text-muted mt-1">
                          Order #{order.orderId.substring(0, 8)}...
                        </div>
                      </div>
                      <div className="text-right ml-4">
                        <div className="text-sm font-medium text-arda-text-primary">
                          Qty: {order.quantity}
                        </div>
                        {order.unitPrice !== undefined && (
                          <div className="text-xs text-arda-text-muted mt-1">
                            @ ${order.unitPrice.toFixed(2)}/ea
                          </div>
                        )}
                      </div>
                    </div>
                  ))
              )}
            </div>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="p-4 border-t border-arda-border space-y-2 flex-shrink-0">
          {inventoryItem && onReorder && (
            <button
              onClick={() => onReorder(inventoryItem)}
              className="w-full bg-arda-accent hover:bg-arda-accent-hover text-white py-2.5 px-4 rounded-lg font-medium transition-colors flex items-center justify-center gap-2"
            >
              <Icons.Send className="w-4 h-4" />
              Create Reorder Email
            </button>
          )}
          {onPushToArda && (
            <button
              onClick={() => onPushToArda(itemProfile)}
              className="w-full bg-arda-bg-tertiary hover:bg-arda-border text-arda-text-primary py-2.5 px-4 rounded-lg font-medium transition-colors flex items-center justify-center gap-2"
            >
              <Icons.Upload className="w-4 h-4" />
              Push to Arda
            </button>
          )}
        </div>
      </div>
    </>
  );
};

export default ItemDetailPanel;

```

### `src/components/ItemsTable/ItemsGrid.tsx`

```tsx
import { useCallback, useMemo, useRef } from 'react';
import { AgGridReact } from 'ag-grid-react';
import type { ColDef, GridReadyEvent, CellValueChangedEvent, GetRowIdParams, RowClassRules } from 'ag-grid-community';
import './gridSetup';
import './ardaGridTheme.css';
import type { MasterListItem, RowSyncState } from './types';
import { ORDER_METHOD_OPTIONS } from './types';
import { SourceBadgeRenderer } from './cellRenderers/SourceBadgeRenderer';
import { ImageCellRenderer } from './cellRenderers/ImageCellRenderer';
import { ColorCellRenderer } from './cellRenderers/ColorCellRenderer';
import { ColorCellEditor } from './cellRenderers/ColorCellEditor';
import { SyncStatusRenderer } from './cellRenderers/SyncStatusRenderer';
import { ActionsCellRenderer } from './cellRenderers/ActionsCellRenderer';
import { UrlCellRenderer } from './cellRenderers/UrlCellRenderer';

export interface ItemsGridProps {
  items: MasterListItem[];
  onUpdateItem: (id: string, field: keyof MasterListItem, value: unknown) => void;
  onRemoveItem: (id: string) => void;
  syncStateById: Record<string, RowSyncState>;
  onSyncSingle?: (id: string) => void;
  mode: 'panel' | 'fullpage';
}

export const ItemsGrid: React.FC<ItemsGridProps> = ({
  items,
  onUpdateItem,
  onRemoveItem,
  syncStateById,
  onSyncSingle,
  mode,
}) => {
  const gridRef = useRef<AgGridReact<MasterListItem>>(null);

  const getRowId = useCallback((params: GetRowIdParams<MasterListItem>) => params.data.id, []);

  const onCellValueChanged = useCallback(
    (event: CellValueChangedEvent<MasterListItem>) => {
      const field = event.colDef.field as keyof MasterListItem | undefined;
      if (field && event.data) {
        onUpdateItem(event.data.id, field, event.newValue);
      }
    },
    [onUpdateItem],
  );

  const onGridReady = useCallback((event: GridReadyEvent) => {
    event.api.sizeColumnsToFit();
  }, []);

  const columnDefs = useMemo<ColDef<MasterListItem>[]>(
    () => [
      {
        headerCheckboxSelection: true,
        checkboxSelection: true,
        width: 44,
        maxWidth: 44,
        pinned: 'left',
        suppressMenu: true,
        resizable: false,
        sortable: false,
        filter: false,
        editable: false,
        lockPosition: true,
      },
      {
        headerName: 'Source',
        field: 'source',
        width: 90,
        maxWidth: 100,
        cellRenderer: SourceBadgeRenderer,
        editable: false,
        enableRowGroup: true,
        filter: 'agSetColumnFilter',
      },
      {
        headerName: 'Img',
        field: 'imageUrl',
        width: 56,
        maxWidth: 56,
        cellRenderer: ImageCellRenderer,
        editable: false,
        sortable: false,
        filter: false,
      },
      {
        headerName: 'Name',
        field: 'name',
        minWidth: 160,
        flex: 2,
        editable: true,
        filter: 'agTextColumnFilter',
        pinned: mode === 'fullpage' ? 'left' : undefined,
        rowDrag: true,
      },
      {
        headerName: 'Supplier',
        field: 'supplier',
        minWidth: 120,
        flex: 1,
        editable: true,
        filter: 'agTextColumnFilter',
        enableRowGroup: true,
      },
      {
        headerName: 'Order Method',
        field: 'orderMethod',
        width: 130,
        editable: true,
        cellEditor: 'agSelectCellEditor',
        cellEditorParams: {
          values: ORDER_METHOD_OPTIONS.map((o) => o.value),
        },
        valueFormatter: (params) => {
          const opt = ORDER_METHOD_OPTIONS.find((o) => o.value === params.value);
          return opt?.label ?? (params.value as string);
        },
      },
      {
        headerName: 'Location',
        field: 'location',
        width: 100,
        editable: true,
        filter: 'agTextColumnFilter',
      },
      {
        headerName: 'SKU',
        field: 'sku',
        width: 100,
        editable: true,
      },
      {
        headerName: 'Barcode',
        field: 'barcode',
        width: 110,
        editable: true,
        hide: mode === 'panel',
      },
      {
        headerName: 'Min',
        field: 'minQty',
        width: 70,
        editable: true,
        cellEditor: 'agNumberCellEditor',
        type: 'numericColumn',
        valueParser: (params) => {
          const val = Number(params.newValue);
          return isNaN(val) ? params.oldValue : val;
        },
      },
      {
        headerName: 'Order',
        field: 'orderQty',
        width: 70,
        editable: true,
        cellEditor: 'agNumberCellEditor',
        type: 'numericColumn',
        valueParser: (params) => {
          const val = Number(params.newValue);
          return isNaN(val) ? params.oldValue : val;
        },
      },
      {
        headerName: 'Price',
        field: 'unitPrice',
        width: 80,
        editable: true,
        cellEditor: 'agNumberCellEditor',
        type: 'numericColumn',
        valueFormatter: (params) => {
          if (params.value == null) return '—';
          return `$${Number(params.value).toFixed(2)}`;
        },
        valueParser: (params) => {
          const cleaned = String(params.newValue).replace(/[$,]/g, '');
          const val = Number(cleaned);
          return isNaN(val) ? params.oldValue : val;
        },
      },
      {
        headerName: 'Color',
        field: 'color',
        width: 100,
        cellRenderer: ColorCellRenderer,
        cellEditor: ColorCellEditor,
        editable: true,
      },
      {
        headerName: 'Product URL',
        field: 'productUrl',
        width: 130,
        cellRenderer: UrlCellRenderer,
        editable: true,
        hide: mode === 'panel',
      },
      {
        headerName: 'Status',
        colId: 'syncStatus',
        width: 60,
        maxWidth: 60,
        cellRenderer: SyncStatusRenderer,
        cellRendererParams: { syncStateById },
        editable: false,
        sortable: false,
        filter: false,
      },
      {
        headerName: '',
        colId: 'actions',
        width: 80,
        maxWidth: 80,
        cellRenderer: ActionsCellRenderer,
        cellRendererParams: { onSyncSingle, onRemoveItem, syncStateById },
        editable: false,
        sortable: false,
        filter: false,
        pinned: 'right',
      },
    ],
    [mode, syncStateById, onSyncSingle, onRemoveItem],
  );

  const defaultColDef = useMemo<ColDef>(
    () => ({
      resizable: true,
      sortable: true,
      filter: true,
      suppressMovable: false,
    }),
    [],
  );

  const rowClassRules = useMemo<RowClassRules<MasterListItem>>(
    () => ({
      'row-needs-attention': (params) => !!params.data?.needsAttention,
      'row-sync-success': (params) => syncStateById[params.data?.id ?? '']?.status === 'success',
      'row-sync-error': (params) => syncStateById[params.data?.id ?? '']?.status === 'error',
    }),
    [syncStateById],
  );

  const containerHeight = mode === 'fullpage' ? 'calc(100vh - 160px)' : '100%';

  return (
    <div className="flex flex-col h-full">
      {/* Header bar */}
      <div className="flex items-center justify-between px-4 py-2 border-b border-gray-200 bg-gray-50/50">
        <div className="flex items-center gap-3">
          <h3 className="text-sm font-semibold text-gray-700">Item Ledger</h3>
          <span className="text-xs text-gray-500">{items.length} items</span>
          {Object.values(syncStateById).filter((s) => s.status === 'success').length > 0 && (
            <span className="text-xs text-green-600">
              {Object.values(syncStateById).filter((s) => s.status === 'success').length} synced
            </span>
          )}
          {Object.values(syncStateById).filter((s) => s.status === 'error').length > 0 && (
            <span className="text-xs text-red-600">
              {Object.values(syncStateById).filter((s) => s.status === 'error').length} failed
            </span>
          )}
        </div>
      </div>

      {/* Grid */}
      <div className="ag-theme-arda flex-1" style={{ height: containerHeight, width: '100%' }}>
        <AgGridReact<MasterListItem>
          ref={gridRef}
          rowData={items}
          columnDefs={columnDefs}
          defaultColDef={defaultColDef}
          getRowId={getRowId}
          rowClassRules={rowClassRules}
          onCellValueChanged={onCellValueChanged}
          onGridReady={onGridReady}
          // Selection
          rowSelection="multiple"
          suppressRowClickSelection
          // Editing
          singleClickEdit
          stopEditingWhenCellsLoseFocus
          // Enterprise features
          enableRangeSelection
          enableFillHandle
          undoRedoCellEditing
          undoRedoCellEditingLimit={20}
          // Row drag
          rowDragManaged
          animateRows
          // Performance
          suppressColumnVirtualisation={items.length < 100}
          rowBuffer={10}
          // Empty state
          overlayNoRowsTemplate='<div class="p-8 text-center text-gray-400"><div class="text-lg mb-1">No items yet</div><div class="text-sm">Items will appear here as you collect them from each step.</div></div>'
        />
      </div>
    </div>
  );
};

```

### `src/components/ItemsTable/ardaGridTheme.css`

```css
.ag-theme-arda {
  --ag-font-family: 'Inter', system-ui, -apple-system, sans-serif;
  --ag-font-size: 13px;

  /* Backgrounds */
  --ag-background-color: #ffffff;
  --ag-header-background-color: #f9fafb;
  --ag-odd-row-background-color: #ffffff;
  --ag-row-hover-color: #f9fafb;
  --ag-header-cell-hover-background-color: #f3f4f6;
  --ag-selected-row-background-color: #fff7ed;
  --ag-modal-overlay-background-color: rgba(0, 0, 0, 0.3);

  /* Accent (Arda orange) */
  --ag-range-selection-border-color: #FC5A29;
  --ag-range-selection-background-color: rgba(252, 90, 41, 0.08);
  --ag-checkbox-checked-color: #FC5A29;
  --ag-input-focus-border-color: #FC5A29;
  --ag-accent-color: #FC5A29;

  /* Borders */
  --ag-border-color: #e5e7eb;
  --ag-row-border-color: #f3f4f6;
  --ag-secondary-border-color: #e5e7eb;

  /* Text */
  --ag-header-foreground-color: #4b5563;
  --ag-foreground-color: #1f2937;
  --ag-secondary-foreground-color: #6b7280;
  --ag-disabled-foreground-color: #9ca3af;

  /* Sizing */
  --ag-grid-size: 4px;
  --ag-cell-horizontal-padding: 8px;
  --ag-header-height: 36px;
  --ag-row-height: 38px;

  /* Shape */
  --ag-wrapper-border-radius: 12px;
  --ag-border-radius: 6px;
  --ag-card-radius: 8px;

  /* Shadows */
  --ag-card-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
  --ag-popup-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
}

/* Header styling */
.ag-theme-arda .ag-header-cell-label {
  font-weight: 600;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Row attention styling */
.ag-theme-arda .ag-row.row-needs-attention {
  background-color: #fff7ed;
}

.ag-theme-arda .ag-row.row-sync-success {
  background-color: #f0fdf4;
}

.ag-theme-arda .ag-row.row-sync-error {
  background-color: #fef2f2;
}

/* Cell editing */
.ag-theme-arda .ag-cell-inline-editing {
  border-color: #FC5A29 !important;
  box-shadow: 0 0 0 2px rgba(252, 90, 41, 0.2);
  border-radius: 4px;
}

/* Scrollbar styling */
.ag-theme-arda ::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.ag-theme-arda ::-webkit-scrollbar-thumb {
  background-color: #d1d5db;
  border-radius: 3px;
}

.ag-theme-arda ::-webkit-scrollbar-thumb:hover {
  background-color: #9ca3af;
}

.ag-theme-arda ::-webkit-scrollbar-track {
  background-color: transparent;
}

```

### `src/components/ItemsTable/cellRenderers/ActionsCellRenderer.tsx`

```tsx
import type { CustomCellRendererProps } from 'ag-grid-react';
import { Icons } from '../../Icons';
import type { MasterListItem, RowSyncState } from '../types';

interface ActionsCellRendererProps extends CustomCellRendererProps<MasterListItem> {
  onSyncSingle?: (id: string) => void;
  onRemoveItem?: (id: string) => void;
  syncStateById?: Record<string, RowSyncState>;
}

export const ActionsCellRenderer = (props: ActionsCellRendererProps) => {
  const id = props.data?.id;
  if (!id) return null;

  const syncState = props.syncStateById?.[id];
  const isSyncing = syncState?.status === 'syncing';
  const isSynced = syncState?.status === 'success';

  return (
    <div className="flex items-center gap-1">
      {props.onSyncSingle && !isSynced && (
        <button
          type="button"
          onClick={() => props.onSyncSingle?.(id)}
          disabled={isSyncing}
          className="p-1 rounded hover:bg-orange-50 text-gray-500 hover:text-orange-600 transition-colors disabled:opacity-50"
          title="Sync to Arda"
        >
          {isSyncing ? (
            <Icons.Loader2 className="w-3.5 h-3.5 animate-spin" />
          ) : (
            <Icons.Upload className="w-3.5 h-3.5" />
          )}
        </button>
      )}
      {props.onRemoveItem && (
        <button
          type="button"
          onClick={() => props.onRemoveItem?.(id)}
          className="p-1 rounded hover:bg-red-50 text-gray-400 hover:text-red-500 transition-colors"
          title="Remove item"
        >
          <Icons.Trash2 className="w-3.5 h-3.5" />
        </button>
      )}
    </div>
  );
};

```

### `src/components/ItemsTable/cellRenderers/ColorCellEditor.tsx`

```tsx
import { forwardRef, useImperativeHandle, useRef, useState } from 'react';
import type { CustomCellEditorProps } from 'ag-grid-react';
import type { MasterListItem } from '../types';

const colors = [
  { id: 'BLUE', label: 'Blue', bg: 'bg-blue-500' },
  { id: 'GREEN', label: 'Green', bg: 'bg-green-500' },
  { id: 'YELLOW', label: 'Yellow', bg: 'bg-yellow-400' },
  { id: 'ORANGE', label: 'Orange', bg: 'bg-orange-500' },
  { id: 'RED', label: 'Red', bg: 'bg-red-500' },
  { id: 'PINK', label: 'Pink', bg: 'bg-pink-400' },
  { id: 'PURPLE', label: 'Purple', bg: 'bg-purple-500' },
  { id: 'GRAY', label: 'Gray', bg: 'bg-gray-400' },
];

export const ColorCellEditor = forwardRef<unknown, CustomCellEditorProps<MasterListItem>>((props, ref) => {
  const [value, setValue] = useState<string>(props.value ?? '');
  const containerRef = useRef<HTMLDivElement>(null);

  useImperativeHandle(ref, () => ({
    getValue: () => value,
    isCancelAfterEnd: () => false,
    isPopup: () => true,
    getPopupPosition: () => 'under' as const,
  }));

  const handleSelect = (colorId: string) => {
    setValue(colorId);
    // Stop editing after selection
    props.stopEditing();
  };

  return (
    <div
      ref={containerRef}
      className="bg-white border border-gray-200 rounded-lg shadow-lg p-2 grid grid-cols-4 gap-1 min-w-[140px]"
    >
      {colors.map((color) => (
        <button
          key={color.id}
          type="button"
          onClick={() => handleSelect(color.id)}
          className={`w-8 h-8 rounded-full ${color.bg} hover:ring-2 ring-offset-1 ring-[#FC5A29] transition-all ${
            value?.toUpperCase() === color.id ? 'ring-2 ring-[#FC5A29]' : ''
          }`}
          title={color.label}
        />
      ))}
      <button
        type="button"
        onClick={() => handleSelect('')}
        className="w-8 h-8 rounded-full border-2 border-dashed border-gray-300 hover:border-[#FC5A29] transition-colors flex items-center justify-center text-gray-400 text-xs"
        title="No color"
      >
        ✕
      </button>
    </div>
  );
});

ColorCellEditor.displayName = 'ColorCellEditor';

```

### `src/components/ItemsTable/cellRenderers/ColorCellRenderer.tsx`

```tsx
import type { CustomCellRendererProps } from 'ag-grid-react';
import type { MasterListItem } from '../types';

const colorMap: Record<string, string> = {
  BLUE: 'bg-blue-500',
  GREEN: 'bg-green-500',
  YELLOW: 'bg-yellow-400',
  ORANGE: 'bg-orange-500',
  RED: 'bg-red-500',
  PINK: 'bg-pink-400',
  PURPLE: 'bg-purple-500',
  GRAY: 'bg-gray-400',
};

export const ColorCellRenderer = (props: CustomCellRendererProps<MasterListItem>) => {
  const color = (props.value as string)?.toUpperCase();
  const bgClass = color ? colorMap[color] : undefined;

  if (!bgClass) {
    return <span className="text-gray-400 text-xs italic">—</span>;
  }

  return (
    <div className="flex items-center gap-2">
      <span className={`w-4 h-4 rounded-full ${bgClass}`} />
      <span className="text-xs">{color.charAt(0) + color.slice(1).toLowerCase()}</span>
    </div>
  );
};

```

### `src/components/ItemsTable/cellRenderers/ImageCellRenderer.tsx`

```tsx
import type { CustomCellRendererProps } from 'ag-grid-react';
import { Icons } from '../../Icons';
import type { MasterListItem } from '../types';

export const ImageCellRenderer = (props: CustomCellRendererProps<MasterListItem>) => {
  const url = props.value as string | undefined;

  if (url?.trim()) {
    return (
      <img
        src={url}
        alt=""
        className="w-8 h-8 rounded object-cover"
        onError={(e) => {
          (e.target as HTMLImageElement).style.display = 'none';
        }}
      />
    );
  }

  return (
    <div className="w-8 h-8 rounded bg-gray-100 flex items-center justify-center">
      <Icons.Package className="w-4 h-4 text-gray-400" />
    </div>
  );
};

```

### `src/components/ItemsTable/cellRenderers/SourceBadgeRenderer.tsx`

```tsx
import type { CustomCellRendererProps } from 'ag-grid-react';
import { Icons } from '../../Icons';
import type { MasterListItem } from '../types';

const sourceConfig: Record<MasterListItem['source'], { icon: keyof typeof Icons; label: string; bg: string }> = {
  email: { icon: 'Mail', label: 'Email', bg: 'bg-blue-50 text-blue-600' },
  url: { icon: 'Link', label: 'URL', bg: 'bg-purple-50 text-purple-600' },
  barcode: { icon: 'Barcode', label: 'UPC', bg: 'bg-green-50 text-green-600' },
  photo: { icon: 'Camera', label: 'Photo', bg: 'bg-orange-50 text-orange-600' },
  csv: { icon: 'FileSpreadsheet', label: 'CSV', bg: 'bg-gray-50 text-gray-600' },
};

export const SourceBadgeRenderer = (props: CustomCellRendererProps<MasterListItem>) => {
  const source = props.value as MasterListItem['source'];
  if (!source) return null;

  const config = sourceConfig[source];
  const Icon = Icons[config.icon];

  return (
    <span className={`inline-flex items-center gap-1 px-1.5 py-0.5 rounded text-[11px] font-medium ${config.bg}`}>
      <Icon className="w-3 h-3" />
      {config.label}
    </span>
  );
};

```

### `src/components/ItemsTable/cellRenderers/SyncStatusRenderer.tsx`

```tsx
import type { CustomCellRendererProps } from 'ag-grid-react';
import { Icons } from '../../Icons';
import type { MasterListItem, RowSyncState } from '../types';

interface SyncStatusRendererProps extends CustomCellRendererProps<MasterListItem> {
  syncStateById?: Record<string, RowSyncState>;
}

export const SyncStatusRenderer = (props: SyncStatusRendererProps) => {
  const syncState = props.syncStateById?.[props.data?.id ?? ''];
  const status = syncState?.status ?? 'idle';

  switch (status) {
    case 'syncing':
      return <Icons.Loader2 className="w-4 h-4 text-orange-500 animate-spin" />;
    case 'success':
      return <Icons.CheckCircle2 className="w-4 h-4 text-green-500" />;
    case 'error':
      return (
        <span title={syncState?.error}>
          <Icons.AlertCircle className="w-4 h-4 text-red-500" />
        </span>
      );
    default:
      return <span className="w-4 h-4 rounded-full border-2 border-dashed border-gray-300 inline-block" />;
  }
};

```

### `src/components/ItemsTable/cellRenderers/UrlCellRenderer.tsx`

```tsx
import type { CustomCellRendererProps } from 'ag-grid-react';
import type { MasterListItem } from '../types';

export const UrlCellRenderer = (props: CustomCellRendererProps<MasterListItem>) => {
  const url = props.value as string | undefined;
  if (!url?.trim() || url.startsWith('data:')) {
    return <span className="text-gray-400 text-xs italic">—</span>;
  }

  let displayUrl: string;
  try {
    const parsed = new URL(url.startsWith('http') ? url : `https://${url}`);
    displayUrl = parsed.hostname + parsed.pathname.substring(0, 15);
    if (displayUrl.length > 25) displayUrl = displayUrl.substring(0, 25) + '...';
  } catch {
    displayUrl = url.substring(0, 25) + (url.length > 25 ? '...' : '');
  }

  return (
    <a
      href={url.startsWith('http') ? url : `https://${url}`}
      target="_blank"
      rel="noopener noreferrer"
      className="text-[#FC5A29] hover:underline text-xs truncate block"
      onClick={(e) => e.stopPropagation()}
    >
      {displayUrl}
    </a>
  );
};

```

### `src/components/ItemsTable/gridSetup.ts`

```typescript
import { AllEnterpriseModule, ModuleRegistry } from 'ag-grid-enterprise';

ModuleRegistry.registerModules([AllEnterpriseModule]);

// Add license key before production:
// import { LicenseManager } from 'ag-grid-enterprise';
// LicenseManager.setLicenseKey('YOUR_KEY_HERE');

```

### `src/components/ItemsTable/index.ts`

```typescript
export { ItemsGrid } from './ItemsGrid';
export type { ItemsGridProps } from './ItemsGrid';
export type {
  MasterListItem,
  OrderMethod,
  RowSyncStatus,
  RowSyncState,
  SyncResult,
  MasterListFooterState,
  EmailItem,
} from './types';
export { ORDER_METHOD_OPTIONS, DEFAULT_ORDER_METHOD_BY_SOURCE } from './types';

```

### `src/components/ItemsTable/types.ts`

```typescript
export interface MasterListItem {
  id: string;
  source: 'email' | 'url' | 'barcode' | 'photo' | 'csv';
  orderMethod: OrderMethod;
  name: string;
  description?: string;
  supplier?: string;
  location?: string;
  barcode?: string;
  sku?: string;
  asin?: string;
  minQty?: number;
  orderQty?: number;
  currentQty?: number;
  unitPrice?: number;
  imageUrl?: string;
  productUrl?: string;
  color?: string;
  needsAttention: boolean;
  validationErrors?: string[];
}

export type OrderMethod = 'online' | 'purchase_order' | 'production' | 'shopping' | 'email';

export const ORDER_METHOD_OPTIONS: Array<{ value: OrderMethod; label: string }> = [
  { value: 'online', label: 'Online' },
  { value: 'purchase_order', label: 'Purchase Order' },
  { value: 'production', label: 'Production' },
  { value: 'shopping', label: 'Shopping' },
  { value: 'email', label: 'Email' },
];

export const DEFAULT_ORDER_METHOD_BY_SOURCE: Record<MasterListItem['source'], OrderMethod> = {
  email: 'online',
  url: 'online',
  barcode: 'shopping',
  photo: 'production',
  csv: 'purchase_order',
};

export type RowSyncStatus = 'idle' | 'syncing' | 'success' | 'error';

export interface RowSyncState {
  status: RowSyncStatus;
  ardaEntityId?: string;
  error?: string;
}

export interface SyncResult {
  success: boolean;
  ardaEntityId?: string;
  error?: string;
}

export interface MasterListFooterState {
  selectedCount: number;
  syncedCount: number;
  canSyncSelected: boolean;
  canComplete: boolean;
  isSyncing: boolean;
  onSyncSelected: () => void;
  onComplete: () => void;
}

export interface EmailItem {
  id: string;
  name: string;
  supplier: string;
  asin?: string;
  imageUrl?: string;
  productUrl?: string;
  lastPrice?: number;
  quantity?: number;
  location?: string;
  recommendedMin?: number;
  recommendedOrderQty?: number;
}

```

### `src/components/LoadingSkeleton.tsx`

```tsx
import { Icons } from './Icons';

interface LoadingSkeletonProps {
  type?: 'card' | 'list' | 'chart' | 'text';
  count?: number;
}

export const LoadingSkeleton: React.FC<LoadingSkeletonProps> = ({ type = 'card', count = 1 }) => {
  const items = Array.from({ length: count }, (_, i) => i);

  if (type === 'text') {
    // Use deterministic widths based on index to avoid impure render
    const widths = [75, 90, 65, 85, 70, 95, 80, 60, 88, 72];
    return (
      <div className="space-y-2 animate-pulse">
        {items.map((i) => (
          <div key={i} className="h-4 bg-arda-bg-tertiary rounded w-full" style={{ width: `${widths[i % widths.length]}%` }} />
        ))}
      </div>
    );
  }

  if (type === 'list') {
    return (
      <div className="space-y-3 animate-pulse">
        {items.map((i) => (
          <div key={i} className="flex items-center gap-3 p-3 bg-arda-bg-secondary rounded-lg border border-arda-border">
            <div className="w-10 h-10 bg-arda-bg-tertiary rounded-lg shrink-0" />
            <div className="flex-1 space-y-2">
              <div className="h-4 bg-arda-bg-tertiary rounded w-1/3" />
              <div className="h-3 bg-arda-bg-tertiary/60 rounded w-2/3" />
            </div>
            <div className="h-6 w-16 bg-arda-bg-tertiary rounded" />
          </div>
        ))}
      </div>
    );
  }

  if (type === 'chart') {
    return (
      <div className="h-64 bg-arda-bg-secondary border border-arda-border rounded-lg p-6 animate-pulse">
        <div className="flex items-end justify-around h-full gap-4">
          {[40, 70, 50, 90, 60, 80, 45].map((height, i) => (
            <div 
              key={i} 
              className="w-8 bg-arda-bg-tertiary rounded-t" 
              style={{ height: `${height}%` }} 
            />
          ))}
        </div>
      </div>
    );
  }

  // Default: card
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6 animate-pulse">
      {items.map((i) => (
        <div key={i} className="bg-arda-bg-secondary border border-arda-border rounded-lg p-5">
          <div className="flex justify-between items-start mb-4">
            <div className="space-y-2">
              <div className="h-5 bg-arda-bg-tertiary rounded w-32" />
              <div className="h-3 bg-arda-bg-tertiary/60 rounded w-20" />
            </div>
            <div className="h-6 w-14 bg-arda-bg-tertiary rounded" />
          </div>
          <div className="grid grid-cols-2 gap-4 mb-4">
            <div className="bg-arda-bg-tertiary p-3 rounded space-y-2">
              <div className="h-3 bg-arda-bg-tertiary/60 rounded w-12" />
              <div className="h-5 bg-arda-bg-tertiary rounded w-16" />
            </div>
            <div className="bg-arda-bg-tertiary p-3 rounded space-y-2">
              <div className="h-3 bg-arda-bg-tertiary/60 rounded w-12" />
              <div className="h-5 bg-arda-bg-tertiary rounded w-16" />
            </div>
          </div>
          <div className="border-t border-arda-border pt-4 flex justify-between">
            <div className="h-4 bg-arda-bg-tertiary/60 rounded w-20" />
            <div className="h-8 bg-arda-bg-tertiary rounded w-24" />
          </div>
        </div>
      ))}
    </div>
  );
};

interface PageLoadingProps {
  message?: string;
}

export const PageLoading: React.FC<PageLoadingProps> = ({ message = 'Loading...' }) => {
  return (
    <div className="flex flex-col items-center justify-center min-h-[400px] gap-4">
      <Icons.Loader2 className="w-10 h-10 text-arda-accent animate-spin" />
      <p className="text-sm text-arda-text-muted font-medium">{message}</p>
    </div>
  );
};

```

### `src/components/OrderTimeline.tsx`

```tsx
import React, { useMemo } from 'react';
import {
  ScatterChart,
  Scatter,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts';
import { ExtractedOrder } from '../types';

interface OrderTimelineProps {
  orders: ExtractedOrder[];
  onOrderClick?: (order: ExtractedOrder) => void;
}

// Color palette for suppliers
const SUPPLIER_COLORS = [
  '#f97316', // orange-500
  '#3b82f6', // blue-500
  '#10b981', // green-500
  '#8b5cf6', // purple-500
  '#ec4899', // pink-500
  '#06b6d4', // cyan-500
  '#f59e0b', // amber-500
  '#ef4444', // red-500
  '#14b8a6', // teal-500
  '#6366f1', // indigo-500
];

interface ChartDataPoint {
  x: number; // timestamp
  y: number; // totalAmount
  order: ExtractedOrder;
  supplier: string;
  date: string;
  itemCount: number;
}

const CustomTooltip = ({ active, payload }: { active?: boolean; payload?: Array<{ payload: ChartDataPoint }> }) => {
  if (active && payload && payload.length > 0) {
    const data = payload[0].payload;
    const order = data.order;
    const date = new Date(order.orderDate);
    
    return (
      <div className="bg-white border border-arda-border rounded-lg p-3 shadow-lg">
        <div className="text-arda-text-primary font-semibold mb-2">{order.supplier}</div>
        <div className="text-sm space-y-1">
          <div className="text-arda-text-secondary">
            Date: <span className="text-arda-text-primary">{date.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
            })}</span>
          </div>
          <div className="text-arda-text-secondary">
            Amount: <span className="text-arda-text-primary">${order.totalAmount?.toFixed(2) || 'N/A'}</span>
          </div>
          <div className="text-arda-text-secondary">
            Items: <span className="text-arda-text-primary">{order.items.length}</span>
          </div>
          {order.confidence < 1 && (
            <div className="text-arda-text-muted text-xs mt-1">
              Confidence: {(order.confidence * 100).toFixed(0)}%
            </div>
          )}
        </div>
      </div>
    );
  }
  return null;
};

export const OrderTimeline: React.FC<OrderTimelineProps> = ({
  orders,
  onOrderClick,
}) => {
  // Transform orders into chart data
  const chartData = useMemo(() => {
    return orders
      .filter(order => order.totalAmount !== undefined && order.totalAmount > 0)
      .map(order => ({
        x: new Date(order.orderDate).getTime(),
        y: order.totalAmount!,
        order,
        supplier: order.supplier,
        date: order.orderDate,
        itemCount: order.items.length,
      }))
      .sort((a, b) => a.x - b.x);
  }, [orders]);

  // Get unique suppliers and assign colors
  const supplierColorMap = useMemo(() => {
    const suppliers = Array.from(new Set(orders.map(o => o.supplier)));
    const map = new Map<string, string>();
    suppliers.forEach((supplier, index) => {
      map.set(supplier, SUPPLIER_COLORS[index % SUPPLIER_COLORS.length]);
    });
    return map;
  }, [orders]);

  // Group data by supplier for legend
  const supplierData = useMemo(() => {
    const suppliers = Array.from(new Set(orders.map(o => o.supplier)));
    return suppliers.map(supplier => ({
      name: supplier,
      color: supplierColorMap.get(supplier) || SUPPLIER_COLORS[0],
    }));
  }, [orders, supplierColorMap]);

  // Format date for X-axis
  const formatXAxis = (tickItem: number) => {
    const date = new Date(tickItem);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
    });
  };

  // Format currency for Y-axis
  const formatYAxis = (tickItem: number) => {
    if (tickItem >= 1000) {
      return `$${(tickItem / 1000).toFixed(1)}k`;
    }
    return `$${tickItem.toFixed(0)}`;
  };

  if (orders.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-12 bg-white rounded-lg border border-arda-border">
        <p className="text-arda-text-secondary text-lg">No order data to display</p>
        <p className="text-arda-text-muted text-sm mt-1">
          Process orders to see timeline visualization
        </p>
      </div>
    );
  }

  if (chartData.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-12 bg-white rounded-lg border border-arda-border">
        <p className="text-arda-text-secondary text-lg">No orders with amounts to display</p>
        <p className="text-arda-text-muted text-sm mt-1">
          Orders need total amounts to appear on the timeline
        </p>
      </div>
    );
  }

  return (
    <div className="w-full h-full bg-white rounded-lg border border-arda-border p-4">
      <div className="mb-4">
        <h3 className="text-lg font-semibold text-arda-text-primary mb-1">Order Timeline</h3>
        <p className="text-sm text-arda-text-muted">
          Visualizing {orders.length} order{orders.length !== 1 ? 's' : ''} over time
        </p>
      </div>
      
      <ResponsiveContainer width="100%" height={400}>
        <ScatterChart
          margin={{ top: 20, right: 30, bottom: 60, left: 60 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke="#E5E7EB" opacity={0.5} />
          <XAxis
            type="number"
            dataKey="x"
            domain={['dataMin', 'dataMax']}
            tickFormatter={formatXAxis}
            stroke="#4B5563"
            style={{ fontSize: '12px' }}
            label={{
              value: 'Date',
              position: 'insideBottom',
              offset: -10,
              style: { textAnchor: 'middle', fill: '#4B5563', fontSize: '14px' },
            }}
          />
          <YAxis
            type="number"
            dataKey="y"
            tickFormatter={formatYAxis}
            stroke="#4B5563"
            style={{ fontSize: '12px' }}
            label={{
              value: 'Order Value',
              angle: -90,
              position: 'insideLeft',
              style: { textAnchor: 'middle', fill: '#4B5563', fontSize: '14px' },
            }}
          />
          <Tooltip content={<CustomTooltip />} />
          <Legend
            wrapperStyle={{ paddingTop: '20px' }}
            iconType="circle"
            formatter={(value) => (
              <span style={{ color: '#4B5563', fontSize: '12px' }}>{value}</span>
            )}
          />
          {supplierData.map((supplier) => {
            const supplierPoints = chartData.filter(d => d.supplier === supplier.name);
            return (
              <Scatter
                key={supplier.name}
                name={supplier.name}
                data={supplierPoints}
                fill={supplier.color}
                onClick={(data: ChartDataPoint) => {
                  if (onOrderClick && data?.order) {
                    onOrderClick(data.order);
                  }
                }}
                style={{ cursor: onOrderClick ? 'pointer' : 'default' }}
              />
            );
          })}
        </ScatterChart>
      </ResponsiveContainer>
    </div>
  );
};

export default OrderTimeline;

```

### `src/components/OrderTree.tsx`

```tsx
import React, { useState, useMemo, useEffect, useRef, useCallback } from 'react';
import { Icons } from './Icons';
import { TreeNode } from './TreeNode';
import { JourneyNode, ExtractedOrder, RawEmail, LineItemNodeData } from '../types';
import { buildJourneyTree, buildVelocityProfiles } from '../utils/inventoryLogic';

interface OrderTreeProps {
  orders: ExtractedOrder[];
  emails?: RawEmail[];
  onItemClick?: (itemData: LineItemNodeData) => void;
  className?: string;
}

type ViewMode = 'chronological' | 'bySupplier' | 'byItem';

export const OrderTree: React.FC<OrderTreeProps> = ({
  orders,
  emails,
  onItemClick,
  className = '',
}) => {
  const [viewMode, setViewMode] = useState<ViewMode>('chronological');
  const [searchQuery, setSearchQuery] = useState('');
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set());
  const [focusedNodeId, setFocusedNodeId] = useState<string | null>(null);
  const treeContainerRef = useRef<HTMLDivElement>(null);

  // Build the journey tree and velocity profiles
  const velocityProfiles = useMemo(() => 
    buildVelocityProfiles(orders), 
    [orders]
  );

  const journeyTree = useMemo(
    () => buildJourneyTree(orders, emails),
    [orders, emails]
  );

  const handleNodeClick = useCallback((node: JourneyNode) => {
    if (node.type === 'lineItem' && onItemClick && node.data) {
      onItemClick(node.data as LineItemNodeData);
    }
  }, [onItemClick]);

  // Filter tree based on search query
  const filteredTree = useMemo(() => {
    if (!searchQuery.trim()) return journeyTree;
    
    const query = searchQuery.toLowerCase();
    
    const filterNode = (node: JourneyNode): JourneyNode | null => {
      // Check if this node matches
      const labelMatch = node.label.toLowerCase().includes(query);
      const subtitleMatch = node.subtitle?.toLowerCase().includes(query);
      
      // Filter children recursively
      const filteredChildren = node.children
        ?.map(filterNode)
        .filter((n): n is JourneyNode => n !== null);
      
      // Include node if it matches or has matching children
      if (labelMatch || subtitleMatch || (filteredChildren && filteredChildren.length > 0)) {
        return {
          ...node,
          children: filteredChildren,
          isExpanded: true, // Auto-expand when filtering
        };
      }
      
      return null;
    };
    
    return journeyTree
      .map(filterNode)
      .filter((n): n is JourneyNode => n !== null);
  }, [journeyTree, searchQuery]);

  // Group by supplier view
  const supplierTree = useMemo((): JourneyNode[] => {
    const supplierMap = new Map<string, JourneyNode[]>();
    
    journeyTree.forEach(emailNode => {
      emailNode.children?.forEach(orderNode => {
        const supplier = orderNode.label.replace('Order from ', '');
        if (!supplierMap.has(supplier)) {
          supplierMap.set(supplier, []);
        }
        supplierMap.get(supplier)!.push({
          ...orderNode,
          isExpanded: false,
        });
      });
    });
    
    return Array.from(supplierMap.entries()).map(([supplier, orderNodes]) => ({
      id: `supplier-${supplier}`,
      type: 'email' as const,
      label: supplier,
      subtitle: `${orderNodes.length} order(s)`,
      isExpanded: true,
      children: orderNodes,
    }));
  }, [journeyTree]);

  // Group by item view
  const itemTree = useMemo((): JourneyNode[] => {
    return Array.from(velocityProfiles.values())
      .sort((a, b) => b.dailyBurnRate - a.dailyBurnRate)
      .map(profile => ({
        id: `item-${profile.normalizedName}`,
        type: 'lineItem' as const,
        label: profile.displayName,
        subtitle: `${profile.orderCount} orders | ${profile.dailyBurnRate.toFixed(1)}/day`,
        isExpanded: false,
        data: {
          lineItemId: profile.normalizedName,
          orderId: '',
          emailId: '',
          name: profile.displayName,
          normalizedName: profile.normalizedName,
          quantity: profile.totalQuantityOrdered,
          unit: 'total',
          sku: profile.sku,
        } as LineItemNodeData,
        children: profile.orders.map(order => ({
          id: `order-occurrence-${order.orderId}-${profile.normalizedName}`,
          type: 'order' as const,
          label: `${new Date(order.date).toLocaleDateString()}`,
          subtitle: `Qty: ${order.quantity}${order.unitPrice ? ` @ $${order.unitPrice.toFixed(2)}` : ''}`,
          data: {
            orderId: order.orderId,
            emailId: order.emailId,
            supplier: profile.supplier,
            orderDate: order.date,
            totalAmount: order.unitPrice ? order.quantity * order.unitPrice : undefined,
            itemCount: 1,
            confidence: 1,
          },
        })),
      }));
  }, [velocityProfiles]);

  // Get the tree to display based on view mode
  const displayTree = useMemo(() => {
    switch (viewMode) {
      case 'bySupplier':
        return supplierTree;
      case 'byItem':
        return itemTree;
      default:
        return filteredTree;
    }
  }, [viewMode, filteredTree, supplierTree, itemTree]);

  // Recursively set expanded state for all nodes
  const setAllNodesExpanded = useCallback((nodes: JourneyNode[], expanded: boolean) => {
    const newExpandedNodes = new Set<string>();
    
    const traverse = (nodeList: JourneyNode[]) => {
      nodeList.forEach(node => {
        if (node.children && node.children.length > 0) {
          if (expanded) {
            newExpandedNodes.add(node.id);
          }
          traverse(node.children);
        }
      });
    };
    
    traverse(nodes);
    setExpandedNodes(newExpandedNodes);
  }, []);

  // Flatten tree to get all visible nodes in order
  const getVisibleNodes = useCallback((nodes: JourneyNode[]): JourneyNode[] => {
    const visible: JourneyNode[] = [];
    
    const traverse = (nodeList: JourneyNode[]) => {
      nodeList.forEach(node => {
        visible.push(node);
        if (node.children && node.children.length > 0 && expandedNodes.has(node.id)) {
          traverse(node.children);
        }
      });
    };
    
    traverse(nodes);
    return visible;
  }, [expandedNodes]);

  const visibleNodes = useMemo(() => getVisibleNodes(displayTree), [displayTree, getVisibleNodes]);

  // Handle expand/collapse all
  const handleExpandAll = useCallback(() => {
    setAllNodesExpanded(displayTree, true);
  }, [displayTree, setAllNodesExpanded]);

  const handleCollapseAll = useCallback(() => {
    setAllNodesExpanded(displayTree, false);
  }, [displayTree, setAllNodesExpanded]);

  // Handle node expand toggle
  const handleNodeExpandToggle = useCallback((nodeId: string, isExpanded: boolean) => {
    setExpandedNodes(prev => {
      const next = new Set(prev);
      if (isExpanded) {
        next.add(nodeId);
      } else {
        next.delete(nodeId);
      }
      return next;
    });
  }, []);

  // Keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Only handle if tree container is focused or contains focused element
      if (!treeContainerRef.current?.contains(document.activeElement)) {
        return;
      }

      // Don't handle if user is typing in search input
      if (document.activeElement?.tagName === 'INPUT') {
        return;
      }

      const currentIndex = focusedNodeId 
        ? visibleNodes.findIndex(n => n.id === focusedNodeId)
        : -1;

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          if (visibleNodes.length > 0) {
            const nextIndex = currentIndex < visibleNodes.length - 1 
              ? currentIndex + 1 
              : 0;
            setFocusedNodeId(visibleNodes[nextIndex].id);
            // Scroll into view
            setTimeout(() => {
              const element = document.querySelector(`[data-node-id="${visibleNodes[nextIndex].id}"]`);
              element?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 0);
          }
          break;
        
        case 'ArrowUp':
          e.preventDefault();
          if (visibleNodes.length > 0) {
            const prevIndex = currentIndex > 0 
              ? currentIndex - 1 
              : visibleNodes.length - 1;
            setFocusedNodeId(visibleNodes[prevIndex].id);
            // Scroll into view
            setTimeout(() => {
              const element = document.querySelector(`[data-node-id="${visibleNodes[prevIndex].id}"]`);
              element?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 0);
          }
          break;
        
        case 'ArrowRight':
          e.preventDefault();
          if (focusedNodeId) {
            const node = visibleNodes.find(n => n.id === focusedNodeId);
            if (node && node.children && node.children.length > 0 && !expandedNodes.has(node.id)) {
              handleNodeExpandToggle(node.id, true);
            }
          }
          break;
        
        case 'ArrowLeft':
          e.preventDefault();
          if (focusedNodeId) {
            const node = visibleNodes.find(n => n.id === focusedNodeId);
            if (node && node.children && node.children.length > 0 && expandedNodes.has(node.id)) {
              handleNodeExpandToggle(node.id, false);
            }
          }
          break;
        
        case 'Enter':
          e.preventDefault();
          if (focusedNodeId) {
            const node = visibleNodes.find(n => n.id === focusedNodeId);
            if (node) {
              handleNodeClick(node);
            }
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [focusedNodeId, visibleNodes, expandedNodes, handleNodeExpandToggle, handleNodeClick]);

  // Set initial focus on first node if none focused
  useEffect(() => {
    if (focusedNodeId || visibleNodes.length === 0) return;
    setTimeout(() => {
      setFocusedNodeId(visibleNodes[0].id);
    }, 0);
  }, [visibleNodes, focusedNodeId]);

  // Reset expanded nodes when view mode changes
  useEffect(() => {
    setTimeout(() => {
      setExpandedNodes(new Set());
      setFocusedNodeId(null);
    }, 0);
  }, [viewMode]);

  // Summary stats
  const stats = useMemo(() => ({
    emails: journeyTree.length,
    orders: journeyTree.reduce((sum, e) => sum + (e.children?.length || 0), 0),
    lineItems: journeyTree.reduce((sum, e) => 
      sum + (e.children?.reduce((s, o) => s + (o.children?.length || 0), 0) || 0), 0
    ),
    uniqueItems: velocityProfiles.size,
  }), [journeyTree, velocityProfiles]);

  if (orders.length === 0) {
    return (
      <div className={`flex flex-col items-center justify-center py-12 ${className}`}>
        <Icons.GitBranch className="w-12 h-12 text-arda-text-muted mb-4" />
        <p className="text-arda-text-secondary text-lg">No order data to display</p>
        <p className="text-arda-text-muted text-sm mt-1">
          Process emails from the Ingestion Engine to see your order journey
        </p>
      </div>
    );
  }

  return (
    <div className={`flex flex-col h-full ${className}`}>
      {/* Header */}
      <div className="flex-shrink-0 mb-4">
        <div className="flex items-center justify-between mb-3">
          <div>
            <h2 className="text-xl font-semibold text-arda-text-primary flex items-center gap-2">
              <Icons.GitBranch className="w-5 h-5 text-arda-accent" />
              Order Journey
            </h2>
            <p className="text-sm text-arda-text-secondary mt-1">
              Trace the flow from email to order to line items
            </p>
          </div>
          
          {/* View Mode Toggle and Expand/Collapse Controls */}
          <div className="flex items-center gap-2">
            <div className="flex items-center gap-2 bg-arda-bg-tertiary border border-arda-border rounded-lg p-1">
              <button
                onClick={() => setViewMode('chronological')}
                className={`px-3 py-1.5 rounded text-sm transition-colors ${
                  viewMode === 'chronological'
                    ? 'bg-arda-accent text-white'
                    : 'text-arda-text-secondary hover:text-arda-text-primary'
                }`}
              >
                Timeline
              </button>
              <button
                onClick={() => setViewMode('bySupplier')}
                className={`px-3 py-1.5 rounded text-sm transition-colors ${
                  viewMode === 'bySupplier'
                    ? 'bg-arda-accent text-white'
                    : 'text-arda-text-secondary hover:text-arda-text-primary'
                }`}
              >
                By Supplier
              </button>
              <button
                onClick={() => setViewMode('byItem')}
                className={`px-3 py-1.5 rounded text-sm transition-colors ${
                  viewMode === 'byItem'
                    ? 'bg-arda-accent text-white'
                    : 'text-arda-text-secondary hover:text-arda-text-primary'
                }`}
              >
                By Item
              </button>
            </div>
            
            {/* Expand/Collapse All Buttons */}
            <div className="flex items-center gap-1 bg-arda-bg-tertiary border border-arda-border rounded-lg p-1">
              <button
                onClick={handleExpandAll}
                className="px-3 py-1.5 rounded text-sm text-arda-text-secondary hover:text-arda-text-primary transition-colors flex items-center gap-1.5"
                title="Expand All"
              >
                <Icons.ChevronDown className="w-4 h-4" />
                Expand All
              </button>
              <button
                onClick={handleCollapseAll}
                className="px-3 py-1.5 rounded text-sm text-arda-text-secondary hover:text-arda-text-primary transition-colors flex items-center gap-1.5"
                title="Collapse All"
              >
                <Icons.ChevronRight className="w-4 h-4" />
                Collapse All
              </button>
            </div>
          </div>
        </div>

        {/* Stats Bar */}
        <div className="flex items-center gap-4 text-sm">
          <div className="flex items-center gap-1.5">
            <Icons.Mail className="w-4 h-4 text-arda-accent" />
            <span className="text-arda-text-secondary">{stats.emails} emails</span>
          </div>
          <div className="flex items-center gap-1.5">
            <Icons.Package className="w-4 h-4 text-arda-accent" />
            <span className="text-arda-text-secondary">{stats.orders} orders</span>
          </div>
          <div className="flex items-center gap-1.5">
            <Icons.Box className="w-4 h-4 text-arda-accent" />
            <span className="text-arda-text-secondary">{stats.lineItems} line items</span>
          </div>
          <div className="flex items-center gap-1.5">
            <Icons.Activity className="w-4 h-4 text-arda-accent" />
            <span className="text-arda-text-secondary">{stats.uniqueItems} unique items</span>
          </div>
        </div>

        {/* Search Bar */}
        <div className="relative mt-3">
          <Icons.Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-arda-text-muted" />
          <input
            type="text"
            placeholder="Search items, suppliers, orders..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full bg-white border border-arda-border rounded-lg pl-10 pr-4 py-2 text-sm text-arda-text-primary placeholder-arda-text-muted focus:outline-none focus:border-arda-accent"
          />
          {searchQuery && (
            <button
              onClick={() => setSearchQuery('')}
              className="absolute right-3 top-1/2 -translate-y-1/2 text-arda-text-muted hover:text-arda-text-primary"
              title="Clear search"
              aria-label="Clear search"
            >
              <Icons.X className="w-4 h-4" />
            </button>
          )}
        </div>
      </div>

      {/* Tree View */}
      <div 
        ref={treeContainerRef}
        className="flex-1 overflow-y-auto bg-white rounded-lg border border-arda-border p-2"
        tabIndex={0}
        onFocus={() => {
          // Set focus to first node if none focused
          if (!focusedNodeId && visibleNodes.length > 0) {
            setFocusedNodeId(visibleNodes[0].id);
          }
        }}
      >
        {displayTree.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-8">
            <Icons.Search className="w-8 h-8 text-arda-text-muted mb-2" />
            <p className="text-arda-text-secondary">No results match your search</p>
          </div>
        ) : (
          displayTree.map((node) => (
            <TreeNode
              key={node.id}
              node={node}
              level={0}
              velocityProfiles={velocityProfiles}
              onNodeClick={handleNodeClick}
              onExpandToggle={handleNodeExpandToggle}
              expandedNodes={expandedNodes}
              focusedNodeId={focusedNodeId}
              onFocusChange={setFocusedNodeId}
            />
          ))
        )}
      </div>
    </div>
  );
};

export default OrderTree;

```

### `src/components/ReorderAlerts.tsx`

```tsx
import React, { useMemo } from 'react';
import { ItemVelocityProfile } from '../types';
import { Icons } from './Icons';

interface ReorderAlertsProps {
  velocityProfiles: Map<string, ItemVelocityProfile>;
  onItemClick?: (name: string) => void;
}

interface AlertItem {
  profile: ItemVelocityProfile;
  daysUntil: number;
  urgency: 'red' | 'orange' | 'yellow';
}

export const ReorderAlerts: React.FC<ReorderAlertsProps> = ({
  velocityProfiles,
  onItemClick,
}) => {
  // Calculate days until next order and create alert items
  const alertItems = useMemo(() => {
    const items: AlertItem[] = [];
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    velocityProfiles.forEach((profile) => {
      if (!profile.nextPredictedOrder) return;

      const nextOrderDate = new Date(profile.nextPredictedOrder);
      nextOrderDate.setHours(0, 0, 0, 0);
      
      const daysUntil = Math.ceil(
        (nextOrderDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)
      );

      // Only include items that need reordering soon (within 14 days)
      if (daysUntil <= 14) {
        let urgency: 'red' | 'orange' | 'yellow';
        if (daysUntil < 3) {
          urgency = 'red';
        } else if (daysUntil < 7) {
          urgency = 'orange';
        } else {
          urgency = 'yellow';
        }

        items.push({
          profile,
          daysUntil,
          urgency,
        });
      }
    });

    // Sort by urgency (soonest first)
    return items.sort((a, b) => a.daysUntil - b.daysUntil);
  }, [velocityProfiles]);

  const displayItems = alertItems.slice(0, 5);
  const hasMore = alertItems.length > 5;

  const getUrgencyConfig = (urgency: 'red' | 'orange' | 'yellow') => {
    switch (urgency) {
      case 'red':
        return {
          icon: Icons.AlertCircle,
          iconColor: 'text-red-400',
          bgColor: 'bg-red-500/10',
          borderColor: 'border-red-500/30',
          textColor: 'text-red-400',
        };
      case 'orange':
        return {
          icon: Icons.Clock,
          iconColor: 'text-orange-400',
          bgColor: 'bg-orange-500/10',
          borderColor: 'border-orange-500/30',
          textColor: 'text-orange-400',
        };
      case 'yellow':
        return {
          icon: Icons.Clock,
          iconColor: 'text-yellow-400',
          bgColor: 'bg-yellow-500/10',
          borderColor: 'border-yellow-500/30',
          textColor: 'text-yellow-400',
        };
    }
  };

  const formatDaysUntil = (days: number): string => {
    if (days < 0) {
      return `${Math.abs(days)} day${Math.abs(days) !== 1 ? 's' : ''} overdue`;
    } else if (days === 0) {
      return 'Today';
    } else {
      return `${days} day${days !== 1 ? 's' : ''}`;
    }
  };

  if (alertItems.length === 0) {
    return (
      <div className="p-4 rounded-lg border border-arda-border bg-white">
        <div className="flex items-center gap-2 mb-2">
          <Icons.CheckCircle2 className="w-5 h-5 text-green-400" />
          <h3 className="text-sm font-semibold text-arda-text-primary">Reorder Alerts</h3>
        </div>
        <p className="text-xs text-arda-text-muted">No items need reordering in the next 14 days.</p>
      </div>
    );
  }

  return (
    <div className="p-4 rounded-lg border border-arda-border bg-white">
      <div className="flex items-center gap-2 mb-3">
        <Icons.AlertCircle className="w-5 h-5 text-orange-400" />
        <h3 className="text-sm font-semibold text-arda-text-primary">Reorder Alerts</h3>
        <span className="text-xs px-2 py-0.5 bg-orange-500/20 text-orange-400 rounded-full">
          {alertItems.length}
        </span>
      </div>

      <div className="space-y-2">
        {displayItems.map((item) => {
          const config = getUrgencyConfig(item.urgency);
          const Icon = config.icon;

          return (
            <div
              key={item.profile.normalizedName}
              className={`p-3 rounded-lg border ${config.bgColor} ${config.borderColor} flex items-start gap-3 cursor-pointer hover:opacity-80 transition-opacity`}
              onClick={() => onItemClick?.(item.profile.normalizedName)}
            >
              <div className={`flex-shrink-0 mt-0.5 ${config.iconColor}`}>
                <Icon className="w-5 h-5" />
              </div>
              <div className="flex-1 min-w-0">
                <div className="flex items-start justify-between gap-2">
                  <div className="flex-1 min-w-0">
                    <div className="text-sm font-medium text-arda-text-primary truncate">
                      {item.profile.displayName}
                    </div>
                    <div className="text-xs text-arda-text-muted mt-0.5">
                      {item.profile.supplier}
                    </div>
                    <div className="flex items-center gap-3 mt-2">
                      <div className="flex items-center gap-1.5">
                        <Icons.Calendar className={`w-3.5 h-3.5 ${config.textColor}`} />
                        <span className={`text-xs font-medium ${config.textColor}`}>
                          {formatDaysUntil(item.daysUntil)}
                        </span>
                      </div>
                      <div className="flex items-center gap-1.5">
                        <Icons.Zap className="w-3.5 h-3.5 text-arda-text-muted" />
                        <span className="text-xs text-arda-text-muted">
                          {item.profile.dailyBurnRate.toFixed(1)}/day
                        </span>
                      </div>
                    </div>
                  </div>
                  <Icons.ChevronRight className="w-4 h-4 text-arda-text-muted flex-shrink-0 mt-0.5" />
                </div>
              </div>
            </div>
          );
        })}
      </div>

      {hasMore && (
        <div className="mt-3 pt-3 border-t border-arda-border">
          <button
            onClick={() => {
              // Could navigate to a full alerts view or expand the list
              console.log('View all alerts');
            }}
            className="w-full flex items-center justify-center gap-2 text-xs text-arda-text-muted hover:text-arda-text-primary transition-colors py-1.5"
          >
            <span>View All {alertItems.length} Alerts</span>
            <Icons.ArrowRight className="w-3.5 h-3.5" />
          </button>
        </div>
      )}
    </div>
  );
};

export default ReorderAlerts;

```

### `src/components/ReorderSparkline.tsx`

```tsx
import React from 'react';
import { LineChart, Line, ResponsiveContainer, Tooltip } from 'recharts';

interface OrderDataPoint {
  date: string;
  quantity: number;
}

interface ReorderSparklineProps {
  orders: OrderDataPoint[];
  width?: number;
  height?: number;
  color?: string;
  showTooltip?: boolean;
}

export const ReorderSparkline: React.FC<ReorderSparklineProps> = ({
  orders,
  width = 100,
  height = 24,
  color = '#f97316', // orange-500
  showTooltip = true,
}) => {
  if (!orders || orders.length < 2) {
    return (
      <div 
        className="flex items-center justify-center text-xs text-arda-text-muted"
        style={{ width, height }}
      >
        —
      </div>
    );
  }

  // Sort and format data for the chart
  const chartData = orders
    .map(o => ({
      date: o.date,
      quantity: o.quantity,
      displayDate: new Date(o.date).toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric' 
      }),
    }))
    .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

  return (
    <div style={{ width, height }} className="overflow-hidden">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart data={chartData} margin={{ top: 2, right: 2, bottom: 2, left: 2 }}>
          {showTooltip && (
            <Tooltip
              contentStyle={{
                background: '#ffffff',
                border: '1px solid #E5E7EB',
                borderRadius: '6px',
                fontSize: '11px',
                padding: '4px 8px',
              }}
              labelStyle={{ color: '#4B5563' }}
              formatter={(value) => [`Qty: ${value}`, '']}
              labelFormatter={(_label, payload) => {
                if (payload && payload[0]) {
                  return (payload[0].payload as { displayDate: string }).displayDate;
                }
                return '';
              }}
            />
          )}
          <Line
            type="monotone"
            dataKey="quantity"
            stroke={color}
            strokeWidth={1.5}
            dot={false}
            activeDot={{ r: 3, fill: color }}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
};

export default ReorderSparkline;

```

### `src/components/Sidebar.tsx`

```tsx
import { NAV_ITEMS, APP_DESCRIPTION } from '../constants';
import { Icons } from './Icons';
import { GoogleUserProfile } from '../types';

interface IngestionProgress {
  total: number;
  processed: number;
  success: number;
  failed: number;
  currentTask: string;
}

interface SidebarProps {
  activeView: string;
  onChangeView: (view: string) => void;
  userProfile?: GoogleUserProfile | null;
  onLogout?: () => void;
  onReset?: () => void;
  isIngesting?: boolean;
  ingestionProgress?: IngestionProgress;
}

// Arda logo SVG
const ArdaLogo = ({ className = "h-7 w-auto" }: { className?: string }) => (
  <svg viewBox="0 0 80 28" className={className}>
    <text x="0" y="22" fill="#FC5A29" fontSize="24" fontWeight="bold" fontFamily="system-ui, -apple-system, sans-serif">
      arda
    </text>
  </svg>
);

export const Sidebar: React.FC<SidebarProps> = ({ 
  activeView, 
  onChangeView,
  userProfile,
  onLogout,
  onReset,
  isIngesting,
  ingestionProgress,
}) => {
  return (
    <div className="w-64 h-screen bg-white border-r border-arda-border flex flex-col fixed left-0 top-0 z-20">
      {/* Header */}
      <div className="p-6 border-b border-arda-border">
        <div className="flex items-center gap-2">
          <ArdaLogo />
          <span className="text-xs font-medium text-arda-text-muted uppercase tracking-wider">{APP_DESCRIPTION}</span>
        </div>
        
        {/* Sync Status */}
        {isIngesting && ingestionProgress && (
          <div className="mt-3 bg-orange-50 rounded-lg p-2">
            <div className="flex items-center gap-2 text-xs text-orange-700">
              <div className="animate-spin w-3 h-3 border-2 border-orange-500 border-t-transparent rounded-full" />
              <span className="font-medium">Syncing emails...</span>
            </div>
            <div className="mt-1 text-xs text-orange-600">
              {ingestionProgress.processed}/{ingestionProgress.total} processed
            </div>
            <div className="mt-1 h-1 bg-orange-200 rounded-full overflow-hidden">
              <div 
                className="h-full bg-orange-500 transition-all duration-300"
                style={{ 
                  width: ingestionProgress.total > 0 
                    ? `${(ingestionProgress.processed / ingestionProgress.total) * 100}%` 
                    : '0%' 
                }}
              />
            </div>
          </div>
        )}
      </div>

      {/* Navigation */}
      <nav className="flex-1 p-4 space-y-1">
        {NAV_ITEMS.map((item) => {
          const Icon = Icons[item.icon as keyof typeof Icons];
          const isActive = activeView === item.id;
          return (
            <button
              key={item.id}
              onClick={() => onChangeView(item.id)}
              className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium transition-all duration-200 ${
                isActive
                  ? 'bg-orange-50 text-arda-accent'
                  : 'text-arda-text-secondary hover:text-arda-text-primary hover:bg-arda-bg-tertiary'
              }`}
            >
              <Icon className={`w-5 h-5 ${isActive ? 'text-arda-accent' : ''}`} />
              {item.label}
            </button>
          );
        })}
        
        {/* Divider */}
        <div className="my-3 border-t border-arda-border" />
        
        {/* Reset Button */}
        <button
          onClick={onReset}
          disabled={isIngesting}
          className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg text-sm font-medium transition-all duration-200 ${
            isIngesting
              ? 'text-arda-text-muted cursor-not-allowed'
              : 'text-red-600 hover:text-red-700 hover:bg-red-50'
          }`}
        >
          <Icons.RefreshCw className={`w-5 h-5 ${isIngesting ? 'animate-spin' : ''}`} />
          {isIngesting ? 'Processing...' : 'Reset & Re-scan'}
        </button>
      </nav>

      {/* User Profile & Logout */}
      <div className="p-4 border-t border-arda-border">
        {userProfile ? (
          <div className="flex items-center gap-3">
            <img 
              src={userProfile.picture} 
              alt={userProfile.name}
              className="w-8 h-8 rounded-full"
            />
            <div className="flex-1 min-w-0">
              <div className="text-sm font-medium text-arda-text-primary truncate">
                {userProfile.name}
              </div>
              <div className="text-xs text-arda-text-muted truncate">
                {userProfile.email}
              </div>
            </div>
            <button
              onClick={onLogout}
              className="p-2 text-arda-text-muted hover:text-arda-text-primary hover:bg-arda-bg-tertiary rounded-lg transition-colors"
              title="Sign out"
            >
              <Icons.LogOut className="w-4 h-4" />
            </button>
          </div>
        ) : (
          <button className="flex items-center gap-3 text-arda-text-secondary hover:text-arda-text-primary text-sm font-medium w-full px-4 py-2 rounded-lg hover:bg-arda-bg-tertiary transition-colors">
            <Icons.Settings className="w-5 h-5" />
            Settings
          </button>
        )}
      </div>
    </div>
  );
};

```

### `src/components/SupplierConfig.tsx`

```tsx
import React from 'react';
import { Icons } from './Icons';

export interface DiscoveredSupplier {
  domain: string;
  displayName: string;
  emailCount: number;
  score: number;
  category: 'industrial' | 'retail' | 'office' | 'food' | 'electronics' | 'unknown';
  sampleSubjects: string[];
  isRecommended: boolean;
}

export interface SupplierConfigProps {
  suppliers: DiscoveredSupplier[];
  enabledSuppliers: string[];
  onToggleSupplier: (domain: string) => void;
  onScanSupplier: (domain: string) => void;
  onScanAllEnabled?: () => void;
  isLoading?: boolean;
  currentlyScanning?: string;
}

const getCategoryConfig = (category: DiscoveredSupplier['category']) => {
  switch (category) {
    case 'industrial':
      return {
        label: 'Industrial',
        color: 'text-blue-400',
        bgColor: 'bg-blue-500/20',
        borderColor: 'border-blue-500/50',
      };
    case 'retail':
      return {
        label: 'Retail',
        color: 'text-green-400',
        bgColor: 'bg-green-500/20',
        borderColor: 'border-green-500/50',
      };
    case 'office':
      return {
        label: 'Office',
        color: 'text-purple-400',
        bgColor: 'bg-purple-500/20',
        borderColor: 'border-purple-500/50',
      };
    case 'food':
      return {
        label: 'Food',
        color: 'text-orange-400',
        bgColor: 'bg-orange-500/20',
        borderColor: 'border-orange-500/50',
      };
    case 'electronics':
      return {
        label: 'Electronics',
        color: 'text-cyan-400',
        bgColor: 'bg-cyan-500/20',
        borderColor: 'border-cyan-500/50',
      };
    case 'unknown':
    default:
      return {
        label: 'Unknown',
        color: 'text-arda-text-muted',
        bgColor: 'bg-arda-bg-tertiary',
        borderColor: 'border-arda-border',
      };
  }
};

export const SupplierConfig: React.FC<SupplierConfigProps> = ({
  suppliers,
  enabledSuppliers,
  onToggleSupplier,
  onScanSupplier,
  onScanAllEnabled,
  isLoading = false,
  currentlyScanning,
}) => {
  const enabledCount = enabledSuppliers.length;
  const hasEnabledSuppliers = enabledCount > 0;

  return (
    <div className="space-y-6">
      {/* Header */}
      <div>
        <h2 className="text-2xl font-bold text-arda-text-primary mb-2">
          Configure Your Suppliers
        </h2>
        <p className="text-arda-text-secondary text-sm">
          Start with one supplier at a time. We recommend beginning with Amazon.
        </p>
      </div>

      {/* Scan All Enabled Button */}
      {hasEnabledSuppliers && onScanAllEnabled && (
        <div className="flex items-center justify-between bg-white border border-arda-border rounded-xl shadow-arda p-4">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 bg-arda-accent/10 rounded-lg flex items-center justify-center">
              <Icons.ScanLine className="w-5 h-5 text-arda-accent" />
            </div>
            <div>
              <p className="text-sm font-medium text-arda-text-primary">
                Scan All Enabled Suppliers
              </p>
              <p className="text-xs text-arda-text-muted">
                {enabledCount} supplier{enabledCount !== 1 ? 's' : ''} enabled
              </p>
            </div>
          </div>
          <button
            onClick={onScanAllEnabled}
            disabled={isLoading || !!currentlyScanning}
            className="px-4 py-2 bg-arda-accent text-white rounded-lg font-medium text-sm hover:bg-arda-accent-hover flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            {isLoading ? (
              <>
                <Icons.Loader2 className="w-4 h-4 animate-spin" />
                Scanning...
              </>
            ) : (
              <>
                <Icons.ScanLine className="w-4 h-4" />
                Scan All Enabled
              </>
            )}
          </button>
        </div>
      )}

      {/* Suppliers List */}
      <div className="space-y-3">
        {suppliers.length === 0 ? (
          <div className="bg-white border border-arda-border rounded-xl shadow-arda p-8 text-center">
            <Icons.Building2 className="w-12 h-12 text-arda-text-muted mx-auto mb-3" />
            <p className="text-arda-text-secondary font-medium mb-1">No suppliers discovered yet</p>
            <p className="text-sm text-arda-text-muted">
              Connect your email account to discover suppliers from your order emails.
            </p>
          </div>
        ) : (
          suppliers.map((supplier) => {
            const isEnabled = enabledSuppliers.includes(supplier.domain);
            const isScanning = currentlyScanning === supplier.domain;
            const categoryConfig = getCategoryConfig(supplier.category);
            const isDisabled = isLoading || (!!currentlyScanning && !isScanning);

            return (
              <div
                key={supplier.domain}
                className={`bg-white border rounded-xl shadow-arda p-5 transition-all ${
                  supplier.isRecommended
                    ? 'border-arda-accent/50 bg-orange-50/30'
                    : 'border-arda-border'
                } ${isDisabled ? 'opacity-60' : ''}`}
              >
                <div className="flex items-start justify-between gap-4">
                  {/* Left: Supplier Info */}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-start gap-3 mb-3">
                      {/* Supplier Icon */}
                      <div className={`flex-shrink-0 w-10 h-10 rounded-lg flex items-center justify-center ${
                        supplier.isRecommended ? 'bg-arda-accent/20' : 'bg-arda-bg-tertiary'
                      }`}>
                        <Icons.Building2 className={`w-5 h-5 ${
                          supplier.isRecommended ? 'text-arda-accent' : 'text-arda-text-secondary'
                        }`} />
                      </div>

                      {/* Supplier Details */}
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <h3 className="text-base font-semibold text-arda-text-primary truncate">
                            {supplier.displayName}
                          </h3>
                          {supplier.isRecommended && (
                            <span className="flex-shrink-0 flex items-center gap-1 px-2 py-0.5 bg-arda-accent/20 text-arda-accent text-xs font-medium rounded-full">
                              <Icons.Sparkles className="w-3 h-3" />
                              Recommended
                            </span>
                          )}
                        </div>
                        <p className="text-sm text-arda-text-muted mb-2">{supplier.domain}</p>

                        {/* Stats Row */}
                        <div className="flex items-center gap-4 flex-wrap">
                          {/* Email Count */}
                          <div className="flex items-center gap-1.5">
                            <Icons.Mail className="w-4 h-4 text-arda-text-muted" />
                            <span className="text-sm text-arda-text-secondary">
                              {supplier.emailCount} email{supplier.emailCount !== 1 ? 's' : ''}
                            </span>
                          </div>

                          {/* Category Badge */}
                          <span
                            className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium border ${categoryConfig.bgColor} ${categoryConfig.color} ${categoryConfig.borderColor}`}
                          >
                            {categoryConfig.label}
                          </span>

                          {/* Score */}
                          <div className="flex items-center gap-2">
                            <span className="text-xs text-arda-text-muted">Score:</span>
                            <div className="flex items-center gap-1.5">
                              <div 
                                className="w-20 h-1.5 bg-arda-bg-tertiary rounded-full overflow-hidden relative"
                                role="progressbar"
                                aria-valuenow={Math.min(supplier.score, 100)}
                                aria-valuemin={0}
                                aria-valuemax={100}
                                aria-label={`Supplier confidence score: ${supplier.score}%`}
                              >
                                <div
                                  className={`h-full rounded-full transition-all absolute left-0 top-0 ${
                                    supplier.score >= 70
                                      ? 'bg-green-500'
                                      : supplier.score >= 40
                                      ? 'bg-yellow-500'
                                      : 'bg-arda-text-muted'
                                  }`}
                                  style={{ width: `${Math.min(supplier.score, 100)}%` }}
                                />
                              </div>
                              <span className="text-xs font-medium text-arda-text-secondary w-8">
                                {supplier.score}%
                              </span>
                            </div>
                          </div>
                        </div>

                        {/* Sample Subjects */}
                        {supplier.sampleSubjects.length > 0 && (
                          <div className="mt-3 pt-3 border-t border-arda-border">
                            <p className="text-xs text-arda-text-muted mb-1.5 font-medium">
                              Sample Subjects:
                            </p>
                            <div className="flex flex-wrap gap-1.5">
                              {supplier.sampleSubjects.slice(0, 3).map((subject, idx) => (
                                <span
                                  key={idx}
                                  className="text-xs text-arda-text-secondary bg-arda-bg-secondary px-2 py-0.5 rounded border border-arda-border truncate max-w-[200px]"
                                  title={subject}
                                >
                                  {subject}
                                </span>
                              ))}
                              {supplier.sampleSubjects.length > 3 && (
                                <span className="text-xs text-arda-text-muted">
                                  +{supplier.sampleSubjects.length - 3} more
                                </span>
                              )}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* Right: Controls */}
                  <div className="flex-shrink-0 flex items-center gap-3">
                    {/* Toggle Switch */}
                    <div className="flex flex-col items-center gap-1">
                      <label className="relative inline-flex items-center cursor-pointer" aria-label={`Toggle ${supplier.displayName} supplier`}>
                        <input
                          type="checkbox"
                          checked={isEnabled}
                          onChange={() => onToggleSupplier(supplier.domain)}
                          disabled={isDisabled}
                          className="sr-only peer"
                          aria-label={`Enable or disable ${supplier.displayName} supplier`}
                        />
                        <div className="w-11 h-6 bg-arda-bg-tertiary peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-arda-accent rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-arda-border after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-arda-accent disabled:opacity-50 disabled:cursor-not-allowed" />
                      </label>
                      <span className="text-xs text-arda-text-muted">
                        {isEnabled ? 'Enabled' : 'Disabled'}
                      </span>
                    </div>

                    {/* Scan Button */}
                    <button
                      onClick={() => onScanSupplier(supplier.domain)}
                      disabled={isDisabled || !isEnabled}
                      className={`px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors ${
                        isEnabled
                          ? 'bg-arda-accent text-white hover:bg-arda-accent-hover disabled:opacity-50 disabled:cursor-not-allowed'
                          : 'bg-arda-bg-tertiary text-arda-text-muted cursor-not-allowed'
                      }`}
                    >
                      {isScanning ? (
                        <>
                          <Icons.Loader2 className="w-4 h-4 animate-spin" />
                          Scanning...
                        </>
                      ) : (
                        <>
                          <Icons.ScanLine className="w-4 h-4" />
                          Scan Now
                        </>
                      )}
                    </button>
                  </div>
                </div>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};

export default SupplierConfig;

```

### `src/components/TreeNode.tsx`

```tsx
import React, { memo, useCallback, useMemo } from 'react';
import { Icons } from './Icons';
import { VelocityBadge } from './VelocityBadge';
import { ReorderSparkline } from './ReorderSparkline';
import { 
  JourneyNode, 
  JourneyNodeType, 
  VelocityNodeData,
  LineItemNodeData,
  OrderNodeData,
  EmailNodeData,
  ItemVelocityProfile
} from '../types';

interface TreeNodeProps {
  node: JourneyNode;
  level: number;
  velocityProfiles?: Map<string, ItemVelocityProfile>;
  onNodeClick?: (node: JourneyNode) => void;
  onExpandToggle?: (nodeId: string, isExpanded: boolean) => void;
  expandedNodes?: Set<string>;
  focusedNodeId?: string | null;
  onFocusChange?: (nodeId: string) => void;
}

const ICONS_BY_TYPE: Record<JourneyNodeType, React.ComponentType<{ className?: string }>> = {
  email: Icons.Mail,
  order: Icons.Package,
  lineItem: Icons.Box,
  velocity: Icons.Activity,
};

const getNodeColors = (type: JourneyNodeType) => {
  switch (type) {
    case 'email':
      return {
        iconBg: 'bg-blue-500/20',
        iconColor: 'text-blue-400',
        border: 'border-blue-500/30',
      };
    case 'order':
      return {
        iconBg: 'bg-green-500/20',
        iconColor: 'text-green-400',
        border: 'border-green-500/30',
      };
    case 'lineItem':
      return {
        iconBg: 'bg-purple-500/20',
        iconColor: 'text-purple-400',
        border: 'border-purple-500/30',
      };
    case 'velocity':
      return {
        iconBg: 'bg-orange-500/20',
        iconColor: 'text-orange-400',
        border: 'border-orange-500/30',
      };
    default:
      return {
        iconBg: 'bg-arda-bg-tertiary',
        iconColor: 'text-arda-text-muted',
        border: 'border-arda-border',
      };
  }
};

const TreeNodeComponent: React.FC<TreeNodeProps> = ({
  node,
  level,
  velocityProfiles,
  onNodeClick,
  onExpandToggle,
  expandedNodes,
  focusedNodeId,
  onFocusChange,
}) => {
  const hasChildren = (node.children?.length ?? 0) > 0;
  const isExpanded = expandedNodes?.has(node.id) ?? (node.isExpanded ?? level < 2);
  const isFocused = focusedNodeId === node.id;
  const isNew = node.isNew ?? false;

  const Icon = ICONS_BY_TYPE[node.type] ?? Icons.FileText;
  const colors = useMemo(() => getNodeColors(node.type), [node.type]);

  const velocityProfile = useMemo(() => {
    if (node.type !== 'lineItem' || !velocityProfiles) return undefined;
    const data = node.data as LineItemNodeData | undefined;
    if (!data?.normalizedName) return undefined;
    return velocityProfiles.get(data.normalizedName);
  }, [node.type, node.data, velocityProfiles]);

  const handleToggle = useCallback(
    (e: React.MouseEvent) => {
      e.stopPropagation();
      onExpandToggle?.(node.id, !isExpanded);
    },
    [isExpanded, node.id, onExpandToggle],
  );

  const handleClick = useCallback(() => {
    onFocusChange?.(node.id);
    onNodeClick?.(node);
  }, [node, onFocusChange, onNodeClick]);

  const handleMouseEnter = useCallback(() => {
    onFocusChange?.(node.id);
  }, [node.id, onFocusChange]);

  return (
    <div className="select-none">
      {/* Node Row */}
      <div 
        data-node-id={node.id}
        className={`
          flex items-center gap-2 py-2 px-2 rounded-lg cursor-pointer
          transition-all duration-200 ease-in-out group
          hover:bg-arda-bg-tertiary hover:scale-[1.01]
          ${level === 0 ? 'bg-arda-bg-secondary' : ''}
          ${isFocused ? 'ring-2 ring-arda-accent ring-offset-2 ring-offset-white bg-arda-bg-tertiary' : ''}
          ${isNew ? 'animate-pulse ring-2 ring-green-400/50 ring-offset-2 ring-offset-white' : ''}
        `}
        style={{ paddingLeft: `${level * 20 + 8}px` }}
        onClick={handleClick}
        onMouseEnter={handleMouseEnter}
      >
        {/* Expand/Collapse Button */}
        <button
          onClick={handleToggle}
          aria-label={isExpanded ? 'Collapse' : 'Expand'}
          className={`
            w-5 h-5 flex items-center justify-center rounded relative
            transition-all duration-200 ease-in-out
            hover:bg-arda-bg-tertiary hover:scale-110
            ${hasChildren ? 'visible' : 'invisible'}
          `}
        >
          <Icons.ChevronRight 
            className={`
              w-4 h-4 text-arda-text-muted absolute
              transition-opacity duration-200 ease-in-out
              ${isExpanded ? 'opacity-0' : 'opacity-100'}
            `} 
          />
          <Icons.ChevronDown 
            className={`
              w-4 h-4 text-arda-text-muted absolute
              transition-opacity duration-200 ease-in-out
              ${isExpanded ? 'opacity-100' : 'opacity-0'}
            `} 
          />
        </button>
        
        {/* Node Icon */}
        <div className={`
          w-7 h-7 rounded-lg flex items-center justify-center
          transition-all duration-200 ease-in-out
          ${colors.iconBg}
          ${isNew ? 'animate-pulse shadow-lg shadow-green-400/30' : ''}
        `}>
          <Icon className={`w-4 h-4 transition-colors duration-200 ${colors.iconColor}`} />
        </div>
        
        {/* Node Content */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-sm font-medium text-arda-text-primary truncate">
              {node.label}
            </span>
            
            {/* Inline velocity badge for line items */}
            {node.type === 'lineItem' && velocityProfile && (
              <VelocityBadge
                dailyBurnRate={velocityProfile.dailyBurnRate}
                averageCadenceDays={velocityProfile.averageCadenceDays}
                orderCount={velocityProfile.orderCount}
                compact
              />
            )}
          </div>
          
          {node.subtitle && (
            <div className="text-xs text-arda-text-muted truncate">
              {node.subtitle}
            </div>
          )}
        </div>
        
        {/* Sparkline for line items */}
        {node.type === 'lineItem' && velocityProfile && velocityProfile.orders.length >= 2 && (
          <div className="hidden group-hover:block transition-opacity duration-200 ease-in-out opacity-0 group-hover:opacity-100">
            <ReorderSparkline
              orders={velocityProfile.orders.map(o => ({
                date: o.date,
                quantity: o.quantity,
              }))}
              width={80}
              height={20}
            />
          </div>
        )}
        
        {/* Order amount badge */}
        {node.type === 'order' && (node.data as OrderNodeData)?.totalAmount && (
          <span className="text-sm font-medium text-arda-accent">
            ${(node.data as OrderNodeData).totalAmount!.toFixed(2)}
          </span>
        )}
        
        {/* Date for emails */}
        {node.type === 'email' && (node.data as EmailNodeData)?.date && (
          <span className="text-xs text-arda-text-muted">
            {new Date((node.data as EmailNodeData).date).toLocaleDateString()}
          </span>
        )}
      </div>
      
      {/* Velocity Detail Node (special rendering) */}
      {node.type === 'velocity' && (
        <div 
          className="ml-4 py-2 px-3 transition-all duration-200 ease-in-out"
          style={{ paddingLeft: `${level * 20 + 28}px` }}
        >
          <VelocityBadge
            dailyBurnRate={(node.data as VelocityNodeData).dailyBurnRate}
            averageCadenceDays={(node.data as VelocityNodeData).averageCadenceDays}
            orderCount={(node.data as VelocityNodeData).orderCount}
            nextPredictedOrder={(node.data as VelocityNodeData).nextPredictedOrder}
          />
        </div>
      )}
      
      {/* Children */}
      {hasChildren && (
        <div 
          className={`
            relative overflow-hidden transition-all duration-300 ease-in-out
            ${level > 0 ? 'ml-3' : ''}
            ${isExpanded ? 'max-h-[10000px] opacity-100' : 'max-h-0 opacity-0'}
          `}
        >
          {/* Connecting line */}
          <div 
            className="absolute left-0 top-0 bottom-0 w-px bg-arda-border transition-opacity duration-300"
            style={{ left: `${level * 20 + 18}px` }}
          />
          
          <div className={`
            transition-transform duration-300 ease-in-out
            ${isExpanded ? 'translate-y-0' : '-translate-y-2'}
          `}>
            {node.children!.map((child) => (
              <TreeNode
                key={child.id}
                node={child}
                level={level + 1}
                velocityProfiles={velocityProfiles}
                onNodeClick={onNodeClick}
                onExpandToggle={onExpandToggle}
                expandedNodes={expandedNodes}
                focusedNodeId={focusedNodeId}
                onFocusChange={onFocusChange}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

function getIsExpanded(
  node: JourneyNode,
  expandedNodes?: Set<string>,
  level = 0,
): boolean {
  return expandedNodes?.has(node.id) ?? (node.isExpanded ?? level < 2);
}

function areTreeNodePropsEqual(prev: TreeNodeProps, next: TreeNodeProps): boolean {
  if (prev.node.id !== next.node.id) return false;
  if (prev.level !== next.level) return false;
  if (prev.node.label !== next.node.label) return false;
  if (prev.node.subtitle !== next.node.subtitle) return false;
  if (prev.node.type !== next.node.type) return false;
  if (prev.node.isNew !== next.node.isNew) return false;
  if (prev.node.data !== next.node.data) return false;
  if (getIsExpanded(prev.node, prev.expandedNodes, prev.level) !== getIsExpanded(next.node, next.expandedNodes, next.level)) {
    return false;
  }
  if (prev.focusedNodeId !== next.focusedNodeId) return false;
  if (prev.velocityProfiles !== next.velocityProfiles) return false;
  if (prev.onNodeClick !== next.onNodeClick) return false;
  if (prev.onExpandToggle !== next.onExpandToggle) return false;
  if (prev.onFocusChange !== next.onFocusChange) return false;
  return true;
}

const memoizedTreeNode = memo(TreeNodeComponent, areTreeNodePropsEqual);
export const TreeNode = memoizedTreeNode;
export default TreeNode;

```

### `src/components/VelocityBadge.tsx`

```tsx
import React from 'react';
import { Icons } from './Icons';

interface VelocityBadgeProps {
  dailyBurnRate: number;
  averageCadenceDays: number;
  orderCount: number;
  nextPredictedOrder?: string;
  compact?: boolean;
}

/**
 * Get velocity classification based on daily burn rate
 */
const getVelocityClass = (dailyBurnRate: number): {
  label: string;
  color: string;
  bgColor: string;
  borderColor: string;
} => {
  if (dailyBurnRate >= 10) {
    return {
      label: 'Fast',
      color: 'text-arda-accent',
      bgColor: 'bg-orange-100',
      borderColor: 'border-orange-200',
    };
  } else if (dailyBurnRate >= 3) {
    return {
      label: 'Medium',
      color: 'text-arda-accent',
      bgColor: 'bg-orange-100',
      borderColor: 'border-orange-200',
    };
  } else if (dailyBurnRate >= 1) {
    return {
      label: 'Slow',
      color: 'text-arda-text-secondary',
      bgColor: 'bg-arda-bg-tertiary',
      borderColor: 'border-arda-border',
    };
  } else {
    return {
      label: 'Rare',
      color: 'text-arda-text-muted',
      bgColor: 'bg-arda-bg-tertiary',
      borderColor: 'border-arda-border',
    };
  }
};

export const VelocityBadge: React.FC<VelocityBadgeProps> = ({
  dailyBurnRate,
  averageCadenceDays,
  orderCount,
  nextPredictedOrder,
  compact = false,
}) => {
  const velocityClass = getVelocityClass(dailyBurnRate);
  
  if (compact) {
    return (
      <span 
        className={`inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs font-medium ${velocityClass.bgColor} ${velocityClass.color} border ${velocityClass.borderColor}`}
        title={`${dailyBurnRate.toFixed(1)}/day | Cadence: ${Math.round(averageCadenceDays)} days | ${orderCount} orders`}
      >
        <Icons.Zap className="w-3 h-3" />
        {dailyBurnRate.toFixed(1)}/day
      </span>
    );
  }

  return (
    <div className={`flex flex-wrap items-center gap-3 px-3 py-2 rounded-lg ${velocityClass.bgColor} border ${velocityClass.borderColor}`}>
      {/* Velocity Rate */}
      <div className="flex items-center gap-1.5">
        <Icons.Zap className={`w-4 h-4 ${velocityClass.color}`} />
        <span className={`text-sm font-semibold ${velocityClass.color}`}>
          {dailyBurnRate.toFixed(1)}/day
        </span>
        <span className="text-xs text-arda-text-muted">
          ({velocityClass.label})
        </span>
      </div>
      
      {/* Divider */}
      <div className="w-px h-4 bg-arda-border" />
      
      {/* Cadence */}
      <div className="flex items-center gap-1.5">
        <Icons.Calendar className="w-4 h-4 text-arda-text-muted" />
        <span className="text-sm text-arda-text-secondary">
          {Math.round(averageCadenceDays)} days
        </span>
      </div>
      
      {/* Order Count */}
      <div className="flex items-center gap-1.5">
        <Icons.Package className="w-4 h-4 text-arda-text-muted" />
        <span className="text-sm text-arda-text-secondary">
          {orderCount} order{orderCount !== 1 ? 's' : ''}
        </span>
      </div>
      
      {/* Next Predicted Order */}
      {nextPredictedOrder && (
        <>
          <div className="w-px h-4 bg-arda-border" />
          <div className="flex items-center gap-1.5">
            <Icons.Clock className="w-4 h-4 text-arda-text-muted" />
            <span className="text-sm text-arda-text-secondary">
              Next: {new Date(nextPredictedOrder).toLocaleDateString()}
            </span>
          </div>
        </>
      )}
    </div>
  );
};

export default VelocityBadge;

```

### `src/components/__tests__/ReorderSparkline.test.tsx`

```tsx
import { describe, expect, it, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import { ReorderSparkline } from '../ReorderSparkline';

vi.mock('recharts', async () => {
  const React = await import('react');
  type RCProps = { children?: React.ReactNode | ((args: { width?: number | string; height?: number | string }) => React.ReactNode); width?: number | string; height?: number | string };
  return {
    ResponsiveContainer: ({ children, width, height }: RCProps) => (
      <div data-testid="responsive" style={{ width, height }}>
        {typeof children === 'function' ? children({ width, height }) : children}
      </div>
    ),
    LineChart: ({ children }: { children?: React.ReactNode }) => <div data-testid="line-chart">{children}</div>,
    Line: (props: Record<string, unknown>) => <div data-testid="line" data-props={JSON.stringify(props)} />,
    Tooltip: (props: { formatter?: (value: unknown) => unknown; labelFormatter?: (label: unknown, payload?: unknown) => unknown }) => {
      props.formatter?.(5);
      props.labelFormatter?.('label', [{ payload: { displayDate: 'Jan 2' } }]);
      props.labelFormatter?.('label', undefined);
      return <div data-testid="tooltip" />;
    },
  };
});

describe('ReorderSparkline', () => {
  it('shows placeholder when fewer than two orders', () => {
    render(<ReorderSparkline orders={[{ date: '2024-01-01', quantity: 1 }]} width={80} height={20} />);
    expect(screen.getByText('—')).toBeInTheDocument();
  });

  it('renders chart data when enough orders and executes tooltip formatters', () => {
    render(
      <ReorderSparkline
        orders={[
          { date: '2024-01-01', quantity: 2 },
          { date: '2024-02-01', quantity: 3 },
        ]}
      />,
    );

    expect(screen.getByTestId('responsive')).toBeInTheDocument();
    expect(screen.getByTestId('line-chart')).toBeInTheDocument();
    expect(screen.getByTestId('line')).toBeInTheDocument();
    expect(screen.getByTestId('tooltip')).toBeInTheDocument();
  });
});

```

### `src/components/__tests__/TreeNode.test.tsx`

```tsx
import { describe, expect, it, vi } from 'vitest';
import { fireEvent, render, screen } from '@testing-library/react';
import { TreeNode } from '../TreeNode';
import { JourneyNode, ItemVelocityProfile } from '../../types';

vi.mock('../ReorderSparkline', () => ({
  ReorderSparkline: ({ orders }: { orders: Array<{ date: string; quantity: number }> }) => (
    <div data-testid="sparkline" data-count={orders.length}>
      sparkline
    </div>
  ),
}));

describe('TreeNode', () => {
  const baseNode: JourneyNode = {
    id: 'line-1',
    type: 'lineItem',
    label: 'Test Line Item',
    subtitle: 'Test Subtitle',
    children: [],
    data: {
      lineItemId: 'line-1',
      orderId: 'order-1',
      emailId: 'email-1',
      name: 'test',
      normalizedName: 'test',
      quantity: 2,
      unit: 'EA',
    },
  };

  const velocityProfile: ItemVelocityProfile = {
    normalizedName: 'test',
    displayName: 'Test Line Item',
    supplier: 'Test Supplier',
    orders: [
      { orderId: 'order-1', emailId: 'email-1', date: '2024-01-01', quantity: 1 },
      { orderId: 'order-2', emailId: 'email-2', date: '2024-02-01', quantity: 1 },
    ],
    totalQuantityOrdered: 2,
    orderCount: 2,
    averageCadenceDays: 30,
    dailyBurnRate: 1.5,
    firstOrderDate: '2024-01-01',
    lastOrderDate: '2024-02-01',
    nextPredictedOrder: '2024-03-15',
    recommendedMin: 1,
    recommendedOrderQty: 2,
  };

  it('renders the label with velocity data', () => {
    render(
      <TreeNode
        node={baseNode}
        level={0}
        velocityProfiles={new Map([['test', velocityProfile]])}
        expandedNodes={new Set()}
        focusedNodeId={null}
        onNodeClick={vi.fn()}
        onExpandToggle={vi.fn()}
        onFocusChange={vi.fn()}
      />,
    );

    expect(screen.getByText('Test Line Item')).toBeInTheDocument();
    expect(screen.getByText(/1\.5\/day/)).toBeInTheDocument();
  });

  it('calls expand toggle handler when the chevron button is clicked', async () => {
    const toggle = vi.fn();

    render(
      <TreeNode
        node={baseNode}
        level={0}
        velocityProfiles={new Map([['test', velocityProfile]])}
        expandedNodes={new Set()}
        focusedNodeId={null}
        onNodeClick={vi.fn()}
        onExpandToggle={toggle}
        onFocusChange={vi.fn()}
      />,
    );

    const button = screen.getByRole('button', { name: /expand/i });
    await button.click();
    expect(toggle).toHaveBeenCalled();
  });

  it('fires focus change and node click when row is clicked', () => {
    const handleClick = vi.fn();
    const handleFocus = vi.fn();

    render(
      <TreeNode
        node={baseNode}
        level={1}
        velocityProfiles={new Map([['test', velocityProfile]])}
        expandedNodes={new Set()}
        focusedNodeId={null}
        onNodeClick={handleClick}
        onExpandToggle={vi.fn()}
        onFocusChange={handleFocus}
      />,
    );

    fireEvent.click(screen.getByText('Test Line Item'));
    expect(handleClick).toHaveBeenCalledWith(expect.objectContaining({ id: 'line-1' }));
    expect(handleFocus).toHaveBeenCalledWith('line-1');
  });

  it('renders children when expanded by default', () => {
    const child: JourneyNode = {
      id: 'child-1',
      type: 'velocity',
      label: 'Velocity Node',
      children: [],
      data: {
        normalizedName: 'test-item',
        dailyBurnRate: 2,
        averageCadenceDays: 15,
        orderCount: 3,
      },
    };

    render(
      <TreeNode
        node={{ ...baseNode, children: [child] }}
        level={0}
        velocityProfiles={new Map([['test', velocityProfile]])}
        expandedNodes={undefined}
        focusedNodeId={null}
        onNodeClick={vi.fn()}
        onExpandToggle={vi.fn()}
        onFocusChange={vi.fn()}
      />,
    );

    expect(screen.getByText('Velocity Node')).toBeInTheDocument();
    expect(screen.getByTestId('sparkline')).toHaveAttribute('data-count', '2');
  });

  it('renders order and email specific details', () => {
    render(
      <>
        <TreeNode
          node={{
            id: 'order-1',
            type: 'order',
            label: 'Order Label',
            subtitle: 'order subtitle',
            children: [],
            data: { orderId: 'o1', emailId: 'e1', supplier: 'Test', orderDate: '2024-01-01', itemCount: 1, confidence: 0.9, totalAmount: 123.45 },
          }}
          level={1}
          expandedNodes={new Set(['order-1'])}
        />
        <TreeNode
          node={{
            id: 'email-1',
            type: 'email',
            label: 'Email Label',
            subtitle: 'email subtitle',
            children: [],
            data: { emailId: 'e1', sender: 'test@test.com', subject: 'Test', date: '2024-02-10' },
          }}
          level={0}
          expandedNodes={new Set(['email-1'])}
        />
        <TreeNode
          node={{
            id: 'vel-1',
            type: 'velocity',
            label: 'Velocity',
            subtitle: 'velocity subtitle',
            children: [],
            data: { normalizedName: 'test', dailyBurnRate: 1.2, averageCadenceDays: 10, orderCount: 2, nextPredictedOrder: '2024-04-01' },
          }}
          level={2}
          expandedNodes={new Set(['vel-1'])}
        />
      </>,
    );

    expect(screen.getByText('$123.45')).toBeInTheDocument();
    const formattedDate = new Date('2024-02-10').toLocaleDateString();
    expect(screen.getByText(formattedDate)).toBeInTheDocument();
    expect(screen.getAllByText(/orders?/i).length).toBeGreaterThanOrEqual(1);
  });

  it('re-renders with memo comparator when props change', () => {
    const { rerender } = render(
      <TreeNode
        node={baseNode}
        level={0}
        velocityProfiles={new Map([['test', velocityProfile]])}
        expandedNodes={new Set()}
        focusedNodeId={null}
        onNodeClick={vi.fn()}
        onExpandToggle={vi.fn()}
        onFocusChange={vi.fn()}
      />,
    );

    // same props should hit comparator return true path
    rerender(
      <TreeNode
        node={baseNode}
        level={0}
        velocityProfiles={new Map([['test', velocityProfile]])}
        expandedNodes={new Set()}
        focusedNodeId={null}
        onNodeClick={vi.fn()}
        onExpandToggle={vi.fn()}
        onFocusChange={vi.fn()}
      />,
    );

    // changed focus should trigger comparator to return false and re-render
    rerender(
      <TreeNode
        node={baseNode}
        level={0}
        velocityProfiles={new Map([['test', velocityProfile]])}
        expandedNodes={new Set()}
        focusedNodeId="line-1"
        onNodeClick={vi.fn()}
        onExpandToggle={vi.fn()}
        onFocusChange={vi.fn()}
      />,
    );

    // mouse enter path for handleMouseEnter
    const row = screen.getByTestId('sparkline').closest('[data-node-id="line-1"]') || screen.getByText('Test Line Item').closest('[data-node-id="line-1"]');
    if (row) {
      fireEvent.mouseEnter(row);
    }
  });

  it('falls back to default styling for unknown node types', () => {
    render(
      <TreeNode
        node={{
          id: 'unknown-1',
          // @ts-expect-error testing default branch
          type: 'unknown',
          label: 'Unknown Node',
          children: [],
        }}
        level={0}
      />,
    );

    expect(screen.getByText('Unknown Node')).toBeInTheDocument();
  });

  it('exposes memo comparator that reacts to expanded state and handlers', () => {
    const comparator = (TreeNode as unknown as { compare: (prev: unknown, next: unknown) => boolean }).compare;
    const sharedNode = { ...baseNode };
    const sharedVelocity = new Map([['test', velocityProfile]]);
    const baseProps = {
      node: sharedNode,
      level: 0,
      velocityProfiles: sharedVelocity,
      expandedNodes: new Set<string>(),
      focusedNodeId: null,
      onNodeClick: vi.fn(),
      onExpandToggle: vi.fn(),
      onFocusChange: vi.fn(),
    };

    // identical props should be equal
    expect(comparator(baseProps, { ...baseProps })).toBe(true);

    // different expansion state should trigger a re-render decision
    const expandedProps = { ...baseProps, expandedNodes: new Set(['line-1']) };
    expect(comparator(baseProps, expandedProps)).toBe(false);

    // different handler identity should trigger re-render
    const handlerChanged = { ...baseProps, onNodeClick: vi.fn() };
    expect(comparator(baseProps, handlerChanged)).toBe(false);
  });

  it('renders line item even when velocity data is missing', () => {
    render(
      <TreeNode
        node={{
          id: 'line-no-velocity',
          type: 'lineItem',
          label: 'No Velocity',
          // omit children to exercise hasChildren optional path
          data: { name: 'No Velocity Item', quantity: 1, unit: 'ea' },
        } as JourneyNode}
        level={0}
        velocityProfiles={new Map()}
      />,
    );

    expect(screen.getByText('No Velocity')).toBeInTheDocument();
  });

  it('shows new-node styling when isNew is true', () => {
    const { container } = render(
      <TreeNode
        node={{
          ...baseNode,
          id: 'line-new',
          label: 'Brand New',
          isNew: true,
          children: [],
        }}
        level={0}
        velocityProfiles={new Map([['test', velocityProfile]])}
      />,
    );

    expect(screen.getByText('Brand New')).toBeInTheDocument();
    expect(container.querySelector('[data-node-id="line-new"]')?.className).toMatch(/animate-pulse/);
  });

  it('renders collapsed child container when not expanded at deeper levels', () => {
    render(
      <TreeNode
        node={{
          ...baseNode,
          id: 'parent-collapsed',
          children: [
            {
              id: 'nested',
              type: 'lineItem',
              label: 'Nested Child',
              children: [],
              data: { lineItemId: 'li1', orderId: 'o1', emailId: 'e1', name: 'n', quantity: 1, unit: 'ea', normalizedName: 'n' },
            },
          ],
        }}
        level={2}
        expandedNodes={new Set<string>()}
        velocityProfiles={new Map()}
      />,
    );

    expect(screen.getByText('Nested Child')).toBeInTheDocument();
  });

  it('omits order amount badge when total is missing', () => {
    render(
      <TreeNode
        node={{
          id: 'order-no-amount',
          type: 'order',
          label: 'Order Missing Amount',
          subtitle: 'no amount',
          children: [],
          data: { orderId: 'o1', emailId: 'e1', supplier: 'Test', orderDate: '2024-01-01', itemCount: 1, confidence: 0.9 },
        }}
        level={0}
        expandedNodes={new Set()}
      />,
    );

    expect(screen.getByText('Order Missing Amount')).toBeInTheDocument();
    expect(screen.queryByText(/\$/)).not.toBeInTheDocument();
  });

  it('handles order total of zero without rendering amount badge', () => {
    render(
      <TreeNode
        node={{
          id: 'order-zero',
          type: 'order',
          label: 'Zero Amount',
          subtitle: 'zero total',
          children: [],
          data: { orderId: 'o1', emailId: 'e1', supplier: 'Test', orderDate: '2024-01-01', itemCount: 1, confidence: 0.9, totalAmount: 0 },
        }}
        level={0}
        expandedNodes={new Set()}
      />,
    );

    expect(screen.getByText('Zero Amount')).toBeInTheDocument();
    expect(screen.queryByText('$0.00')).not.toBeInTheDocument();
  });

  it('covers memo comparator branches for mismatched props', () => {
    const comparator = (TreeNode as unknown as { compare: (prev: unknown, next: unknown) => boolean }).compare;
    const makeProps = (overrides: Record<string, unknown> = {}) => {
      const nodeOverride = overrides.node ?? {};
      return {
        node: { ...baseNode, ...nodeOverride },
        level: overrides.level ?? 0,
        velocityProfiles: overrides.velocityProfiles ?? new Map([['test', velocityProfile]]),
        expandedNodes: Object.prototype.hasOwnProperty.call(overrides, 'expandedNodes')
          ? overrides.expandedNodes
          : new Set<string>(),
        focusedNodeId: overrides.focusedNodeId ?? null,
        onNodeClick: overrides.onNodeClick ?? baseClick,
        onExpandToggle: overrides.onExpandToggle ?? baseExpand,
        onFocusChange: overrides.onFocusChange ?? baseFocus,
      };
    };

    const baseClick = vi.fn();
    const baseExpand = vi.fn();
    const baseFocus = vi.fn();

    const baseProps = makeProps();
    expect(comparator(baseProps, baseProps)).toBe(true);
    expect(comparator(baseProps, makeProps({ node: { ...baseProps.node, id: 'other' } }))).toBe(false);
    expect(comparator(baseProps, makeProps({ level: 2 }))).toBe(false);
    expect(comparator(baseProps, makeProps({ node: { ...baseProps.node, label: 'Changed' } }))).toBe(false);
    expect(comparator(baseProps, makeProps({ node: { ...baseProps.node, subtitle: 'Changed subtitle' } }))).toBe(false);
    expect(comparator(baseProps, makeProps({ node: { ...baseProps.node, type: 'order' as JourneyNode['type'] } }))).toBe(false);
    expect(comparator(baseProps, makeProps({ node: { ...baseProps.node, isNew: true } }))).toBe(false);
    expect(comparator(baseProps, makeProps({ node: { ...baseProps.node, data: { ...baseProps.node.data } } }))).toBe(false);
    expect(comparator(baseProps, makeProps({ expandedNodes: undefined }))).toBe(false);
    expect(comparator(baseProps, makeProps({ expandedNodes: new Set(['line-1']) }))).toBe(false);
    expect(comparator(baseProps, makeProps({ focusedNodeId: 'line-1' }))).toBe(false);
    expect(comparator(baseProps, makeProps({ velocityProfiles: new Map() }))).toBe(false);
    expect(comparator(baseProps, makeProps({ onNodeClick: vi.fn(), onExpandToggle: baseExpand, onFocusChange: baseFocus }))).toBe(false);
    expect(comparator(baseProps, { ...baseProps, onExpandToggle: vi.fn() })).toBe(false);
    expect(comparator(baseProps, { ...baseProps, onFocusChange: vi.fn() })).toBe(false);
  });
});

```

### `src/components/__tests__/VelocityBadge.test.tsx`

```tsx
import React from 'react';
import { describe, expect, it } from 'vitest';
import { render, screen } from '@testing-library/react';
import { VelocityBadge } from '../VelocityBadge';

describe('VelocityBadge', () => {
  it('renders compact badge with correct rate', () => {
    render(
      <VelocityBadge
        dailyBurnRate={5}
        averageCadenceDays={12}
        orderCount={3}
        compact
      />,
    );

    expect(screen.getByText(/5\.0\/day/)).toBeInTheDocument();
    expect(screen.getByTitle(/12 days/)).toBeInTheDocument();
  });

  it('renders detailed badge with next predicted order and pluralization', () => {
    render(
      <VelocityBadge
        dailyBurnRate={0.2}
        averageCadenceDays={45}
        orderCount={1}
        nextPredictedOrder="2024-08-15"
      />,
    );

    expect(screen.getByText(/0\.2\/day/)).toBeInTheDocument();
    expect(screen.getByText(/45 days/)).toBeInTheDocument();
    expect(screen.getByText(/1 order/)).toBeInTheDocument();
    expect(screen.getByText(/Next:/)).toBeInTheDocument();
  });

  it('shows correct classification labels across ranges', () => {
    render(
      <>
        <VelocityBadge dailyBurnRate={12} averageCadenceDays={5} orderCount={10} />
        <VelocityBadge dailyBurnRate={3} averageCadenceDays={5} orderCount={10} />
        <VelocityBadge dailyBurnRate={1} averageCadenceDays={5} orderCount={10} />
        <VelocityBadge dailyBurnRate={0} averageCadenceDays={5} orderCount={10} />
      </>,
    );

    expect(screen.getAllByText('(Fast)')).toHaveLength(1);
    expect(screen.getAllByText('(Medium)')).toHaveLength(1);
    expect(screen.getAllByText('(Slow)')).toHaveLength(1);
    expect(screen.getAllByText('(Rare)')).toHaveLength(1);
  });
});

```

### `src/constants.ts`

```typescript
export const APP_NAME = "Arda";
export const APP_DESCRIPTION = "Order Intelligence";
export const APP_TAGLINE = "The easiest way to never run out";

export const NAV_ITEMS = [
  { id: 'dashboard', label: 'Dashboard', icon: 'LayoutDashboard' },
  { id: 'journey', label: 'Order Journey', icon: 'GitBranch' },
  { id: 'inventory', label: 'Inventory Cards', icon: 'Package' },
  { id: 'analysis', label: 'Cadence Analysis', icon: 'BarChart3' },
  { id: 'compose', label: 'Send Email', icon: 'Send' },
  { id: 'setup', label: 'Supplier Setup', icon: 'Settings' },
];

export const MOCK_DELAY_MS = 800;

```

### `src/hooks/useAutoIngestion.ts`

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { jobsApi } from '../services/api';
import { ExtractedOrder, GoogleUserProfile } from '../types';

interface EmailPreview {
  id: string;
  subject: string;
  sender: string;
  snippet?: string;
}

interface IngestionProgress {
  total: number;
  processed: number;
  success: number;
  failed: number;
  currentTask: string;
}

interface UseAutoIngestionResult {
  isIngesting: boolean;
  progress: IngestionProgress;
  currentEmail: EmailPreview | null;
  orders: ExtractedOrder[];
  logs: string[];
  error: string | null;
  startIngestion: () => Promise<void>;
  resetAndRestart: () => Promise<void>;
  jobStatus: 'pending' | 'running' | 'completed' | 'failed' | null;
}

export function useAutoIngestion(
  userProfile: GoogleUserProfile | null,
  onOrdersProcessed: (orders: ExtractedOrder[]) => void
): UseAutoIngestionResult {
  const [isIngesting, setIsIngesting] = useState(false);
  const [currentJobId, setCurrentJobId] = useState<string | null>(null);
  const [jobStatus, setJobStatus] = useState<'pending' | 'running' | 'completed' | 'failed' | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  const [progress, setProgress] = useState<IngestionProgress>({
    total: 0,
    processed: 0,
    success: 0,
    failed: 0,
    currentTask: 'Waiting...',
  });
  
  const [currentEmail, setCurrentEmail] = useState<EmailPreview | null>(null);
  const [orders, setOrders] = useState<ExtractedOrder[]>([]);
  const [logs, setLogs] = useState<string[]>([]);
  
  const pollingRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const hasStartedRef = useRef(false);

  // Poll for job status
  const pollJobStatus = useCallback(async () => {
    if (!currentJobId) return;
    
    try {
      const status = await jobsApi.getStatus(currentJobId);
      
      if (!status.hasJob) {
        setIsIngesting(false);
        setJobStatus(null);
        return;
      }
      
      // Update progress
      if (status.progress) {
        setProgress({
          total: status.progress.total,
          processed: status.progress.processed,
          success: status.progress.success,
          failed: status.progress.failed,
          currentTask: status.progress.currentTask,
        });
      }
      
      if (status.currentEmail) {
        setCurrentEmail(status.currentEmail);
      }
      
      if (status.orders) {
        const convertedOrders: ExtractedOrder[] = status.orders.map((o) => ({
          id: o.id,
          originalEmailId: o.id,
          supplier: o.supplier,
          orderDate: o.orderDate,
          totalAmount: o.totalAmount,
          items: o.items,
          confidence: o.confidence,
        }));
        setOrders(convertedOrders);
        onOrdersProcessed(convertedOrders);
      }
      
      if (status.logs) {
        setLogs(status.logs);
      }
      
      setJobStatus(status.status || null);
      
      // Stop polling if complete or failed
      if (status.status === 'completed' || status.status === 'failed') {
        setIsIngesting(false);
        setCurrentEmail(null);
        if (pollingRef.current) {
          clearInterval(pollingRef.current);
          pollingRef.current = null;
        }
        
        if (status.status === 'failed' && status.error) {
          setError(status.error);
        }
      }
    } catch (err) {
      console.error('Polling error:', err);
    }
  }, [currentJobId, onOrdersProcessed]);

  // Start/stop polling
  useEffect(() => {
    if (isIngesting && currentJobId) {
      pollingRef.current = setInterval(pollJobStatus, 1000);
      setTimeout(() => {
        void pollJobStatus(); // Immediate first poll
      }, 0);
    }
    
    return () => {
      if (pollingRef.current) {
        clearInterval(pollingRef.current);
        pollingRef.current = null;
      }
    };
  }, [isIngesting, currentJobId, pollJobStatus]);

  // Start ingestion
  const startIngestion = useCallback(async () => {
    if (isIngesting || !userProfile) return;
    
    setIsIngesting(true);
    setError(null);
    setProgress({ total: 0, processed: 0, success: 0, failed: 0, currentTask: 'Starting...' });
    setLogs(['[' + new Date().toLocaleTimeString() + '] Starting email analysis...']);
    
    try {
      const result = await jobsApi.startJob();
      if (result.jobId) {
        setCurrentJobId(result.jobId);
        setJobStatus('running');
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to start ingestion';
      setError(message);
      setIsIngesting(false);
    }
  }, [isIngesting, userProfile]);

  // Reset all state and restart ingestion from scratch
  const resetAndRestart = useCallback(async () => {
    // Stop any current polling
    if (pollingRef.current) {
      clearInterval(pollingRef.current);
      pollingRef.current = null;
    }
    
    // Clear all state
    setIsIngesting(false);
    setCurrentJobId(null);
    setJobStatus(null);
    setError(null);
    setProgress({ total: 0, processed: 0, success: 0, failed: 0, currentTask: 'Waiting...' });
    setCurrentEmail(null);
    setOrders([]);
    setLogs(['[' + new Date().toLocaleTimeString() + '] Reset complete. Starting fresh...']);
    
    // Notify parent to clear orders
    onOrdersProcessed([]);
    
    // Small delay then start fresh
    await new Promise(resolve => setTimeout(resolve, 500));
    
    if (userProfile) {
      setIsIngesting(true);
      setProgress({ total: 0, processed: 0, success: 0, failed: 0, currentTask: 'Starting...' });
      setLogs(prev => [...prev, '[' + new Date().toLocaleTimeString() + '] Starting email analysis...']);
      
      try {
        const result = await jobsApi.startJob();
        if (result.jobId) {
          setCurrentJobId(result.jobId);
          setJobStatus('running');
        }
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to start ingestion';
        setError(message);
        setIsIngesting(false);
      }
    }
  }, [userProfile, onOrdersProcessed]);

  // Auto-start on first auth
  useEffect(() => {
    if (userProfile && !hasStartedRef.current) {
      hasStartedRef.current = true;
      
      // Check for existing job first
      const checkAndStart = async () => {
        try {
          const status = await jobsApi.getStatus();
          
          if (status.hasJob && status.jobId) {
            // Resume existing job
            setCurrentJobId(status.jobId);
            setIsIngesting(status.status === 'running' || status.status === 'pending');
            setJobStatus(status.status || null);
            
            // If completed, load the orders
                if (status.status === 'completed' && status.orders) {
                  const convertedOrders: ExtractedOrder[] = status.orders.map((o) => ({
                    id: o.id,
                    originalEmailId: o.id,
                    supplier: o.supplier,
                    orderDate: o.orderDate,
                    totalAmount: o.totalAmount,
                    items: o.items,
                    confidence: o.confidence,
                  }));
                  setOrders(convertedOrders);
                  onOrdersProcessed(convertedOrders);
                }
          } else {
            // No existing job, start a new one
            await startIngestion();
          }
        } catch {
          // No existing job, start fresh
          await startIngestion();
        }
      };
      
      checkAndStart();
    }
  }, [userProfile, startIngestion, onOrdersProcessed]);

  return {
    isIngesting,
    progress,
    currentEmail,
    orders,
    logs,
    error,
    startIngestion,
    resetAndRestart,
    jobStatus,
  };
}

```

### `src/hooks/useSyncToArda.ts`

```typescript
import { useState, useCallback } from 'react';
import { API_BASE_URL, ardaApi, ArdaTenantResolutionDetails, isApiRequestError } from '../services/api';
import { exportItemsToCSV } from '../utils/exportUtils';
import type { MasterListItem, RowSyncState, SyncResult } from '../components/ItemsTable/types';

export function useSyncToArda(items: MasterListItem[]) {
  const [syncStateById, setSyncStateById] = useState<Record<string, RowSyncState>>({});
  const [isBulkSyncing, setIsBulkSyncing] = useState<boolean>(false);

  const uploadImage = useCallback(async (imageData: string): Promise<string | null> => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/photo/upload`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ imageData }),
      });
      if (!response.ok) return null;
      const data = await response.json();
      return data.imageUrl ?? null;
    } catch {
      return null;
    }
  }, []);

  const resolveTenantForSync = useCallback(async (details?: ArdaTenantResolutionDetails): Promise<boolean> => {
    if (!details?.canCreateTenant) return false;
    try {
      const resolution = await ardaApi.resolveTenant('create_new');
      return resolution.success;
    } catch {
      return false;
    }
  }, []);

  const exportMasterListItemsFallback = useCallback((itemsToExport: MasterListItem[]) => {
    exportItemsToCSV(
      itemsToExport.map((item) => ({
        source: item.source,
        name: item.name,
        supplier: item.supplier,
        description: item.description,
        location: item.location,
        orderMethod: item.orderMethod,
        minQty: item.minQty,
        orderQty: item.orderQty,
        unitPrice: item.unitPrice,
        sku: item.sku,
        barcode: item.barcode,
        asin: item.asin,
        productUrl: item.productUrl,
        imageUrl: item.imageUrl,
        color: item.color,
      })),
      'master-list-tenant-unresolved'
    );
  }, []);

  const ensureTenantForSync = useCallback(async (itemsToExportOnFailure: MasterListItem[]): Promise<boolean> => {
    try {
      const status = await ardaApi.getTenantStatus();
      if (status.resolved) return true;
      const resolved = await resolveTenantForSync(status.details);
      if (resolved) return true;
      exportMasterListItemsFallback(itemsToExportOnFailure);
      return false;
    } catch (error) {
      if (isApiRequestError(error) && error.code === 'TENANT_REQUIRED') {
        const resolved = await resolveTenantForSync(error.details as ArdaTenantResolutionDetails | undefined);
        if (resolved) return true;
      }
      exportMasterListItemsFallback(itemsToExportOnFailure);
      return false;
    }
  }, [exportMasterListItemsFallback, resolveTenantForSync]);

  const syncItemToArda = useCallback(async (item: MasterListItem): Promise<SyncResult> => {
    try {
      let imageUrl = item.imageUrl;
      if (imageUrl?.startsWith('data:image/')) {
        const uploadedUrl = await uploadImage(imageUrl);
        imageUrl = uploadedUrl || undefined;
      }

      const payload = {
        name: item.name,
        primarySupplier: item.supplier || 'Unknown Supplier',
        orderMechanism: item.orderMethod,
        sku: item.sku,
        barcode: item.barcode,
        location: item.location,
        minQty: item.minQty || 1,
        orderQty: item.orderQty || item.minQty || 1,
        unitPrice: item.unitPrice,
        imageUrl,
        primarySupplierLink: item.productUrl,
        description: item.description,
      };

      const attemptSync = async (): Promise<{
        data?: { success: boolean; record?: { rId?: string } };
        error?: unknown;
      }> => {
        try {
          return { data: await ardaApi.createItem(payload) };
        } catch (error) {
          return { error };
        }
      };

      let attempt = await attemptSync();

      if (attempt.error && isApiRequestError(attempt.error) && attempt.error.code === 'TENANT_REQUIRED') {
        const resolved = await resolveTenantForSync(attempt.error.details as ArdaTenantResolutionDetails | undefined);
        if (resolved) {
          attempt = await attemptSync();
        } else {
          const tenantDetails = attempt.error.details as ArdaTenantResolutionDetails | undefined;
          const unresolvedMessage = tenantDetails?.autoProvisionError
            || tenantDetails?.message
            || 'Tenant could not be auto-provisioned.';
          exportMasterListItemsFallback([item]);
          return {
            success: false,
            error: `${unresolvedMessage} Exported item to CSV.`,
          };
        }
      }

      if (attempt.error) {
        if (isApiRequestError(attempt.error)) {
          const resolvedErrorMessage = attempt.error.message || '';
          if (
            attempt.error.status === 409 ||
            resolvedErrorMessage.toLowerCase().includes('already exists')
          ) {
            return { success: true, ardaEntityId: 'already-exists' };
          }
          const tenantDetails = attempt.error.details as ArdaTenantResolutionDetails | undefined;
          return {
            success: false,
            error: tenantDetails?.message || resolvedErrorMessage || 'Failed to sync item',
          };
        }
        return {
          success: false,
          error: attempt.error instanceof Error ? attempt.error.message : 'Unknown sync error',
        };
      }

      const data = attempt.data;
      return {
        success: true,
        ardaEntityId: data?.record?.rId,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown sync error',
      };
    }
  }, [exportMasterListItemsFallback, resolveTenantForSync, uploadImage]);

  const syncSingleItem = useCallback(async (id: string): Promise<boolean> => {
    const item = items.find(entry => entry.id === id);
    if (!item) return false;

    setSyncStateById(prev => ({
      ...prev,
      [id]: { status: 'syncing' },
    }));

    const result = await syncItemToArda(item);

    if (result.success) {
      setSyncStateById(prev => ({
        ...prev,
        [id]: { status: 'success', ardaEntityId: result.ardaEntityId },
      }));
      return true;
    }

    setSyncStateById(prev => ({
      ...prev,
      [id]: { status: 'error', error: result.error || 'Sync failed' },
    }));
    return false;
  }, [items, syncItemToArda]);

  const syncSelectedItems = useCallback(async (selectedIds: string[]) => {
    if (selectedIds.length === 0 || isBulkSyncing) return;

    setIsBulkSyncing(true);
    try {
      const selectedItems = items.filter(item => selectedIds.includes(item.id));
      const tenantReady = await ensureTenantForSync(selectedItems);
      if (!tenantReady) {
        selectedIds.forEach((id) => {
          setSyncStateById(prev => ({
            ...prev,
            [id]: { status: 'error', error: 'Tenant unresolved. Exported selected items to CSV.' },
          }));
        });
        return;
      }

      for (let i = 0; i < selectedIds.length; i += 1) {
        const id = selectedIds[i];
        await syncSingleItem(id);
        if (i < selectedIds.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
    } finally {
      setIsBulkSyncing(false);
    }
  }, [ensureTenantForSync, isBulkSyncing, items, syncSingleItem]);

  return {
    syncStateById,
    setSyncStateById,
    isBulkSyncing,
    syncSingleItem,
    syncSelectedItems,
  };
}

```

### `src/index.css`

```css
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Arda-inspired light theme */
:root {
  --arda-accent: #FC5A29;
  --arda-accent-hover: #E54D1F;
  --arda-bg: #FFFFFF;
  --arda-bg-secondary: #F9FAFB;
  --arda-bg-tertiary: #F3F4F6;
  --arda-border: #E5E7EB;
  --arda-text-primary: #111827;
  --arda-text-secondary: #4B5563;
  --arda-text-muted: #9CA3AF;
}

body {
  background-color: var(--arda-bg-secondary);
  color: var(--arda-text-primary);
  font-family: 'Geist', 'Inter', system-ui, sans-serif;
}

/* Arda proprietary look */
.arda-mesh {
  background: radial-gradient(circle at 20% 20%, rgba(252, 90, 41, 0.16), transparent 25%),
              radial-gradient(circle at 80% 10%, rgba(59, 130, 246, 0.16), transparent 22%),
              radial-gradient(circle at 70% 80%, rgba(99, 102, 241, 0.18), transparent 28%),
              linear-gradient(135deg, #ffffff 0%, #f9fafb 40%, #f3f4f6 100%);
}

.arda-glass {
  backdrop-filter: blur(14px);
  background: rgba(255, 255, 255, 0.82);
  border: 1px solid rgba(229, 231, 235, 0.7);
  box-shadow: 0 25px 80px rgba(15, 23, 42, 0.06), 0 8px 30px rgba(252, 90, 41, 0.08);
}

.arda-pill {
  @apply inline-flex items-center gap-2 px-3 py-1 rounded-full text-xs font-semibold;
  background: linear-gradient(120deg, rgba(252, 90, 41, 0.15), rgba(59, 130, 246, 0.12));
  color: #FC5A29;
  border: 1px solid rgba(252, 90, 41, 0.25);
}

/* Custom Scrollbar - Light theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--arda-bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: #D1D5DB;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #9CA3AF;
}

/* Arda Button Styles */
.btn-arda-primary {
  @apply bg-arda-accent text-white px-4 py-2 rounded-arda font-medium text-sm;
  @apply hover:bg-arda-accent-hover transition-colors duration-200;
  @apply focus:outline-none focus:ring-2 focus:ring-arda-accent focus:ring-offset-2;
}

.btn-arda-secondary {
  @apply bg-arda-text-primary text-white px-4 py-2 rounded-arda font-medium text-sm;
  @apply hover:bg-gray-800 transition-colors duration-200;
}

.btn-arda-outline {
  @apply bg-transparent border border-arda-border text-arda-text-primary px-4 py-2 rounded-arda font-medium text-sm;
  @apply hover:bg-arda-bg-tertiary transition-colors duration-200;
}

/* Arda Card Styles */
.card-arda {
  @apply bg-white rounded-arda-lg border border-arda-border shadow-arda;
}

.card-arda-hover {
  @apply bg-white rounded-arda-lg border border-arda-border shadow-arda;
  @apply hover:shadow-arda-lg hover:border-arda-border-hover transition-all duration-200;
}

/* Arda Input Styles */
.input-arda {
  @apply w-full px-3 py-2 rounded-[10px] border border-arda-border;
  @apply text-arda-text-primary placeholder:text-arda-text-muted;
  @apply focus:outline-none focus:ring-2 focus:ring-arda-accent focus:border-transparent;
}

/* Arda Table Styles */
.table-arda {
  @apply w-full text-sm;
}

.table-arda th {
  @apply px-4 py-3 text-left text-xs font-semibold text-arda-text-secondary uppercase tracking-wider;
  @apply bg-arda-bg-secondary border-b border-arda-border;
}

.table-arda td {
  @apply px-4 py-3 border-b border-arda-border text-arda-text-primary;
}

.table-arda tr:hover td {
  @apply bg-arda-bg-tertiary;
}

/* Arda Sidebar */
.sidebar-arda {
  @apply bg-arda-bg-secondary border-r border-arda-border;
}

.sidebar-arda-item {
  @apply flex items-center gap-3 px-3 py-2 rounded-arda text-arda-text-secondary;
  @apply hover:bg-arda-bg-tertiary hover:text-arda-text-primary transition-colors duration-200;
}

.sidebar-arda-item-active {
  @apply flex items-center gap-3 px-3 py-2 rounded-arda;
  @apply bg-orange-50 text-arda-accent font-medium;
}

/* Animation utilities */
@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slide-in-from-top {
  from { transform: translateY(-10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes zoom-in {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

.animate-in {
  animation: fade-in 0.2s ease-out forwards;
}

.fade-in {
  animation: fade-in 0.2s ease-out forwards;
}

.slide-in-from-top-2 {
  animation: slide-in-from-top 0.3s ease-out forwards;
}

.zoom-in-95 {
  animation: zoom-in 0.2s ease-out forwards;
}

/* Delightful onboarding animations */
@keyframes bounce-in {
  0% { transform: scale(0.3); opacity: 0; }
  50% { transform: scale(1.05); }
  70% { transform: scale(0.9); }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes confetti {
  0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

@keyframes pulse-glow {
  0%, 100% { box-shadow: 0 0 0 0 rgba(252, 90, 41, 0.4); }
  50% { box-shadow: 0 0 0 15px rgba(252, 90, 41, 0); }
}

@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
}

@keyframes count-up {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.animate-bounce-in {
  animation: bounce-in 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
}

.animate-confetti {
  animation: confetti 3s linear forwards;
}

.animate-pulse-glow {
  animation: pulse-glow 2s infinite;
}

.animate-shimmer {
  background: linear-gradient(90deg, 
    rgba(147, 197, 253, 0.6), 
    rgba(96, 165, 250, 1), 
    rgba(59, 130, 246, 1),
    rgba(96, 165, 250, 1),
    rgba(147, 197, 253, 0.6)
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s ease-in-out infinite;
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

.animate-count-up {
  animation: count-up 0.3s ease-out forwards;
}

.animate-fade-in {
  animation: fade-in 0.5s ease-out forwards;
}

/* Line clamp utility */
.line-clamp-1 {
  display: -webkit-box;
  -webkit-line-clamp: 1;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* Gradient text */
.text-gradient {
  background: linear-gradient(135deg, #FC5A29 0%, #3B82F6 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Glass effect */
.glass {
  background: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

```

### `src/main.tsx`

```tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

```

### `src/services/__tests__/apiAuth.test.ts`

```typescript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import {
  authApi,
  resetSessionExpiredSignalForTests,
  SESSION_EXPIRED_EVENT,
  SessionExpiredError,
} from '../api';

describe('API auth error handling', () => {
  beforeEach(() => {
    resetSessionExpiredSignalForTests();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('maps 401 responses to SessionExpiredError and emits a session-expired signal', async () => {
    const fetchMock = vi.spyOn(globalThis, 'fetch').mockResolvedValue(
      new Response(JSON.stringify({ error: 'Not authenticated' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      }),
    );

    const onExpired = vi.fn();
    window.addEventListener(SESSION_EXPIRED_EVENT, onExpired);

    await expect(authApi.getCurrentUser()).rejects.toBeInstanceOf(SessionExpiredError);
    expect(fetchMock).toHaveBeenCalledTimes(1);
    expect(onExpired).toHaveBeenCalledTimes(1);

    window.removeEventListener(SESSION_EXPIRED_EVENT, onExpired);
  });
});

```

### `src/services/__tests__/apiBaseUrl.test.ts`

```typescript
import { describe, expect, it } from 'vitest';
import { normalizeApiBaseUrl, resolveApiBaseUrl } from '../api';

describe('API base URL resolution', () => {
  it('defaults to same-origin in production when VITE_API_URL is unset', () => {
    expect(resolveApiBaseUrl({ isProd: true })).toBe('');
  });

  it('defaults to localhost backend in development when VITE_API_URL is unset', () => {
    expect(resolveApiBaseUrl({ isProd: false })).toBe('http://localhost:3001');
  });

  it('uses explicit VITE_API_URL override and normalizes trailing slashes', () => {
    expect(resolveApiBaseUrl({ isProd: true, viteApiUrl: ' https://api.example.com/ ' })).toBe(
      'https://api.example.com',
    );
  });

  it('keeps explicit empty override as same-origin', () => {
    expect(resolveApiBaseUrl({ isProd: false, viteApiUrl: '' })).toBe('');
  });

  it('normalizes root URL slash', () => {
    expect(normalizeApiBaseUrl('/')).toBe('');
  });
});

```

### `src/services/__tests__/ardaOpenUrl.test.ts`

```typescript
import { describe, expect, it } from 'vitest';
import { buildArdaOpenUrl, getLastSuccessfulSyncTenant } from '../api';

describe('Arda open URL builder', () => {
  it('replaces {tenantId} when tenant exists', () => {
    expect(
      buildArdaOpenUrl('tenant-123', {
        appUrl: 'https://live.app.arda.cards',
        appUrlTemplate: 'https://live.app.arda.cards/?tenantId={tenantId}',
      }),
    ).toBe('https://live.app.arda.cards/?tenantId=tenant-123');
  });

  it('falls back to app URL when tenant is missing', () => {
    expect(
      buildArdaOpenUrl(null, {
        appUrl: 'https://live.app.arda.cards',
        appUrlTemplate: 'https://live.app.arda.cards/?tenantId={tenantId}',
      }),
    ).toBe('https://live.app.arda.cards');
  });

  it('falls back to app URL when template has no tenant placeholder', () => {
    expect(
      buildArdaOpenUrl('tenant-123', {
        appUrl: 'https://live.app.arda.cards',
        appUrlTemplate: 'https://live.app.arda.cards/dashboard',
      }),
    ).toBe('https://live.app.arda.cards');
  });
});

describe('last successful sync tenant parser', () => {
  it('selects the most recent successful event with tenantId', () => {
    const tenant = getLastSuccessfulSyncTenant({
      recent: [
        {
          id: '2',
          operation: 'item_create',
          success: true,
          requested: 1,
          successful: 1,
          failed: 0,
          timestamp: '2026-02-20T10:00:00.000Z',
          tenantId: 'tenant-new',
          email: 'new@example.com',
        },
        {
          id: '1',
          operation: 'item_create',
          success: true,
          requested: 1,
          successful: 1,
          failed: 0,
          timestamp: '2026-02-20T09:00:00.000Z',
          tenantId: 'tenant-old',
          email: 'old@example.com',
        },
      ],
    });

    expect(tenant).toEqual({
      tenantId: 'tenant-new',
      email: 'new@example.com',
      timestamp: '2026-02-20T10:00:00.000Z',
    });
  });

  it('ignores failed or tenant-less events', () => {
    const tenant = getLastSuccessfulSyncTenant({
      recent: [
        {
          id: '3',
          operation: 'item_create',
          success: false,
          requested: 1,
          successful: 0,
          failed: 1,
          timestamp: '2026-02-20T10:00:00.000Z',
          tenantId: 'tenant-failed',
        },
        {
          id: '2',
          operation: 'item_create',
          success: true,
          requested: 1,
          successful: 1,
          failed: 0,
          timestamp: '2026-02-20T09:00:00.000Z',
        },
      ],
    });

    expect(tenant).toBeNull();
  });
});

```

### `src/services/api.ts`

```typescript
// API client for backend communication
// Production defaults to same-origin so Vercel rewrites keep session cookies first-party.
const DEFAULT_DEV_API_BASE_URL = 'http://localhost:3001';
const DEFAULT_ARDA_APP_URL = 'https://live.app.arda.cards';
const DEFAULT_ARDA_APP_URL_TEMPLATE = `${DEFAULT_ARDA_APP_URL}/?tenantId={tenantId}`;
const SESSION_EXPIRED_MESSAGE = 'Session expired. Please sign in again.';
export const SESSION_EXPIRED_EVENT = 'orderpulse:session-expired';

interface ApiBaseUrlConfig {
  viteApiUrl?: string;
  isProd: boolean;
}

export function normalizeApiBaseUrl(baseUrl: string): string {
  const trimmed = baseUrl.trim();
  return trimmed.replace(/\/+$/, '');
}

export function resolveApiBaseUrl({ viteApiUrl, isProd }: ApiBaseUrlConfig): string {
  if (viteApiUrl !== undefined) {
    return normalizeApiBaseUrl(viteApiUrl);
  }
  return isProd ? '' : DEFAULT_DEV_API_BASE_URL;
}

const API_BASE_URL = resolveApiBaseUrl({
  viteApiUrl: import.meta.env.VITE_API_URL as string | undefined,
  isProd: import.meta.env.PROD,
});

export function buildArdaOpenUrl(
  tenantId: string | null | undefined,
  options?: { appUrl?: string; appUrlTemplate?: string },
): string {
  const appUrl = normalizeApiBaseUrl(
    options?.appUrl ?? (import.meta.env.VITE_ARDA_APP_URL as string | undefined) ?? DEFAULT_ARDA_APP_URL,
  );
  const appUrlTemplate = (
    options?.appUrlTemplate ??
    (import.meta.env.VITE_ARDA_APP_URL_TEMPLATE as string | undefined) ??
    DEFAULT_ARDA_APP_URL_TEMPLATE
  ).trim();

  if (!tenantId || !appUrlTemplate.includes('{tenantId}')) {
    return appUrl;
  }

  return appUrlTemplate.replaceAll('{tenantId}', encodeURIComponent(tenantId));
}

interface ApiError {
  error: string;
  code?: string;
  details?: unknown;
}

export class SessionExpiredError extends Error {
  constructor(message = SESSION_EXPIRED_MESSAGE) {
    super(message);
    this.name = 'SessionExpiredError';
  }
}

export class ApiRequestError extends Error {
  status: number;
  code?: string;
  details?: unknown;

  constructor(message: string, status: number, code?: string, details?: unknown) {
    super(message);
    this.name = 'ApiRequestError';
    this.status = status;
    this.code = code;
    this.details = details;
  }
}

export function isSessionExpiredError(error: unknown): error is SessionExpiredError {
  return error instanceof SessionExpiredError;
}

export function isApiRequestError(error: unknown): error is ApiRequestError {
  return error instanceof ApiRequestError;
}

let hasNotifiedSessionExpired = false;

function notifySessionExpired(): void {
  if (hasNotifiedSessionExpired) return;
  hasNotifiedSessionExpired = true;
  if (typeof window !== 'undefined') {
    window.dispatchEvent(new CustomEvent(SESSION_EXPIRED_EVENT));
  }
}

// Test helper for deterministic assertions.
export function resetSessionExpiredSignalForTests(): void {
  hasNotifiedSessionExpired = false;
}

async function fetchApi<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    ...options,
    credentials: 'include', // Include cookies for session
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

  if (!response.ok) {
    const error: ApiError = await response.json().catch(() => ({ error: 'Request failed' }));
    if (response.status === 401) {
      notifySessionExpired();
      throw new SessionExpiredError();
    }
    throw new ApiRequestError(
      error.error || `HTTP ${response.status}`,
      response.status,
      error.code,
      error.details
    );
  }

  return response.json();
}

// Auth API
export const authApi = {
  getLoginUrl: () => `${API_BASE_URL}/auth/google`,

  login: (email: string, password: string) =>
    fetchApi<{ success: boolean; user: { id: string; email: string; name: string; picture_url: string } }>(
      '/auth/local/login',
      {
        method: 'POST',
        body: JSON.stringify({ email, password }),
      }
    ),

  signup: (email: string, password: string, name?: string) =>
    fetchApi<{ success: boolean; user: { id: string; email: string; name: string; picture_url: string } }>(
      '/auth/local/signup',
      {
        method: 'POST',
        body: JSON.stringify({ email, password, name }),
      }
    ),
  
  getCurrentUser: () => fetchApi<{ user: { id: string; email: string; name: string; picture_url: string } }>('/auth/me'),
  
  // Exchange short-lived auth token for session (used after OAuth redirect)
  exchangeToken: (token: string) => fetchApi<{ success: boolean; user: { id: string; email: string; name: string; picture_url: string } }>(`/auth/token-exchange?token=${token}`),
  
  logout: () => fetchApi<{ success: boolean }>('/auth/logout', { method: 'POST' }),
};

// Gmail API
export interface GmailMessage {
  id: string;
  subject: string;
  sender: string;
  date: string;
  snippet: string;
  body: string;
}

export const gmailApi = {
  getMessages: (query?: string, maxResults?: number) => 
    fetchApi<{ messages: GmailMessage[]; total: number }>(
      `/api/gmail/messages?q=${encodeURIComponent(query || '')}&maxResults=${maxResults || 10}`
    ),

  getStatus: () =>
    fetchApi<{ connected: boolean; gmailEmail?: string | null }>('/api/gmail/status'),
  
  sendEmail: (to: string, subject: string, body: string) =>
    fetchApi<{ success: boolean; messageId: string }>('/api/gmail/send', {
      method: 'POST',
      body: JSON.stringify({ to, subject, body }),
    }),
};

// Analysis API
export interface AnalysisResult {
  emailId: string;
  isOrder: boolean;
  supplier: string | null;
  orderDate: string | null;
  totalAmount: number | null;
  items: Array<{
    name: string;
    quantity: number;
    unit: string;
    unitPrice: number | null;
    totalPrice: number | null;
  }>;
  confidence: number;
}

export const analysisApi = {
  analyzeEmails: (emails: Array<{ id: string; subject: string; sender: string; body: string }>) =>
    fetchApi<{ results: AnalysisResult[] }>('/api/analyze', {
      method: 'POST',
      body: JSON.stringify({ emails }),
    }),
};

// Discover API
export interface DiscoveredSupplier {
  domain: string;
  displayName: string;
  emailCount: number;
  score: number;
  category: 'industrial' | 'retail' | 'office' | 'food' | 'electronics' | 'unknown';
  sampleSubjects: string[];
  isRecommended: boolean;
}

export const discoverApi = {
  discoverSuppliers: () => fetchApi<{ suppliers: DiscoveredSupplier[] }>('/api/discover/discover-suppliers'),
  
  startJobWithFilter: (supplierDomains?: string[]) =>
    fetchApi<{ jobId: string; status: string; message: string }>('/api/jobs/start', {
      method: 'POST',
      body: JSON.stringify({ supplierDomains }),
    }),
};

// Jobs API - Background processing with polling
export interface JobProgress {
  total: number;
  processed: number;
  success: number;
  failed: number;
  currentTask: string;
}

export interface JobEmailPreview {
  id: string;
  subject: string;
  sender: string;
  snippet?: string;
}

export interface JobOrder {
  id: string;
  supplier: string;
  orderDate: string;
  totalAmount: number;
  items: Array<{
    id: string;
    name: string;
    quantity: number;
    unit: string;
    unitPrice: number;
  }>;
  confidence: number;
}

export interface JobStatus {
  hasJob: boolean;
  jobId?: string;
  status?: 'pending' | 'running' | 'completed' | 'failed';
  progress?: JobProgress;
  currentEmail?: JobEmailPreview | null;
  orders?: JobOrder[];
  logs?: string[];
  error?: string;
  message?: string;
}

export const jobsApi = {
  // Start Amazon-first processing immediately
  startAmazon: () =>
    fetchApi<{ jobId: string }>('/api/jobs/start-amazon', {
      method: 'POST',
    }),
  
  // Start processing for selected suppliers
  startJob: (supplierDomains?: string[], jobType?: string) =>
    fetchApi<{ jobId: string }>('/api/jobs/start', {
      method: 'POST',
      body: JSON.stringify({ supplierDomains, jobType }),
    }),
  
  getStatus: (jobId?: string) =>
    fetchApi<JobStatus>(`/api/jobs/status${jobId ? `?jobId=${jobId}` : ''}`),
  
  getJob: (jobId: string) =>
    fetchApi<JobStatus>(`/api/jobs/${jobId}`),
};

export interface UrlScrapedItem {
  sourceUrl: string;
  productUrl?: string;
  imageUrl?: string;
  itemName?: string;
  supplier?: string;
  price?: number;
  currency?: string;
  description?: string;
  vendorSku?: string;
  asin?: string;
  needsReview: boolean;
  extractionSource: 'amazon-paapi' | 'html-metadata' | 'hybrid-ai' | 'error';
  confidence: number;
}

export interface UrlScrapeResult {
  sourceUrl: string;
  normalizedUrl?: string;
  status: 'success' | 'partial' | 'failed';
  message?: string;
  extractionSource: UrlScrapedItem['extractionSource'];
  item: UrlScrapedItem;
}

export interface UrlScrapeResponse {
  requested: number;
  processed: number;
  results: UrlScrapeResult[];
  items: UrlScrapedItem[];
}

export const urlIngestionApi = {
  scrapeUrls: (urls: string[]) =>
    fetchApi<UrlScrapeResponse>('/api/url-ingestion/scrape', {
      method: 'POST',
      body: JSON.stringify({ urls }),
    }),
};

// Amazon API
export interface AmazonItemData {
  ASIN: string;
  ItemName?: string;
  Price?: string;
  ImageURL?: string;
  AmazonURL?: string;
  Quantity?: string;
  Units?: string;
  UnitCount?: number;
  UnitPrice?: number;
  UPC?: string;
}

export const amazonApi = {
  getItem: (asin: string) =>
    fetchApi<{ item: AmazonItemData }>(`/api/amazon/item/${asin}`),
  
  getItems: (asins: string[]) =>
    fetchApi<{ items: Record<string, AmazonItemData>; requested: number; found: number }>('/api/amazon/items', {
      method: 'POST',
      body: JSON.stringify({ asins }),
    }),
    
  extractAsins: (text: string, subject?: string) =>
    fetchApi<{ asins: string[] }>('/api/amazon/extract-asins', {
      method: 'POST',
      body: JSON.stringify({ text, subject }),
    }),
};

// Orders API
export interface Order {
  id: string;
  user_id: string;
  original_email_id: string;
  supplier: string;
  order_date: string;
  total_amount: number;
  confidence: number;
  items: Array<{
    id: string;
    name: string;
    quantity: number;
    unit: string;
    unitPrice: number;
    totalPrice: number;
  }>;
}

export interface InventoryItem {
  name: string;
  totalQuantityOrdered: number;
  orderCount: number;
  firstOrderDate: string;
  lastOrderDate: string;
  averageCadenceDays: number;
  dailyBurnRate: number;
  recommendedMin: number;
  recommendedOrderQty: number;
  lastPrice: number;
  suppliers: string;
  location?: string;
  imageUrl?: string;
  productUrl?: string;
  asin?: string;
}

export const ordersApi = {
  getOrders: () => fetchApi<{ orders: Order[] }>('/api/orders'),
  
  saveOrders: (orders: Order[]) =>
    fetchApi<{ success: boolean; orders: Order[] }>('/api/orders', {
      method: 'POST',
      body: JSON.stringify({ orders }),
    }),
  
  getInventory: () => fetchApi<{ inventory: InventoryItem[] }>('/api/orders/inventory'),
  
  deleteOrder: (id: string) =>
    fetchApi<{ success: boolean }>(`/api/orders/${id}`, { method: 'DELETE' }),
};

export type IntegrationProvider = 'quickbooks' | 'xero';
export type IntegrationConnectionStatus = 'connected' | 'reauth_required' | 'error' | 'disconnected';
export type IntegrationSyncTrigger = 'manual' | 'scheduled' | 'webhook' | 'backfill';
export type IntegrationSyncStatus = 'running' | 'success' | 'failed';

export interface IntegrationConnection {
  id: string;
  provider: IntegrationProvider;
  tenantId: string;
  tenantName?: string;
  status: IntegrationConnectionStatus;
  tokenExpiresAt: string;
  createdAt: string;
  updatedAt: string;
  lastRun?: {
    id: string;
    status: IntegrationSyncStatus;
    trigger: IntegrationSyncTrigger;
    startedAt: string;
    finishedAt?: string;
    error?: string;
  };
}

export interface IntegrationSyncRun {
  id: string;
  connectionId: string;
  trigger: IntegrationSyncTrigger;
  status: IntegrationSyncStatus;
  ordersUpserted: number;
  ordersDeleted: number;
  itemsUpserted: number;
  apiCalls: number;
  startedAt: string;
  finishedAt?: string;
  error?: string;
}

export const integrationsApi = {
  connectProvider: (provider: IntegrationProvider) =>
    fetchApi<{ authUrl: string }>(`/api/integrations/${provider}/connect`, {
      method: 'POST',
    }),

  listConnections: () =>
    fetchApi<{ connections: IntegrationConnection[] }>('/api/integrations/connections'),

  disconnectConnection: (connectionId: string) =>
    fetchApi<{ success: boolean }>(`/api/integrations/connections/${connectionId}`, {
      method: 'DELETE',
    }),

  syncConnection: (connectionId: string) =>
    fetchApi<{ success: boolean; runId: string }>(`/api/integrations/connections/${connectionId}/sync`, {
      method: 'POST',
    }),

  getConnectionRuns: (connectionId: string) =>
    fetchApi<{ runs: IntegrationSyncRun[] }>(`/api/integrations/connections/${connectionId}/runs`),
};

export { API_BASE_URL };

// Arda API
export interface ArdaItemInput {
  name: string;
  description?: string;
  orderMechanism?: string;
  minQty?: number;
  minQtyUnit?: string;
  primarySupplier: string;
  location?: string;
  orderQty?: number;
  orderQtyUnit?: string;
  primarySupplierLink?: string;
  imageUrl?: string;
  sku?: string;
  barcode?: string;
  unitPrice?: number;
}

export interface ArdaKanbanCardInput {
  item: {
    itemId: string;
    itemName: string;
  };
  quantity: {
    value: number;
    unit: string;
  };
  locator?: {
    facility: string;
    location?: string;
  };
  seedStatus?: string;
  notes?: string;
}

export interface ArdaOrderInput {
  orderDate?: string;
  supplier?: string;
  supplierName?: string;
  allowPartial?: boolean;
  expedite?: boolean;
  deliverBy?: string;
  notes?: string;
  taxesAndFees?: Record<string, { value: number; currency: string }>;
}

export interface ArdaEntityRecord {
  rId: string;
  asOf: { effective: number; recorded: number };
  payload: unknown;
  metadata: unknown;
  retired: boolean;
}

export interface ArdaItemVelocityProfileInput {
  displayName: string;
  supplier: string;
  dailyBurnRate: number;
  averageCadenceDays: number;
  recommendedMin: number;
  recommendedOrderQty: number;
  unit?: string;
  location?: string;
  primarySupplierLink?: string;
  imageUrl?: string;
}

export interface ArdaVelocitySyncResult {
  displayName: string;
  success: boolean;
  itemId?: string;
  error?: string;
}

export interface ArdaTenantSuggestion {
  tenantId: string;
  matchedEmail: string;
  domain: string;
  matchCount: number;
}

export interface ArdaTenantResolutionDetails {
  email?: string;
  message?: string;
  authorFound?: boolean;
  tenantIdFound?: boolean;
  canUseSuggestedTenant?: boolean;
  canCreateTenant?: boolean;
  suggestedTenant?: ArdaTenantSuggestion | null;
  tenantId?: string;
  autoProvisionAttempted?: boolean;
  autoProvisionSucceeded?: boolean;
  autoProvisionError?: string;
  resolutionMode?: 'mapped' | 'provisioned' | 'override' | 'unresolved';
}

export interface ArdaSyncStatusEvent {
  id: string;
  operation: string;
  success: boolean;
  requested: number;
  successful: number;
  failed: number;
  timestamp: string;
  error?: string;
  email?: string;
  tenantId?: string;
}

export interface ArdaSyncStatusResponse {
  success: boolean;
  message: string;
  user: string;
  ardaConfigured: boolean;
  totalAttempts: number;
  successfulAttempts: number;
  failedAttempts: number;
  totalRequested: number;
  totalSuccessful: number;
  totalFailed: number;
  lastAttemptAt: string | null;
  lastSuccessAt: string | null;
  lastErrorAt: string | null;
  recent: ArdaSyncStatusEvent[];
  updatedAt: string;
  timestamp: string;
}

export interface ArdaSyncedTenantContext {
  tenantId: string;
  email?: string;
  timestamp: string;
}

export function getLastSuccessfulSyncTenant(
  syncStatus: Pick<ArdaSyncStatusResponse, 'recent'> | null | undefined,
): ArdaSyncedTenantContext | null {
  const recentEvents = syncStatus?.recent ?? [];
  for (const event of recentEvents) {
    if (event.success && event.tenantId) {
      return {
        tenantId: event.tenantId,
        email: event.email,
        timestamp: event.timestamp,
      };
    }
  }
  return null;
}

export const ardaApi = {
  // Check if Arda is configured
  getStatus: () => fetchApi<{ configured: boolean; message: string }>('/api/arda/status'),

  // Create item in Arda
  createItem: (item: ArdaItemInput) =>
    fetchApi<{ success: boolean; record: ArdaEntityRecord }>('/api/arda/items', {
      method: 'POST',
      body: JSON.stringify(item),
    }),

  // Bulk create items
  bulkCreateItems: (items: ArdaItemInput[]) =>
    fetchApi<{
      success: boolean;
      code?: string;
      error?: string;
      details?: ArdaTenantResolutionDetails;
      summary?: { total: number; successful: number; failed: number };
      results?: Array<{ item: string; status: string; error?: string }>;
    }>('/api/arda/items/bulk', {
      method: 'POST',
      body: JSON.stringify({ items }),
    }),

  resolveTenant: (action: 'create_new' | 'use_suggested') =>
    fetchApi<{ success: boolean; tenantId?: string; author?: string; error?: string }>('/api/arda/tenant/resolve', {
      method: 'POST',
      body: JSON.stringify({ action }),
    }),

  getTenantStatus: () =>
    fetchApi<{
      success: boolean;
      resolved: boolean;
      code?: string;
      error?: string;
      details?: ArdaTenantResolutionDetails;
    }>('/api/arda/tenant/status'),

  getSyncStatus: () => fetchApi<ArdaSyncStatusResponse>('/api/arda/sync-status'),

  // Create Kanban card
  createKanbanCard: (card: ArdaKanbanCardInput) =>
    fetchApi<{ success: boolean; record: ArdaEntityRecord }>('/api/arda/kanban-cards', {
      method: 'POST',
      body: JSON.stringify(card),
    }),

  // Create order
  createOrder: (order: ArdaOrderInput) =>
    fetchApi<{ success: boolean; record: ArdaEntityRecord }>('/api/arda/orders', {
      method: 'POST',
      body: JSON.stringify(order),
    }),

  // Push velocity items to Arda
  pushVelocityItems: (items: ArdaItemVelocityProfileInput[]) =>
    fetchApi<{
      success: boolean;
      summary: { total: number; successful: number; failed: number };
      results: ArdaVelocitySyncResult[];
    }>('/api/arda/push-velocity', {
      method: 'POST',
      body: JSON.stringify({ items }),
    }),
};

```

### `src/services/geminiService.ts`

```typescript
import { GoogleGenAI, Type } from "@google/genai";
import { ExtractedOrder, RawEmail } from "../types";

// Schema for structured output
const ORDER_SCHEMA = {
  type: Type.OBJECT,
  properties: {
    isOrder: { type: Type.BOOLEAN, description: "True if this email is a receipt, invoice, or order confirmation." },
    supplier: { type: Type.STRING, description: "The name of the vendor or supplier." },
    orderDate: { type: Type.STRING, description: "Date of the order in ISO 8601 format (YYYY-MM-DD)." },
    totalAmount: { type: Type.NUMBER, description: "Total numerical value of the order." },
    items: {
      type: Type.ARRAY,
      items: {
        type: Type.OBJECT,
        properties: {
          name: { type: Type.STRING, description: "Clean, standardized name of the product." },
          quantity: { type: Type.NUMBER, description: "Numeric quantity purchased." },
          unit: { type: Type.STRING, description: "Unit of measure (e.g., box, case, each, lbs)." },
          unitPrice: { type: Type.NUMBER, description: "Price per unit." }
        }
      }
    }
  },
  required: ["isOrder"]
};

export const parseEmailWithGemini = async (email: RawEmail, apiKey: string): Promise<ExtractedOrder | null> => {
  if (!apiKey) throw new Error("API Key is missing");

  const ai = new GoogleGenAI({ apiKey });

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash",
      contents: `
        Analyze the following email content. Determine if it is a purchase order, receipt, or invoice.
        If it is, extract the supplier, date, and line items.
        
        Subject: ${email.subject}
        Sender: ${email.sender}
        Date Header: ${email.date}
        Body:
        ${email.body}
      `,
      config: {
        responseMimeType: "application/json",
        responseSchema: ORDER_SCHEMA,
      }
    });

    const text = response.text;
    if (!text) return null;

    const data = JSON.parse(text);

    if (!data.isOrder) {
      return null;
    }

    return {
      id: `order_${Math.random().toString(36).substr(2, 9)}`,
      originalEmailId: email.id,
      supplier: data.supplier || "Unknown Supplier",
      orderDate: data.orderDate || email.date,
      totalAmount: data.totalAmount,
      items: data.items || [],
      confidence: 0.95 
    };

  } catch (error) {
    console.error("Gemini Parsing Error:", error);
    return null;
  }
};

/**
 * Uses Gemini to take a rough email draft and make it more professional and concise.
 */
export const improveEmailDraft = async (body: string, apiKey: string): Promise<string> => {
  if (!apiKey) throw new Error("API Key is missing for AI Enhancement");

  const ai = new GoogleGenAI({ apiKey });

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash",
      contents: `
        Rewrite the following email draft to be professional, polite, and concise. 
        It is a supplier communication for a business. 
        Keep any specific numbers, dates, or product names.
        Return ONLY the rewritten body text.
        
        Draft:
        ${body}
      `,
    });

    return response.text || body;
  } catch (error) {
    console.error("Gemini Improvement Error:", error);
    return body; // Fallback to original
  }
};

```

### `src/services/gmailService.ts`

```typescript
import { RawEmail, GoogleUserProfile } from '../types';

const GMAIL_API_BASE = 'https://gmail.googleapis.com/gmail/v1/users/me';
const USER_INFO_ENDPOINT = 'https://www.googleapis.com/oauth2/v1/userinfo';

export const validateToken = async (accessToken: string): Promise<boolean> => {
  try {
    const res = await fetch(`${USER_INFO_ENDPOINT}?alt=json`, {
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    return res.ok;
  } catch {
    return false;
  }
};

export const fetchUserProfile = async (accessToken: string): Promise<GoogleUserProfile | null> => {
  try {
    const res = await fetch(`${USER_INFO_ENDPOINT}?alt=json`, {
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    if (!res.ok) return null;
    return await res.json();
  } catch (e) {
    console.error("Failed to fetch user profile", e);
    return null;
  }
};

export const sendGmailEmail = async (
  accessToken: string, 
  to: string, 
  subject: string, 
  body: string,
  cc?: string,
  bcc?: string
): Promise<boolean> => {
  // Gmail API requires a base64url encoded RFC 2822 message
  const emailLines = [
    `To: ${to}`,
    cc ? `Cc: ${cc}` : null,
    bcc ? `Bcc: ${bcc}` : null,
    `Subject: ${subject}`,
    'Content-Type: text/html; charset=utf-8',
    'MIME-Version: 1.0',
    '',
    body
  ].filter(line => line !== null);
  
  const emailContent = emailLines.join('\r\n');
  const encodedEmail = btoa(unescape(encodeURIComponent(emailContent)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');

  try {
    const res = await fetch(`${GMAIL_API_BASE}/messages/send`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        raw: encodedEmail
      })
    });
    
    return res.ok;
  } catch (error) {
    console.error("Failed to send email", error);
    return false;
  }
};

const decodeBase64 = (data: string) => {
  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');
  try {
    return atob(base64);
  } catch (e) {
    console.error("Failed to decode base64", e);
    return "";
  }
};

interface GmailHeader {
  name: string;
  value: string;
}

interface GmailPart {
  mimeType: string;
  body?: { data?: string };
  parts?: GmailPart[];
}

interface GmailMessage {
  id: string;
  snippet?: string;
  payload: {
    headers?: GmailHeader[];
    body?: { data?: string };
    parts?: GmailPart[];
  };
}

const parseGmailResponse = (message: GmailMessage): RawEmail => {
  const headers = message.payload.headers || [];
  const getHeader = (name: string) => headers.find((h) => h.name.toLowerCase() === name.toLowerCase())?.value || '';
  
  const subject = getHeader('Subject') || '(No Subject)';
  const sender = getHeader('From') || 'Unknown Sender';
  const date = getHeader('Date') || new Date().toISOString(); 
  
  let body = '';
  
  const findBody = (parts: GmailPart[]): string => {
    for (const part of parts) {
      if (part.mimeType === 'text/html' && part.body?.data) {
        return decodeBase64(part.body.data);
      }
      if (part.mimeType === 'text/plain' && part.body?.data) {
        return decodeBase64(part.body.data);
      }
      if (part.parts) {
        const found = findBody(part.parts);
        if (found) return found;
      }
    }
    return '';
  };

  if (message.payload.body?.data) {
    body = decodeBase64(message.payload.body.data);
  } else if (message.payload.parts) {
    body = findBody(message.payload.parts);
  } else {
    body = message.snippet || "";
  }

  return {
    id: message.id,
    subject,
    sender,
    date,
    snippet: message.snippet || "",
    body
  };
};

export const fetchGmailMessages = async (accessToken: string, query: string = 'subject:(order OR invoice OR receipt)'): Promise<RawEmail[]> => {
  const listRes = await fetch(`${GMAIL_API_BASE}/messages?q=${encodeURIComponent(query)}&maxResults=10`, {
    headers: { Authorization: `Bearer ${accessToken}` }
  });
  
  if (!listRes.ok) throw new Error('Failed to list messages');
  
  const listData = await listRes.json();
  const messages = listData.messages || [];
  
  const detailPromises = messages.map(async (msg: { id: string }) => {
    try {
      const detailRes = await fetch(`${GMAIL_API_BASE}/messages/${msg.id}`, {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const detail = await detailRes.json();
      return parseGmailResponse(detail);
    } catch (e) {
      console.error(`Failed to fetch message ${msg.id}`, e);
      return null;
    }
  });
  
  const rawEmails = await Promise.all(detailPromises);
  return rawEmails.filter((e): e is RawEmail => e !== null);
};

```

### `src/services/mockData.ts`

```typescript
import { RawEmail } from '../types';

export const MOCK_EMAILS: RawEmail[] = [
  {
    id: 'msg_001',
    subject: 'Order Confirmation #4492 - Acme Supplies',
    sender: 'orders@acmesupplies.com',
    date: '2023-10-01T09:30:00Z',
    snippet: 'Thank you for your business. Here is your receipt...',
    body: `
      <h1>Order Confirmation</h1>
      <p>Date: October 1, 2023</p>
      <p>Order #: 4492</p>
      <table>
        <tr><th>Item</th><th>Qty</th><th>Price</th></tr>
        <tr><td>Industrial Paper Towels (Case of 12)</td><td>5</td><td>$45.00</td></tr>
        <tr><td>Hand Soap Refill (1 Gallon)</td><td>2</td><td>$12.50</td></tr>
        <tr><td>Trash Bags 50 Gallon (Roll)</td><td>10</td><td>$18.00</td></tr>
      </table>
      <p>Total: $430.00</p>
    `
  },
  {
    id: 'msg_002',
    subject: 'Your recent purchase from TechParts Inc',
    sender: 'billing@techparts.io',
    date: '2023-10-15T14:20:00Z',
    snippet: 'Your electronic components are on the way...',
    body: `
      Hello Team,
      Thanks for shopping with TechParts.
      Order Date: 2023-10-15
      
      Items:
      - USB-C Cables (Braided, 2m) x 50 @ $3.50 ea
      - HDMI Adapters 4K x 20 @ $8.00 ea
      
      Shipping: Free
      Total: $335.00
    `
  },
  {
    id: 'msg_003',
    subject: 'Order #4501 Confirmed',
    sender: 'orders@acmesupplies.com',
    date: '2023-10-22T10:00:00Z',
    snippet: 'Another order has been processed...',
    body: `
      <h1>Order Confirmation</h1>
      <p>Date: October 22, 2023</p>
      <p>Order #: 4501</p>
      <table>
        <tr><th>Item</th><th>Qty</th><th>Price</th></tr>
        <tr><td>Industrial Paper Towels (Case of 12)</td><td>4</td><td>$45.00</td></tr>
        <tr><td>Bleach Cleaner (Spray)</td><td>12</td><td>$4.50</td></tr>
      </table>
    `
  },
  {
    id: 'msg_004',
    subject: 'Invoice: Coffee Beans Monthly',
    sender: 'roastery@beanstream.com',
    date: '2023-10-05T08:00:00Z',
    snippet: 'Your monthly coffee supply...',
    body: `
      Invoice #9992
      Date: 2023-10-05
      
      1. Espresso Blend (5lb Bag) - Qty: 6 - Unit: $60.00
      2. Filter Blend (5lb Bag) - Qty: 4 - Unit: $55.00
    `
  },
  {
    id: 'msg_005',
    subject: 'Order #4588 - Restock',
    sender: 'orders@acmesupplies.com',
    date: '2023-11-12T11:15:00Z',
    snippet: 'Restock order processed...',
    body: `
      <h1>Order Confirmation</h1>
      <p>Date: November 12, 2023</p>
      <p>Order #: 4588</p>
      Items:
      - Industrial Paper Towels (Case of 12): 6 units @ $46.00
      - Trash Bags 50 Gallon (Roll): 8 units @ $18.50
    `
  },
  {
    id: 'msg_006',
    subject: 'Invoice: Coffee Beans',
    sender: 'roastery@beanstream.com',
    date: '2023-11-04T08:00:00Z',
    snippet: 'Fresh roast incoming...',
    body: `
      Invoice #10045
      Date: 2023-11-04
      
      1. Espresso Blend (5lb Bag) - Qty: 6 - Unit: $60.00
      2. Filter Blend (5lb Bag) - Qty: 5 - Unit: $55.00
    `
  }
];

```

### `src/setupTests.ts`

```typescript
import '@testing-library/jest-dom';

```

### `src/types.ts`

```typescript
export interface LineItem {
  id?: string;  // Unique identifier for tracking
  name: string;
  quantity: number;
  unit: string;
  unitPrice?: number;
  totalPrice?: number;
  // Source tracking fields
  sourceEmailId?: string;
  sourceOrderId?: string;
  normalizedName?: string;  // For matching across orders
  sku?: string;  // Part number/SKU if available
  // Amazon-specific fields
  asin?: string;  // Amazon Standard Identification Number
  amazonEnriched?: AmazonItemData;  // Enriched data from Amazon API
}

// Amazon Product Advertising API enriched data
export interface AmazonItemData {
  asin: string;
  itemName: string;
  humanizedName?: string;  // Shop-floor friendly name from LLM
  price?: string;
  imageUrl?: string;
  amazonUrl?: string;
  unitCount?: number | string;
  unitPrice?: number;
  upc?: string;
}

// Cross-order item tracking for velocity analysis
export interface ItemVelocityProfile {
  normalizedName: string;
  displayName: string;
  supplier: string;
  sku?: string;
  packSize?: number;
  // Amazon enrichment
  asin?: string;
  imageUrl?: string;
  amazonUrl?: string;
  // Order history
  orders: {
    orderId: string;
    emailId: string;
    date: string;
    quantity: number;
    unitPrice?: number;
  }[];
  // Calculated fields
  totalQuantityOrdered: number;
  orderCount: number;
  averageCadenceDays: number;
  dailyBurnRate: number;
  firstOrderDate: string;
  lastOrderDate: string;
  nextPredictedOrder?: string;
  // Recommendations
  recommendedMin: number;
  recommendedOrderQty: number;
}

// Tree view node types for the Order Journey
export type JourneyNodeType = 'email' | 'order' | 'lineItem' | 'velocity';

export interface JourneyNode {
  id: string;
  type: JourneyNodeType;
  label: string;
  subtitle?: string;
  children?: JourneyNode[];
  data?: EmailNodeData | OrderNodeData | LineItemNodeData | VelocityNodeData;
  isExpanded?: boolean;
  isNew?: boolean;
}

export interface EmailNodeData {
  emailId: string;
  sender: string;
  subject: string;
  date: string;
}

export interface OrderNodeData {
  orderId: string;
  emailId: string;
  supplier: string;
  orderDate: string;
  totalAmount?: number;
  itemCount: number;
  confidence: number;
}

export interface LineItemNodeData {
  lineItemId: string;
  orderId: string;
  emailId: string;
  name: string;
  normalizedName: string;
  quantity: number;
  unit: string;
  unitPrice?: number;
  sku?: string;
  asin?: string;
  supplier?: string;
  orderDate?: string;
  totalPrice?: number;
  amazonEnriched?: AmazonItemData;
}

export interface VelocityNodeData {
  normalizedName: string;
  dailyBurnRate: number;
  averageCadenceDays: number;
  orderCount: number;
  nextPredictedOrder?: string;
}

// Email type for tracking order lifecycle
export type OrderEmailType = 'order' | 'shipped' | 'delivered' | 'unknown';

export interface OrderEmail {
  emailId: string;
  emailType: OrderEmailType;
  date: string;
  subject: string;
}

export interface ExtractedOrder {
  id: string;
  originalEmailId: string;
  supplier: string;
  orderNumber?: string;  // Order/confirmation number from the email
  orderDate: string; // ISO String
  shippedDate?: string; // When order was shipped
  deliveredDate?: string; // When order was delivered
  leadTimeDays?: number; // Days from order to delivery
  totalAmount?: number;
  items: LineItem[];
  confidence: number;
  // Track all related emails for this order
  relatedEmails?: OrderEmail[];
}

export type ItemColor = 'Red' | 'Orange' | 'Yellow' | 'Green' | 'Blue' | 'Gray' | 'Pink' | 'Purple';
export type ReviewStatus = 'pending' | 'approved' | 'excluded';

export interface InventoryItem {
  id: string;
  name: string;
  originalName?: string;  // Full Amazon name for tooltip
  supplier: string;
  location?: string;
  asin?: string;
  amazonEnriched?: AmazonItemData;
  totalQuantityOrdered: number;
  orderCount: number;
  firstOrderDate: string;
  lastOrderDate: string;
  averageCadenceDays: number; // Days between orders
  dailyBurnRate: number; // Estimated daily usage
  recommendedMin: number; // Reorder point
  recommendedOrderQty: number; // EOQ
  lastPrice: number;
  history: { date: string; quantity: number }[];
  // New fields for table view
  imageUrl?: string;
  productUrl?: string;
  color?: ItemColor;
  isDraft?: boolean; // True for items from email that haven't been saved
}

export interface ProcessingStatus {
  total: number;
  processed: number;
  success: number;
  failed: number;
  currentTask: string;
}

export interface RawEmail {
  id: string;
  subject: string;
  sender: string;
  date: string;
  snippet: string;
  body: string; // HTML or Text content
}

export interface GoogleUserProfile {
  id: string;
  email: string;
  name: string;
  given_name?: string;
  family_name?: string;
  picture: string;
}

```

### `src/utils/__tests__/supplierUtils.test.ts`

```typescript
import { describe, expect, it } from 'vitest';
import { DiscoveredSupplier } from '../../services/api';
import {
  canonicalizePrioritySupplierDomain,
  isPrioritySupplierDomain,
  OTHER_PRIORITY_SUPPLIERS,
} from '../../views/supplierSetupUtils';
import { mergeSuppliers } from '../supplierUtils';

describe('mergeSuppliers', () => {
  it('collapses priority aliases into canonical priority suppliers', () => {
    const discoveredSuppliers: DiscoveredSupplier[] = [
      {
        domain: 'mcmaster-carr.com',
        displayName: 'McMaster-Carr',
        emailCount: 2,
        score: 88,
        category: 'industrial',
        sampleSubjects: ['Order A'],
        isRecommended: true,
      },
      {
        domain: 'mcmaster.com',
        displayName: 'McMaster',
        emailCount: 3,
        score: 80,
        category: 'industrial',
        sampleSubjects: ['Order B'],
        isRecommended: true,
      },
      {
        domain: 'fastenal.com',
        displayName: 'Fastenal',
        emailCount: 4,
        score: 75,
        category: 'industrial',
        sampleSubjects: ['Fastenal Order'],
        isRecommended: true,
      },
    ];

    const merged = mergeSuppliers(OTHER_PRIORITY_SUPPLIERS, discoveredSuppliers, {
      canonicalizeDomain: canonicalizePrioritySupplierDomain,
    });

    const mcmaster = merged.find((supplier) => supplier.domain === 'mcmaster.com');
    expect(mcmaster).toBeDefined();
    expect(mcmaster?.emailCount).toBe(5);
    expect(mcmaster?.sampleSubjects).toEqual(expect.arrayContaining(['Order A', 'Order B']));

    const selectableOtherSuppliers = merged.filter(
      (supplier) => !isPrioritySupplierDomain(supplier.domain) && !supplier.domain.includes('amazon'),
    );
    expect(selectableOtherSuppliers.map((supplier) => supplier.domain)).toEqual(['fastenal.com']);
  });
});

```

### `src/utils/exportUtils.ts`

```typescript
import { ItemVelocityProfile, ExtractedOrder } from '../types';

/**
 * Escapes a CSV field value by wrapping in quotes if necessary
 * and escaping internal quotes by doubling them.
 */
function escapeCSVValue(value: string | number | undefined | null): string {
  if (value === null || value === undefined) {
    return '';
  }
  
  const str = String(value);
  
  // If the value contains comma, quote, or newline, wrap in quotes
  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
    // Escape quotes by doubling them
    return `"${str.replace(/"/g, '""')}"`;
  }
  
  return str;
}

/**
 * Formats a date string for CSV export (ISO date format: YYYY-MM-DD)
 */
function formatDateForCSV(dateString: string | undefined | null): string {
  if (!dateString) {
    return '';
  }
  
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) {
      return dateString; // Return original if invalid
    }
    return date.toISOString().split('T')[0]; // YYYY-MM-DD format
  } catch {
    return dateString;
  }
}

/**
 * Formats a date string for CSV export with time (YYYY-MM-DD HH:MM:SS)
 */
function formatDateTimeForCSV(dateString: string | undefined | null): string {
  if (!dateString) {
    return '';
  }
  
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) {
      return dateString; // Return original if invalid
    }
    const datePart = date.toISOString().split('T')[0];
    const timePart = date.toTimeString().split(' ')[0];
    return `${datePart} ${timePart}`;
  } catch {
    return dateString;
  }
}

/**
 * Helper function to trigger a browser download of CSV content
 */
export function downloadCSV(filename: string, csvContent: string): void {
  // Create a blob with the CSV content
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  
  // Create a temporary URL for the blob
  const url = URL.createObjectURL(blob);
  
  // Create a temporary anchor element and trigger download
  const link = document.createElement('a');
  link.href = url;
  link.download = filename.endsWith('.csv') ? filename : `${filename}.csv`;
  link.style.display = 'none';
  
  // Append to body, click, and remove
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up the URL after a short delay
  setTimeout(() => URL.revokeObjectURL(url), 100);
}

/**
 * Exports velocity profiles to CSV format
 * Columns: Item Name, Supplier, SKU, Total Ordered, Order Count, Avg Cadence Days, Daily Burn Rate, Recommended Min, Recommended Order Qty, Next Predicted Order
 */
export function exportVelocityToCSV(profiles: ItemVelocityProfile[]): void {
  // CSV Headers
  const headers = [
    'Item Name',
    'Supplier',
    'SKU',
    'Total Ordered',
    'Order Count',
    'Avg Cadence Days',
    'Daily Burn Rate',
    'Recommended Min',
    'Recommended Order Qty',
    'Next Predicted Order'
  ];
  
  // Build CSV rows
  const rows: string[] = [];
  
  // Add header row
  rows.push(headers.map(escapeCSVValue).join(','));
  
  // Add data rows
  for (const profile of profiles) {
    const row = [
      profile.displayName || profile.normalizedName,
      profile.supplier,
      profile.sku || '',
      profile.totalQuantityOrdered,
      profile.orderCount,
      profile.averageCadenceDays.toFixed(2),
      profile.dailyBurnRate.toFixed(4),
      profile.recommendedMin.toFixed(2),
      profile.recommendedOrderQty.toFixed(2),
      profile.nextPredictedOrder ? formatDateForCSV(profile.nextPredictedOrder) : ''
    ];
    
    rows.push(row.map(escapeCSVValue).join(','));
  }
  
  const csvContent = rows.join('\n');
  downloadCSV('velocity-profiles', csvContent);
}

/**
 * Exports orders to CSV format
 * Columns: Order ID, Email ID, Supplier, Date, Total Amount, Item Count, Item Names
 */
export function exportOrdersToCSV(orders: ExtractedOrder[]): void {
  // CSV Headers
  const headers = [
    'Order ID',
    'Email ID',
    'Supplier',
    'Date',
    'Total Amount',
    'Item Count',
    'Item Names'
  ];
  
  // Build CSV rows
  const rows: string[] = [];
  
  // Add header row
  rows.push(headers.map(escapeCSVValue).join(','));
  
  // Add data rows
  for (const order of orders) {
    // Collect item names, handling multiple items
    const itemNames = order.items.map(item => item.name).join('; ');
    
    const row = [
      order.id,
      order.originalEmailId,
      order.supplier,
      formatDateTimeForCSV(order.orderDate),
      order.totalAmount !== undefined ? order.totalAmount.toFixed(2) : '',
      order.items.length,
      itemNames
    ];
    
    rows.push(row.map(escapeCSVValue).join(','));
  }
  
  const csvContent = rows.join('\n');
  downloadCSV('orders', csvContent);
}

export interface ItemExportRow {
  source?: string;
  name: string;
  supplier?: string;
  description?: string;
  location?: string;
  orderMethod?: string;
  minQty?: number;
  orderQty?: number;
  unitPrice?: number;
  sku?: string;
  barcode?: string;
  asin?: string;
  productUrl?: string;
  imageUrl?: string;
  color?: string;
}

export function exportItemsToCSV(items: ItemExportRow[], filenamePrefix = 'items-export'): void {
  const headers = [
    'Source',
    'Item Name',
    'Supplier',
    'Description',
    'Location',
    'Order Method',
    'Min Qty',
    'Order Qty',
    'Unit Price',
    'SKU',
    'Barcode',
    'ASIN',
    'Product URL',
    'Image URL',
    'Color',
  ];

  const rows: string[] = [];
  rows.push(headers.map(escapeCSVValue).join(','));

  for (const item of items) {
    const row = [
      item.source || '',
      item.name,
      item.supplier || '',
      item.description || '',
      item.location || '',
      item.orderMethod || '',
      item.minQty ?? '',
      item.orderQty ?? '',
      item.unitPrice ?? '',
      item.sku || '',
      item.barcode || '',
      item.asin || '',
      item.productUrl || '',
      item.imageUrl || '',
      item.color || '',
    ];
    rows.push(row.map(escapeCSVValue).join(','));
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const csvContent = rows.join('\n');
  downloadCSV(`${filenamePrefix}-${timestamp}`, csvContent);
}

```

### `src/utils/inventoryLogic.ts`

```typescript
import { 
  ExtractedOrder, 
  InventoryItem, 
  ItemVelocityProfile,
  JourneyNode,
  RawEmail,
  LineItem
} from '../types';

// ============================================
// ITEM NAME NORMALIZATION SERVICE
// ============================================

/**
 * Normalizes item names for cross-order matching
 * Handles common variations like:
 * - Case differences
 * - Extra whitespace
 * - Common suffixes/prefixes
 * - Part number variations
 * - Product codes in parentheses/brackets
 * - Size/quantity patterns
 * - Common abbreviations
 */
export const normalizeItemName = (name: string): string => {
  const normalized = name
    .toLowerCase()
    .trim()
    // Normalize dashes and underscores to spaces
    .replace(/[-_]/g, ' ')
    // Normalize multiple spaces to single space
    .replace(/\s+/g, ' ')
    // Remove common prefixes
    .replace(/^(the|a|an)\s+/i, '')
    // Remove product codes in parentheses or brackets (e.g., "Item (SKU-12345)", "Item [ABC-123]")
    .replace(/\s*[([[][^\])]*[\])]\s*/g, '')
    // Remove common size/quantity patterns (e.g., "100 pack", "box of 50", "50ct", "12pk")
    .replace(/\b\d+\s*(pack|box|case|bag|ct|pk|count|each|ea|unit|units|pcs|pieces)\b/gi, '')
    .replace(/\b(box|case|pack|bag)\s+of\s+\d+\b/gi, '')
    // Normalize common abbreviations
    .replace(/\bea\.?\b/gi, 'ea')
    .replace(/\bpkg\.?\b/gi, 'pack')
    .replace(/\bpcs?\.?\b/gi, 'pieces')
    .replace(/\bct\.?\b/gi, 'count')
    .replace(/\bpk\.?\b/gi, 'pack')
    // Remove common suffixes
    .replace(/\s*[-–]\s*(pack|box|case|bag|each|ea|pk|ct|count|unit|units)\s*$/i, '')
    // Remove trailing punctuation
    .replace(/[.,;:!?]+$/g, '')
    // Final whitespace normalization
    .replace(/\s+/g, ' ')
    .trim();
  
  return normalized;
};

const normalizePackSizeValue = (value: number | null | undefined): number | null => {
  if (!Number.isFinite(value)) return null;
  const rounded = Math.round(Number(value));
  if (rounded <= 1 || rounded > 10000) return null;
  return rounded;
};

/**
 * Extract pack size from product text (title, description, etc.)
 * Uses multiple patterns to catch various formats like:
 * - "100 Pack", "100-Pack", "100pk", "100 ct", "100 count"
 * - "Pack of 100", "Box of 50", "Case of 24"
 * - "(100 Count)", "[50 Pack]"
 * - "100 Sheets", "500 Envelopes", "24 Rolls"
 * - "12-Pack", "6 Pack", "24pk"
 * - Quantity x Size like "2 x 100 count"
 */
const parsePackSizeFromText = (text?: string): number | null => {
  if (!text) return null;
  
  const patterns = [
    // "100 Pack", "100-Pack", "100pk", "100 ct", "100 count", "100 pcs"
    /\b(\d+)\s*[-\s]?(?:pack|pk|ct|count|pcs|pieces|units|unit|sheets|rolls|envelopes|bags|boxes|pairs)\b/i,
    
    // "Pack of 100", "Box of 50", "Case of 24", "Set of 12"
    /\b(?:pack|box|case|bag|set|bundle)\s+of\s+(\d+)\b/i,
    
    // Parenthetical: "(100 Count)", "(50 Pack)", "[24 ct]"
    /[([](\d+)\s*(?:count|ct|pack|pk|pcs|pieces)[)\]]/i,
    
    // "100-ct", "50-pk", "24-pack"
    /\b(\d+)\s*[-](?:ct|pk|pack|count)\b/i,
    
    // "Qty: 100", "Quantity: 50"
    /\b(?:qty|quantity)[:\s]+(\d+)\b/i,
    
    // "2 x 100 count" or "3x50 pack" - multiply these
    /\b(\d+)\s*x\s*(\d+)\s*(?:count|ct|pack|pk|pcs)?\b/i,
    
    // Comma-separated large numbers like "1,000 Count"
    /\b(\d{1,3}(?:,\d{3})+)\s*(?:count|ct|pack|pk|pcs|pieces|sheets)\b/i,
    
    // Just "100 Count" at end of title
    /\b(\d+)\s+(?:count|sheets|rolls|wipes|tablets|capsules|pills)\s*$/i,
    
    // "12/Pack" or "24/Case" format
    /\b(\d+)\s*\/\s*(?:pack|case|box|bag)\b/i,
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      // Handle "2 x 100" multiplication pattern
      if (match[2] && pattern.source.includes('x')) {
        const multiplied = parseInt(match[1], 10) * parseInt(match[2], 10);
        const normalized = normalizePackSizeValue(multiplied);
        if (normalized) return normalized;
      }
      
      // Handle comma-separated numbers like "1,000"
      let valueStr = match[1];
      if (valueStr.includes(',')) {
        valueStr = valueStr.replace(/,/g, '');
      }
      
      const value = parseInt(valueStr, 10);
      const normalized = normalizePackSizeValue(value);
      if (normalized) return normalized;
    }
  }
  return null;
};

/**
 * Extract pack size from price string (e.g., "$0.05/Count" means per-unit pricing)
 * If we see per-unit pricing and have total price, we can derive pack size
 */
const parsePackSizeFromPrice = (priceStr?: string, totalPrice?: number): number | null => {
  if (!priceStr) return null;
  
  // Look for per-unit pricing like "$0.05/Count" or "$1.25/ea"
  const perUnitMatch = priceStr.match(/\$?([\d.]+)\s*\/\s*(?:count|ct|ea|each|unit|piece)/i);
  if (perUnitMatch && totalPrice) {
    const perUnitPrice = parseFloat(perUnitMatch[1]);
    if (perUnitPrice > 0) {
      const estimatedCount = Math.round(totalPrice / perUnitPrice);
      return normalizePackSizeValue(estimatedCount);
    }
  }
  
  // Look for "($0.05/Count)" format common in Amazon titles
  const parentheticalMatch = priceStr.match(/\(\$?([\d.]+)\s*\/\s*(?:count|ct|ea|each)\)/i);
  if (parentheticalMatch && totalPrice) {
    const perUnitPrice = parseFloat(parentheticalMatch[1]);
    if (perUnitPrice > 0) {
      const estimatedCount = Math.round(totalPrice / perUnitPrice);
      return normalizePackSizeValue(estimatedCount);
    }
  }
  
  return null;
};

/**
 * Get pack size for an item using multiple fallback sources:
 * 1. Amazon API unitCount field
 * 2. Parse from Amazon item title
 * 3. Parse from original item name
 * 4. Parse from price string (per-unit pricing)
 * 5. Parse from humanized name
 * 6. Default to 1
 */
const getPackSizeForItem = (item: LineItem): number => {
  const amazon = item.amazonEnriched;
  
  // 1. Try Amazon API unitCount field first (most reliable)
  const amazonUnitCount = normalizePackSizeValue(
    typeof amazon?.unitCount === 'string'
      ? parseFloat(amazon.unitCount)
      : amazon?.unitCount
  );
  if (amazonUnitCount) return amazonUnitCount;
  
  // 2. Parse from Amazon item title (often contains "100 Count", "50 Pack", etc.)
  const fromAmazonTitle = parsePackSizeFromText(amazon?.itemName);
  if (fromAmazonTitle) return fromAmazonTitle;
  
  // 3. Parse from original item name
  const fromOriginalName = parsePackSizeFromText(item.name);
  if (fromOriginalName) return fromOriginalName;
  
  // 4. Try to derive from per-unit pricing in Amazon price string
  const fromPrice = parsePackSizeFromPrice(amazon?.price, item.unitPrice);
  if (fromPrice) return fromPrice;
  
  // 5. Parse from humanized name (LLM-generated)
  const fromHumanizedName = parsePackSizeFromText(amazon?.humanizedName);
  if (fromHumanizedName) return fromHumanizedName;
  
  // 6. Default fallback
  return 1;
};

const roundUpToMultiple = (value: number, multiple: number): number => {
  if (multiple <= 1) return Math.ceil(value);
  const rounded = Math.ceil(value / multiple) * multiple;
  return Math.max(rounded, multiple);
};

/**
 * Calculate simple string similarity using Levenshtein-like distance
 * Returns a value between 0 (identical) and 1 (completely different)
 */
const calculateSimilarity = (str1: string, str2: string): number => {
  const len1 = str1.length;
  const len2 = str2.length;
  
  // If one string is empty, return 0 if both empty, 1 otherwise
  if (len1 === 0) return len2 === 0 ? 0 : 1;
  if (len2 === 0) return 1;
  
  // If strings are identical, return 0
  if (str1 === str2) return 0;
  
  // Check prefix match (first 3+ characters)
  const prefixLen = Math.min(3, Math.min(len1, len2));
  if (prefixLen >= 3 && str1.substring(0, prefixLen) === str2.substring(0, prefixLen)) {
    // If prefix matches, use a simpler comparison
    const longer = Math.max(len1, len2);
    const shorter = Math.min(len1, len2);
    const diff = longer - shorter;
    
    // Count character differences in overlapping portion
    let differences = 0;
    for (let i = 0; i < shorter; i++) {
      if (str1[i] !== str2[i]) differences++;
    }
    
    // Normalize: differences + length difference
    return (differences + diff) / longer;
  }
  
  // Simple Levenshtein distance calculation
  const matrix: number[][] = [];
  
  for (let i = 0; i <= len1; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= len2; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,      // deletion
        matrix[i][j - 1] + 1,      // insertion
        matrix[i - 1][j - 1] + cost  // substitution
      );
    }
  }
  
  const distance = matrix[len1][len2];
  const maxLen = Math.max(len1, len2);
  return maxLen === 0 ? 0 : distance / maxLen;
};

/**
 * Find similar items using fuzzy matching
 * Returns profiles with normalized names similar to the given normalized name
 * Uses string similarity and prefix matching
 */
export const findSimilarItems = (
  normalizedName: string,
  profiles: Map<string, ItemVelocityProfile>
): ItemVelocityProfile[] => {
  const similar: Array<{ profile: ItemVelocityProfile; similarity: number }> = [];
  const threshold = 0.3; // Consider items similar if similarity score <= 0.3 (70%+ match)
  
  profiles.forEach((profile, key) => {
    // Skip exact matches
    if (key === normalizedName) return;
    
    const similarity = calculateSimilarity(normalizedName, key);
    
    if (similarity <= threshold) {
      similar.push({ profile, similarity });
    }
  });
  
  // Sort by similarity (most similar first)
  similar.sort((a, b) => a.similarity - b.similarity);
  
  return similar.map(item => item.profile);
};

/**
 * Extract SKU/part number from item name if present
 */
export const extractSku = (name: string): string | undefined => {
  // Common SKU patterns: alphanumeric codes, often with dashes
  const skuPatterns = [
    /\b([A-Z]{2,4}[-]?\d{4,})\b/i,  // e.g., MCM-12345, AB1234
    /\b(\d{5,}[-A-Z]*)\b/,          // e.g., 91255A123
    /\b([A-Z]\d{2}[-]\d{4})\b/i,    // e.g., M10-1234
    /#\s*(\w+)/,                     // e.g., #12345
  ];
  
  for (const pattern of skuPatterns) {
    const match = name.match(pattern);
    if (match) {
      return match[1].toUpperCase();
    }
  }
  return undefined;
};

/**
 * Enrich line items with IDs, normalized names, and source tracking
 */
export const enrichLineItems = (
  orders: ExtractedOrder[]
): ExtractedOrder[] => {
  return orders.map(order => ({
    ...order,
    items: order.items.map((item, idx) => ({
      ...item,
      id: item.id || `${order.id}-item-${idx}`,
      sourceEmailId: order.originalEmailId,
      sourceOrderId: order.id,
      normalizedName: item.normalizedName || normalizeItemName(item.name),
      sku: item.sku || extractSku(item.name),
    })),
  }));
};

// ============================================
// VELOCITY PROFILE CALCULATION
// ============================================

/**
 * Build velocity profiles for all unique items across orders
 */
export const buildVelocityProfiles = (
  orders: ExtractedOrder[]
): Map<string, ItemVelocityProfile> => {
  const profileMap = new Map<string, ItemVelocityProfile>();
  
  // Enrich orders first
  const enrichedOrders = enrichLineItems(orders);
  
  enrichedOrders.forEach(order => {
    order.items.forEach(item => {
      const normalizedName = item.normalizedName || normalizeItemName(item.name);
      const amazonData = item.amazonEnriched;
      const packSize = getPackSizeForItem(item);
      
      // Use humanized name > enriched name > original name
      const displayName = amazonData?.humanizedName || amazonData?.itemName || item.name;
      
      if (!profileMap.has(normalizedName)) {
        profileMap.set(normalizedName, {
          normalizedName,
          displayName,
          supplier: order.supplier,
          sku: item.sku,
          // Amazon enrichment
          asin: item.asin,
          imageUrl: amazonData?.imageUrl,
          amazonUrl: amazonData?.amazonUrl,
          packSize,
          // Initialize other fields
          orders: [],
          totalQuantityOrdered: 0,
          orderCount: 0,
          averageCadenceDays: 0,
          dailyBurnRate: 0,
          firstOrderDate: order.orderDate,
          lastOrderDate: order.orderDate,
          recommendedMin: 0,
          recommendedOrderQty: 0,
        });
      } else {
        // Update Amazon data if we have it now but didn't before
        const profile = profileMap.get(normalizedName)!;
        if (!profile.imageUrl && amazonData?.imageUrl) {
          profile.imageUrl = amazonData.imageUrl;
        }
        if (!profile.amazonUrl && amazonData?.amazonUrl) {
          profile.amazonUrl = amazonData.amazonUrl;
        }
        if (!profile.asin && item.asin) {
          profile.asin = item.asin;
        }
        if (!profile.packSize || (packSize > 1 && profile.packSize === 1)) {
          profile.packSize = packSize;
        }
        // Update displayName - prefer humanized > enriched
        if (amazonData?.humanizedName && profile.displayName !== amazonData.humanizedName) {
          profile.displayName = amazonData.humanizedName;
        } else if (amazonData?.itemName && !amazonData.humanizedName && profile.displayName !== amazonData.itemName) {
          profile.displayName = amazonData.itemName;
        }
      }
      
      const profile = profileMap.get(normalizedName)!;
      const effectiveQuantity = item.quantity * packSize;
      
      // Add order occurrence
      profile.orders.push({
        orderId: order.id,
        emailId: order.originalEmailId,
        date: order.orderDate,
        quantity: effectiveQuantity,
        unitPrice: item.unitPrice,
      });
      
      profile.totalQuantityOrdered += effectiveQuantity;
      
      // Update dates
      if (new Date(order.orderDate) < new Date(profile.firstOrderDate)) {
        profile.firstOrderDate = order.orderDate;
      }
      if (new Date(order.orderDate) > new Date(profile.lastOrderDate)) {
        profile.lastOrderDate = order.orderDate;
      }
    });
  });
  
  // Calculate analytics for each profile
  profileMap.forEach(profile => {
    // Count unique orders (dedupe by orderId)
    const uniqueOrderIds = new Set(profile.orders.map(o => o.orderId));
    profile.orderCount = uniqueOrderIds.size;
    
    // Sort orders by date
    profile.orders.sort((a, b) => 
      new Date(a.date).getTime() - new Date(b.date).getTime()
    );
    
    const firstDate = new Date(profile.firstOrderDate);
    const lastDate = new Date(profile.lastOrderDate);
    const daySpan = (lastDate.getTime() - firstDate.getTime()) / (1000 * 3600 * 24);
    
    // Calculate cadence
    if (profile.orderCount > 1 && daySpan > 0) {
      profile.averageCadenceDays = daySpan / (profile.orderCount - 1);
    } else {
      profile.averageCadenceDays = 30; // Default
    }
    
    // Calculate burn rate
    const effectiveSpan = daySpan === 0 ? 30 : daySpan;
    profile.dailyBurnRate = profile.totalQuantityOrdered / effectiveSpan;
    
    // ==============================================
    // ReLoWiSa Kanban Calculation (Bosch TPS/Lean)
    // ==============================================
    // ReLoWiSa = Reichweite (Range) + Losgroße (Lot) + Wiederbeschaffungszeit (Lead Time) + Sicherheit (Safety)
    // For one-card, two-bin system:
    //   - Bin 1 (working stock) = Daily usage × Lead time
    //   - Bin 2 (safety/reorder stock) = Daily usage × Lead time × Safety factor
    //   - Order Qty (NPK) = Pack size from supplier
    //
    // Takt time = 1 / dailyBurnRate (days per unit)
    // NPK = Pack size from Amazon enrichment
    
    const packSize = profile.packSize || 1; // NPK - Normal Pack Quantity
    const leadTimeDays = 3; // Default assumed lead time (could be enhanced with actual data)
    const safetyFactor = 0.5; // 50% safety stock
    
    // Calculate minimum quantity (trigger point for reorder)
    // Min = Usage during lead time + Safety stock
    const usageDuringLeadTime = profile.dailyBurnRate * leadTimeDays;
    const safetyStock = usageDuringLeadTime * safetyFactor;
    const rawMinQty = usageDuringLeadTime + safetyStock;
    
    // Round up to pack size for practical ordering
    profile.recommendedMin = roundUpToMultiple(rawMinQty, packSize);
    
    // Two-bin system: reorder quantity should fully refill the empty bin.
    // That equals the reorder point (recommendedMin), already rounded to pack size.
    profile.recommendedOrderQty = profile.recommendedMin;
    
    // Predict next order date
    if (profile.orderCount >= 2) {
      const lastOrderDate = new Date(profile.lastOrderDate);
      const nextOrderDate = new Date(
        lastOrderDate.getTime() + profile.averageCadenceDays * 24 * 60 * 60 * 1000
      );
      profile.nextPredictedOrder = nextOrderDate.toISOString().split('T')[0];
    }
  });
  
  return profileMap;
};

// ============================================
// JOURNEY TREE BUILDER
// ============================================

/**
 * Build a hierarchical journey tree from emails and orders
 * Structure: Email -> Order -> LineItems -> Velocity
 */
export const buildJourneyTree = (
  orders: ExtractedOrder[],
  emails?: RawEmail[]
): JourneyNode[] => {
  const velocityProfiles = buildVelocityProfiles(orders);
  const enrichedOrders = enrichLineItems(orders);
  
  // Group orders by email
  const ordersByEmail = new Map<string, ExtractedOrder[]>();
  enrichedOrders.forEach(order => {
    const emailId = order.originalEmailId;
    if (!ordersByEmail.has(emailId)) {
      ordersByEmail.set(emailId, []);
    }
    ordersByEmail.get(emailId)!.push(order);
  });
  
  // Build tree nodes
  const tree: JourneyNode[] = [];
  
  ordersByEmail.forEach((ordersForEmail, emailId) => {
    // Find email info if available
    const email = emails?.find(e => e.id === emailId);
    const firstOrder = ordersForEmail[0];
    
    const emailNode: JourneyNode = {
      id: `email-${emailId}`,
      type: 'email',
      label: email?.sender || firstOrder?.supplier || 'Unknown Source',
      subtitle: email?.subject || `${ordersForEmail.length} order(s)`,
      isExpanded: true,
      data: {
        emailId,
        sender: email?.sender || firstOrder?.supplier || '',
        subject: email?.subject || '',
        date: email?.date || firstOrder?.orderDate || '',
      },
      children: ordersForEmail.map(order => {
        const orderNode: JourneyNode = {
          id: `order-${order.id}`,
          type: 'order',
          label: `Order from ${order.supplier}`,
          subtitle: `$${(order.totalAmount || 0).toFixed(2)} • ${order.items.length} items`,
          isExpanded: true,
          data: {
            orderId: order.id,
            emailId: order.originalEmailId,
            supplier: order.supplier,
            orderDate: order.orderDate,
            totalAmount: order.totalAmount,
            itemCount: order.items.length,
            confidence: order.confidence,
          },
          children: order.items.map((item, idx) => {
            const normalizedName = item.normalizedName || normalizeItemName(item.name);
            const velocityProfile = velocityProfiles.get(normalizedName);
            
            const displayName = item.amazonEnriched?.itemName || item.name;
            const unitPrice = item.unitPrice;
            const totalPrice = unitPrice ? unitPrice * item.quantity : undefined;
            const lineItemNode: JourneyNode = {
              id: item.id || `${order.id}-item-${idx}`,
              type: 'lineItem',
              label: displayName,
              subtitle: `Qty: ${item.quantity} ${item.unit}${unitPrice ? ` • $${unitPrice.toFixed(2)}/ea` : ''}${totalPrice ? ` • $${totalPrice.toFixed(2)} total` : ''}`,
              isExpanded: false,
              data: {
                lineItemId: item.id || `${order.id}-item-${idx}`,
                orderId: order.id,
                emailId: order.originalEmailId,
                name: displayName,
                normalizedName,
                quantity: item.quantity,
                unit: item.unit,
                unitPrice: unitPrice,
                sku: item.sku,
                asin: item.asin,
                supplier: order.supplier,
                orderDate: order.orderDate,
                totalPrice,
                amazonEnriched: item.amazonEnriched,
              },
              children: velocityProfile ? [{
                id: `velocity-${normalizedName}`,
                type: 'velocity',
                label: `${velocityProfile.dailyBurnRate.toFixed(1)}/day`,
                subtitle: `Cadence: ${Math.round(velocityProfile.averageCadenceDays)} days • ${velocityProfile.orderCount} orders`,
                data: {
                  normalizedName,
                  dailyBurnRate: velocityProfile.dailyBurnRate,
                  averageCadenceDays: velocityProfile.averageCadenceDays,
                  orderCount: velocityProfile.orderCount,
                  nextPredictedOrder: velocityProfile.nextPredictedOrder,
                },
              }] : [],
            };
            
            return lineItemNode;
          }),
        };
        
        return orderNode;
      }),
    };
    
    tree.push(emailNode);
  });
  
  // Sort by date (most recent first)
  tree.sort((a, b) => {
    const dateA = (a.data as { date?: string })?.date || '';
    const dateB = (b.data as { date?: string })?.date || '';
    return new Date(dateB).getTime() - new Date(dateA).getTime();
  });
  
  return tree;
};

// ============================================
// ORIGINAL INVENTORY PROCESSING (PRESERVED)
// ============================================

export const processOrdersToInventory = (orders: ExtractedOrder[]): InventoryItem[] => {
  const itemMap = new Map<string, InventoryItem & { orderIds: Set<string>; packSize?: number }>();

  // 1. Group items by name, track unique orders
  orders.forEach(order => {
    order.items.forEach(lineItem => {
      // Normalize name (simple lowercasing and trimming for this demo)
      const key = lineItem.normalizedName || lineItem.name.trim().toLowerCase();
      
      // Use humanized name > Amazon enriched name > original name
      const amazonData = lineItem.amazonEnriched;
      const displayName = amazonData?.humanizedName || amazonData?.itemName || lineItem.name;
      const originalName = amazonData?.itemName || lineItem.name;
      
      const packSize = getPackSizeForItem(lineItem);
      const effectiveQuantity = lineItem.quantity * packSize;

      if (!itemMap.has(key)) {
        itemMap.set(key, {
          id: key,
          name: displayName,
          originalName: originalName !== displayName ? originalName : undefined,
          supplier: order.supplier,
          totalQuantityOrdered: 0,
          orderCount: 0, // This will count unique ORDERS containing this item
          firstOrderDate: order.orderDate,
          lastOrderDate: order.orderDate,
          averageCadenceDays: 0,
          dailyBurnRate: 0,
          recommendedMin: 0,
          recommendedOrderQty: 0,
          lastPrice: lineItem.unitPrice || 0,
          history: [],
          orderIds: new Set<string>(), // Track unique order IDs
          packSize,
          // Amazon enrichment fields
          imageUrl: amazonData?.imageUrl,
          productUrl: amazonData?.amazonUrl,
        });
      }

      const entry = itemMap.get(key)!;
      if (!entry.packSize || (packSize > 1 && entry.packSize === 1)) {
        entry.packSize = packSize;
      }
      
      // Update basic stats
      entry.totalQuantityOrdered += effectiveQuantity;
      
      // Track unique orders - an item may appear multiple times in one order
      entry.orderIds.add(order.id);
      
      // Update dates
      if (new Date(order.orderDate) < new Date(entry.firstOrderDate)) entry.firstOrderDate = order.orderDate;
      if (new Date(order.orderDate) > new Date(entry.lastOrderDate)) entry.lastOrderDate = order.orderDate;
      
      // Update price
      if (lineItem.unitPrice) entry.lastPrice = lineItem.unitPrice;
      
      // Update Amazon enrichment if we have it now but didn't before
      if (!entry.imageUrl && amazonData?.imageUrl) {
        entry.imageUrl = amazonData.imageUrl;
      }
      if (!entry.productUrl && amazonData?.amazonUrl) {
        entry.productUrl = amazonData.amazonUrl;
      }
      // Update names - prefer humanized > enriched > original
      if (amazonData?.humanizedName && entry.name !== amazonData.humanizedName) {
        entry.originalName = entry.name;
        entry.name = amazonData.humanizedName;
      } else if (amazonData?.itemName && entry.name !== amazonData.itemName && !amazonData.humanizedName) {
        entry.name = amazonData.itemName;
      }

      // Add to history (one entry per line item occurrence)
      entry.history.push({ date: order.orderDate, quantity: effectiveQuantity });
    });
  });

  // 2. Calculate Analytics
  return Array.from(itemMap.values()).map(item => {
    // Count unique orders containing this item
    item.orderCount = item.orderIds.size;
    
    // Sort history by date
    item.history.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    const firstDate = new Date(item.firstOrderDate);
    const lastDate = new Date(item.lastOrderDate);
    const daySpan = (lastDate.getTime() - firstDate.getTime()) / (1000 * 3600 * 24);

    // Calc Cadence (Average days between orders)
    // Needs at least 2 orders to calculate cadence
    if (item.orderCount > 1 && daySpan > 0) {
      item.averageCadenceDays = daySpan / (item.orderCount - 1);
    } else {
      item.averageCadenceDays = 30; // Default assumption if not enough data
    }

    // Calc Burn Rate (Units per day)
    // If span is 0 (single day), assume 30 day usage for the total qty
    const effectiveSpan = daySpan === 0 ? 30 : daySpan;
    item.dailyBurnRate = item.totalQuantityOrdered / effectiveSpan;

    // ==============================================
    // ReLoWiSa Kanban Calculation (Bosch TPS/Lean)
    // ==============================================
    // For one-card, two-bin kanban system
    const itemPackSize = item.packSize || 1; // NPK from Amazon
    const leadTimeDays = 3; // Default lead time
    const safetyFactor = 0.5; // 50% safety stock
    
    const usageDuringLeadTime = item.dailyBurnRate * leadTimeDays;
    const safetyStock = usageDuringLeadTime * safetyFactor;
    const rawMinQty = usageDuringLeadTime + safetyStock;
    
    item.recommendedMin = roundUpToMultiple(rawMinQty, itemPackSize);
    // Two-bin: refill one bin; order qty equals the (pack-rounded) minimum.
    item.recommendedOrderQty = item.recommendedMin;

    // Clean up temp field before returning - destructure to remove internal fields
    const { orderIds: _ids, packSize: _ps, ...cleanItem } = item;
    void _ids; void _ps; // Mark as intentionally unused
    return cleanItem as InventoryItem;
  });
};

```

### `src/utils/masterListItems.ts`

```typescript
import type { MasterListItem } from '../components/ItemsTable/types';
import { DEFAULT_ORDER_METHOD_BY_SOURCE } from '../components/ItemsTable/types';
import type { EmailItem } from '../components/ItemsTable/types';
import type { UrlScrapedItem } from '../services/api';
import type { ScannedBarcode, CapturedPhoto } from '../views/OnboardingFlow';
import type { CSVItem } from '../views/CSVUploadStep';

export function buildMasterListItems(
  emailItems: EmailItem[],
  urlItems: UrlScrapedItem[],
  scannedBarcodes: ScannedBarcode[],
  capturedPhotos: CapturedPhoto[],
  csvItems: CSVItem[],
): MasterListItem[] {
  const items: MasterListItem[] = [];

  emailItems.forEach(item => {
    items.push({
      id: item.id,
      source: 'email',
      orderMethod: DEFAULT_ORDER_METHOD_BY_SOURCE.email,
      name: item.name,
      supplier: item.supplier,
      location: item.location,
      asin: item.asin,
      minQty: item.recommendedMin,
      orderQty: item.recommendedOrderQty,
      unitPrice: item.lastPrice,
      imageUrl: item.imageUrl,
      productUrl: item.productUrl,
      needsAttention: !item.name || item.name.includes('Unknown'),
    });
  });

  urlItems.forEach((item) => {
    items.push({
      id: `url-${item.sourceUrl}`,
      source: 'url',
      orderMethod: DEFAULT_ORDER_METHOD_BY_SOURCE.url,
      name: item.itemName || 'Unknown item',
      description: item.description,
      supplier: item.supplier,
      sku: item.vendorSku,
      asin: item.asin,
      unitPrice: item.price,
      imageUrl: item.imageUrl,
      productUrl: item.productUrl || item.sourceUrl,
      needsAttention: item.needsReview || !item.itemName || !item.supplier,
    });
  });

  scannedBarcodes.forEach(barcode => {
    const existingByBarcode = items.find(i => i.barcode === barcode.barcode);
    if (!existingByBarcode) {
      items.push({
        id: `barcode-${barcode.id}`,
        source: 'barcode',
        orderMethod: DEFAULT_ORDER_METHOD_BY_SOURCE.barcode,
        name: barcode.productName || `Unknown (${barcode.barcode})`,
        barcode: barcode.barcode,
        imageUrl: barcode.imageUrl,
        needsAttention: !barcode.productName,
      });
    }
  });

  capturedPhotos.forEach(photo => {
    items.push({
      id: `photo-${photo.id}`,
      source: 'photo',
      orderMethod: DEFAULT_ORDER_METHOD_BY_SOURCE.photo,
      name: photo.suggestedName || 'Captured Item (analyzing...)',
      supplier: photo.suggestedSupplier,
      imageUrl: photo.imageData,
      needsAttention: !photo.suggestedName,
    });
  });

  csvItems.forEach(csvItem => {
    items.push({
      id: csvItem.id,
      source: 'csv',
      orderMethod: DEFAULT_ORDER_METHOD_BY_SOURCE.csv,
      name: csvItem.name,
      supplier: csvItem.supplier,
      location: csvItem.location,
      barcode: csvItem.barcode,
      sku: csvItem.sku,
      minQty: csvItem.minQty,
      orderQty: csvItem.orderQty,
      unitPrice: csvItem.unitPrice,
      productUrl: csvItem.productUrl,
      imageUrl: csvItem.imageUrl,
      color: csvItem.color,
      needsAttention: false,
    });
  });

  return items;
}

export function mergeMasterListItems(
  existing: MasterListItem[],
  incoming: MasterListItem[],
): MasterListItem[] {
  const newItems = [...existing];
  let hasChanges = false;

  for (const newItem of incoming) {
    const existingIndex = newItems.findIndex(i => i.id === newItem.id);
    if (existingIndex === -1) {
      newItems.push(newItem);
      hasChanges = true;
    } else {
      const existingItem = newItems[existingIndex];
      if (
        (!existingItem.name || existingItem.name.includes('analyzing'))
        && newItem.name && !newItem.name.includes('analyzing')
      ) {
        newItems[existingIndex] = {
          ...existingItem,
          name: newItem.name,
          supplier: newItem.supplier || existingItem.supplier,
          needsAttention: false,
        };
        hasChanges = true;
      }
    }
  }

  return hasChanges ? newItems : existing;
}

```

### `src/utils/supplierUtils.ts`

```typescript
import { DiscoveredSupplier } from '../services/api';

interface MergeSuppliersOptions {
  canonicalizeDomain?: (domain: string) => string;
}

function uniqueSampleSubjects(...groups: string[][]): string[] {
  const seen = new Set<string>();
  const merged: string[] = [];

  groups.flat().forEach((subject) => {
    if (!subject || seen.has(subject)) return;
    seen.add(subject);
    merged.push(subject);
  });

  return merged;
}

export function mergeSuppliers(
  prioritySuppliers: DiscoveredSupplier[],
  discoveredSuppliers: DiscoveredSupplier[],
  options?: MergeSuppliersOptions,
): DiscoveredSupplier[] {
  const canonicalizeDomain = options?.canonicalizeDomain ?? ((domain: string) => domain);
  const merged = new Map<string, DiscoveredSupplier>();
  const priorityDomains = new Set<string>();

  prioritySuppliers.forEach((supplier) => {
    const canonicalDomain = canonicalizeDomain(supplier.domain);
    priorityDomains.add(canonicalDomain);
    merged.set(canonicalDomain, { ...supplier, domain: canonicalDomain });
  });

  discoveredSuppliers
    .map((supplier) => ({
      ...supplier,
      domain: canonicalizeDomain(supplier.domain),
    }))
    .filter((supplier) => !supplier.domain.includes('amazon'))
    .forEach((supplier) => {
      if (merged.has(supplier.domain)) {
        const existing = merged.get(supplier.domain)!;
        merged.set(supplier.domain, {
          ...existing,
          emailCount: existing.emailCount + supplier.emailCount,
          score: Math.max(existing.score, supplier.score),
          category: existing.category !== 'unknown' ? existing.category : supplier.category,
          sampleSubjects: uniqueSampleSubjects(existing.sampleSubjects, supplier.sampleSubjects).slice(0, 5),
          isRecommended: existing.isRecommended || supplier.isRecommended,
        });
      } else {
        merged.set(supplier.domain, supplier);
      }
    });

  return Array.from(merged.values()).sort((a, b) => {
    const aPriority = priorityDomains.has(a.domain);
    const bPriority = priorityDomains.has(b.domain);
    if (aPriority && !bPriority) return -1;
    if (!aPriority && bPriority) return 1;
    return b.score - a.score;
  });
}

```

### `src/views/BarcodeScanStep.tsx`

```tsx
import { useState, useEffect, useRef, useCallback } from 'react';
import { Icons } from '../components/Icons';
import { ScannedBarcode } from './OnboardingFlow';
import { API_BASE_URL } from '../services/api';

interface BarcodeScanStepProps {
  sessionId: string;
  scannedBarcodes: ScannedBarcode[];
  onBarcodeScanned: (barcode: ScannedBarcode) => void;
  onComplete?: () => void;
  onBack?: () => void;
}

const BARCODE_TYPES: ScannedBarcode['barcodeType'][] = ['UPC-A', 'EAN-13', 'EAN-8', 'GTIN-14', 'UPC', 'EAN', 'unknown'];

// Generate QR code URL for mobile scanning page
const getMobileScanUrl = (sessionId: string): string => {
  const baseUrl = window.location.origin;
  return `${baseUrl}/scan/${sessionId}`;
};

export const BarcodeScanStep: React.FC<BarcodeScanStepProps> = ({
  sessionId,
  scannedBarcodes,
  onBarcodeScanned,
}) => {
  type EditableBarcodeField = 'productName' | 'barcode' | 'barcodeType' | 'brand' | 'category';

  const [scannerInput, setScannerInput] = useState('');
  const [isListening, setIsListening] = useState(true);
  const [recentScan, setRecentScan] = useState<string | null>(null);
  const [lookupStatus, setLookupStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
  const [savingBarcodeId, setSavingBarcodeId] = useState<string | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const scanTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const idCounterRef = useRef(0);
  const scannedBarcodesRef = useRef<ScannedBarcode[]>(scannedBarcodes);
  const dirtyFieldsByBarcodeIdRef = useRef<Map<string, Set<EditableBarcodeField>>>(new Map());
  const savingBarcodeIdRef = useRef<string | null>(null);

  useEffect(() => {
    scannedBarcodesRef.current = scannedBarcodes;
  }, [scannedBarcodes]);

  useEffect(() => {
    savingBarcodeIdRef.current = savingBarcodeId;
  }, [savingBarcodeId]);

  const markBarcodeDirty = useCallback((barcodeId: string, field: EditableBarcodeField) => {
    const current = dirtyFieldsByBarcodeIdRef.current.get(barcodeId);
    if (current) {
      current.add(field);
      return;
    }
    dirtyFieldsByBarcodeIdRef.current.set(barcodeId, new Set([field]));
  }, []);

  const clearBarcodeDirty = useCallback((barcodeId: string) => {
    dirtyFieldsByBarcodeIdRef.current.delete(barcodeId);
  }, []);

  const nextId = useCallback(() => {
    idCounterRef.current += 1;
    return `scan-${idCounterRef.current}`;
  }, []);

  const saveSessionBarcode = useCallback(async (item: ScannedBarcode): Promise<ScannedBarcode | null> => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/scan/session/${sessionId}/barcode`, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: item.id,
          data: item.barcode,
          timestamp: item.scannedAt,
          barcodeType: item.barcodeType,
          source: item.source,
          productName: item.productName,
          brand: item.brand,
          imageUrl: item.imageUrl,
          category: item.category,
        }),
      });
      if (!response.ok) return null;
      const data = await response.json();
      if (data?.barcode) return data.barcode as ScannedBarcode;
    } catch {
      // Keep UI responsive even if session persistence fails temporarily.
    }
    return null;
  }, [sessionId]);

  const persistBarcodeById = useCallback(async (barcodeId: string, override?: ScannedBarcode): Promise<void> => {
    const item = override || scannedBarcodesRef.current.find((entry) => entry.id === barcodeId);
    if (!item) return;

    const dirtyFields = dirtyFieldsByBarcodeIdRef.current.get(item.id);
    if (!dirtyFields || dirtyFields.size === 0) return;

    setSavingBarcodeId(item.id);
    try {
      const payload: Record<string, unknown> = {};

      if (dirtyFields.has('barcode')) payload.barcode = item.barcode;
      if (dirtyFields.has('barcodeType')) payload.barcodeType = item.barcodeType;
      if (dirtyFields.has('productName')) payload.productName = item.productName ?? '';
      if (dirtyFields.has('brand')) payload.brand = item.brand ?? '';
      if (dirtyFields.has('category')) payload.category = item.category ?? '';

      const response = await fetch(`${API_BASE_URL}/api/scan/session/${sessionId}/barcode/${encodeURIComponent(item.id)}`, {
        method: 'PUT',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!response.ok) return;
      const data = await response.json();
      if (data?.barcode) {
        const saved = data.barcode as ScannedBarcode;
        clearBarcodeDirty(item.id);
        clearBarcodeDirty(saved.id);
        onBarcodeScanned(saved);
      }
    } catch {
      // Ignore update failures; user edits remain in local onboarding state.
    } finally {
      setSavingBarcodeId((current) => (current === item.id ? null : current));
    }
  }, [clearBarcodeDirty, onBarcodeScanned, sessionId]);

  // Focus input for scanner when listening
  useEffect(() => {
    if (isListening && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isListening]);

  // Poll for session barcodes so desktop/mobile stay in sync.
  useEffect(() => {
    const syncBarcodes = async () => {
      try {
        const response = await fetch(`${API_BASE_URL}/api/scan/session/${sessionId}/barcodes`, {
          credentials: 'include',
        });
        if (!response.ok) return;
        const data = await response.json();
        if (!data.barcodes || !Array.isArray(data.barcodes)) return;
        const localBarcodes = scannedBarcodesRef.current;
        const currentlySavingId = savingBarcodeIdRef.current;

        data.barcodes.forEach((barcode: ScannedBarcode) => {
          const localMatch = localBarcodes.find((entry) => entry.id === barcode.id)
            || localBarcodes.find((entry) => entry.barcode === barcode.barcode);
          if (localMatch) {
            if (localMatch.id === currentlySavingId) return;
            const dirtyFields = dirtyFieldsByBarcodeIdRef.current.get(localMatch.id);
            if (dirtyFields && dirtyFields.size > 0) return;
          }
          onBarcodeScanned(barcode);
        });
      } catch {
        // Silently ignore polling errors.
      }
    };

    void syncBarcodes();
    const pollInterval = setInterval(() => {
      void syncBarcodes();
    }, 2000);

    return () => clearInterval(pollInterval);
  }, [sessionId, onBarcodeScanned]);

  // Detect barcode type from string
  const detectBarcodeType = useCallback((barcode: string): ScannedBarcode['barcodeType'] => {
    const digits = barcode.replace(/\D/g, '');
    if (digits.length === 12) return 'UPC-A';
    if (digits.length === 13) return 'EAN-13';
    if (digits.length === 8) return 'EAN-8';
    if (digits.length === 14) return 'GTIN-14';
    return 'unknown';
  }, []);

  // Look up product info from barcode
  const lookupBarcode = useCallback(async (barcode: string): Promise<{
    name: string;
    brand?: string;
    imageUrl?: string;
    category?: string;
  } | null> => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/barcode/lookup?code=${encodeURIComponent(barcode)}`, {
        credentials: 'include',
      });
      if (response.ok) {
        return await response.json();
      }
    } catch {
      // Ignore lookup errors
    }
    return null;
  }, []);

  // Process a scanned barcode
  const processBarcode = useCallback(async (barcode: string) => {
    const cleanBarcode = barcode.trim();
    if (!cleanBarcode) return;

    // Check for duplicates by code
    if (scannedBarcodes.some((entry) => entry.barcode === cleanBarcode)) {
      setRecentScan(`${cleanBarcode} (already scanned)`);
      setScannerInput('');
      return;
    }

    setLookupStatus('loading');
    setRecentScan(cleanBarcode);

    const scannedItem: ScannedBarcode = {
      id: nextId(),
      barcode: cleanBarcode,
      barcodeType: detectBarcodeType(cleanBarcode),
      scannedAt: new Date().toISOString(),
      source: 'desktop',
    };

    try {
      const productInfo = await lookupBarcode(cleanBarcode);
      if (productInfo) {
        scannedItem.productName = productInfo.name;
        scannedItem.brand = productInfo.brand;
        scannedItem.imageUrl = productInfo.imageUrl;
        scannedItem.category = productInfo.category;
      }
      setLookupStatus('success');
    } catch {
      setLookupStatus('error');
    }

    const persisted = await saveSessionBarcode(scannedItem);
    onBarcodeScanned(persisted || scannedItem);
    setScannerInput('');

    // Clear status after a delay
    setTimeout(() => {
      setLookupStatus('idle');
      setRecentScan(null);
    }, 2000);
  }, [detectBarcodeType, lookupBarcode, nextId, onBarcodeScanned, saveSessionBarcode, scannedBarcodes]);

  // Handle scanner input
  const handleScannerInput = useCallback((value: string) => {
    setScannerInput(value);

    if (scanTimeoutRef.current) {
      clearTimeout(scanTimeoutRef.current);
    }

    scanTimeoutRef.current = setTimeout(() => {
      if (value.length >= 8) {
        void processBarcode(value);
      }
    }, 100);
  }, [processBarcode]);

  const handleEditableItemChange = useCallback((
    item: ScannedBarcode,
    field: EditableBarcodeField,
    value: string,
  ) => {
    markBarcodeDirty(item.id, field);
    const next: ScannedBarcode = {
      ...item,
      [field]: value || undefined,
    };

    if (field === 'barcode') {
      next.barcode = value;
    }
    if (field === 'barcodeType') {
      next.barcodeType = (value as ScannedBarcode['barcodeType']) || 'unknown';
    }

    onBarcodeScanned(next);
  }, [markBarcodeDirty, onBarcodeScanned]);

  // Handle keyboard input
  const handleKeyDown = (event: React.KeyboardEvent) => {
    if (event.key === 'Enter') {
      event.preventDefault();
      if (scannerInput.length >= 8) {
        void processBarcode(scannerInput);
      }
    }
  };

  // Generate QR code as data URL
  const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(getMobileScanUrl(sessionId))}`;

  return (
    <div className="space-y-4">
      <div className="card-arda p-4 sm:p-5">
        <div className="grid grid-cols-1 lg:grid-cols-[minmax(0,1.3fr)_minmax(0,1fr)] gap-4 items-stretch">
          <div className="space-y-3">
            <div className="flex items-center gap-3">
              <div className="w-11 h-11 bg-orange-50 rounded-2xl flex items-center justify-center border border-orange-100">
                <Icons.Barcode className="w-5 h-5 text-arda-accent" />
              </div>
              <div>
                <h3 className="font-semibold text-arda-text-primary">Barcode scanner</h3>
                <p className="text-sm text-arda-text-secondary">Use a USB or Bluetooth scanner</p>
              </div>
            </div>

            <div className="relative">
              <input
                ref={inputRef}
                type="text"
                value={scannerInput}
                onChange={(event) => handleScannerInput(event.target.value)}
                onKeyDown={handleKeyDown}
                placeholder={isListening ? 'Scan a barcode...' : 'Click to enable scanning'}
                className={[
                  'input-arda font-mono text-lg',
                  'pr-10',
                  isListening ? 'bg-orange-50 ring-2 ring-arda-accent border-transparent' : '',
                ].join(' ')}
                onFocus={() => setIsListening(true)}
                onBlur={() => setTimeout(() => setIsListening(false), 200)}
              />
              {isListening && (
                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                  <div className="w-3 h-3 bg-arda-accent rounded-full animate-pulse" />
                </div>
              )}
            </div>

            {recentScan && (
              <div className={[
                'flex items-center gap-2 px-3 py-2 rounded-xl text-sm border',
                lookupStatus === 'loading' ? 'bg-orange-50 text-orange-700 border-orange-200' : '',
                lookupStatus === 'success' ? 'bg-green-50 text-green-700 border-green-200' : '',
                lookupStatus === 'error' ? 'bg-red-50 text-red-700 border-red-200' : '',
                lookupStatus === 'idle' ? 'bg-arda-bg-secondary text-arda-text-secondary border-arda-border' : '',
              ].join(' ')}>
                {lookupStatus === 'loading' && <Icons.Loader2 className="w-4 h-4 animate-spin" />}
                {lookupStatus === 'success' && <Icons.CheckCircle2 className="w-4 h-4" />}
                {lookupStatus === 'error' && <Icons.AlertCircle className="w-4 h-4" />}
                <span className="font-mono">{recentScan}</span>
              </div>
            )}

            <p className="text-xs text-arda-text-muted">
              Keep focus in the input while scanning. Each row below is fully editable.
            </p>
          </div>

          <div className="space-y-3 lg:border-l lg:border-arda-border lg:pl-4">
            <div className="flex items-center gap-3">
              <div className="w-11 h-11 bg-arda-bg-tertiary rounded-2xl flex items-center justify-center border border-arda-border">
                <Icons.Smartphone className="w-5 h-5 text-arda-text-secondary" />
              </div>
              <div>
                <h3 className="font-semibold text-arda-text-primary">Phone camera</h3>
                <p className="text-sm text-arda-text-secondary">Scan QR to open the mobile scanner</p>
              </div>
            </div>

            <div className="flex items-center gap-3">
              <div className="bg-white p-2 rounded-xl border border-arda-border shadow-arda flex-shrink-0">
                <img
                  src={qrCodeUrl}
                  alt="Scan to open mobile scanner"
                  className="w-28 h-28 sm:w-32 sm:h-32"
                />
              </div>
              <p className="text-sm text-arda-text-secondary">
                Barcodes scanned on your phone sync here in real-time.
              </p>
            </div>

            <div className="flex items-center gap-2 text-xs text-arda-text-muted bg-white/70 border border-arda-border rounded-xl px-3 py-2">
              <Icons.Link className="w-3 h-3" />
              <span className="font-mono truncate">{getMobileScanUrl(sessionId)}</span>
            </div>
          </div>
        </div>
      </div>

      <div className="card-arda overflow-hidden">
        <div className="px-6 py-4 border-b border-arda-border bg-arda-bg-secondary flex items-center justify-between">
          <h3 className="font-semibold text-arda-text-primary">
            Scanned Items ({scannedBarcodes.length})
          </h3>
          {scannedBarcodes.length > 0 && (
            <span className="text-sm text-arda-text-secondary">
              {scannedBarcodes.filter((barcode) => barcode.productName).length} identified
            </span>
          )}
        </div>

        {scannedBarcodes.length === 0 ? (
          <div className="px-6 py-12 text-center text-arda-text-muted">
            <Icons.Barcode className="w-12 h-12 mx-auto mb-3 opacity-40" />
            <p>No barcodes scanned yet</p>
            <p className="text-sm mt-1 text-arda-text-secondary">Scan a UPC or EAN code to get started</p>
          </div>
        ) : (
          <div className="divide-y divide-arda-border max-h-[52vh] overflow-auto">
            {scannedBarcodes.map((item) => (
              <div key={item.id} className="px-4 py-3 hover:bg-arda-bg-tertiary transition-colors">
                <div className="flex items-start gap-3">
                  <div className="w-12 h-12 bg-arda-bg-tertiary rounded-xl flex items-center justify-center overflow-hidden flex-shrink-0 border border-arda-border">
                    {item.imageUrl ? (
                      <img src={item.imageUrl} alt="" className="w-full h-full object-cover" />
                    ) : (
                      <Icons.Package className="w-6 h-6 text-arda-text-muted" />
                    )}
                  </div>

                  <div className="flex-1 grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-5 gap-2">
                    <label className="text-xs text-arda-text-secondary">
                      Name
                      <input
                        type="text"
                        value={item.productName || ''}
                        onChange={(event) => handleEditableItemChange(item, 'productName', event.target.value)}
                        onBlur={() => void persistBarcodeById(item.id)}
                        className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white"
                        placeholder="Product name"
                      />
                    </label>

                    <label className="text-xs text-arda-text-secondary">
                      Barcode
                      <input
                        type="text"
                        value={item.barcode}
                        onChange={(event) => handleEditableItemChange(item, 'barcode', event.target.value)}
                        onBlur={() => void persistBarcodeById(item.id)}
                        className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white font-mono"
                        placeholder="Barcode"
                      />
                    </label>

                    <label className="text-xs text-arda-text-secondary">
                      Type
                      <select
                        value={item.barcodeType}
                        onChange={(event) => {
                          const nextType = event.target.value as ScannedBarcode['barcodeType'];
                          handleEditableItemChange(item, 'barcodeType', nextType);
                          void persistBarcodeById(item.id, { ...item, barcodeType: nextType });
                        }}
                        className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white"
                      >
                        {BARCODE_TYPES.map((type) => (
                          <option key={type} value={type}>{type}</option>
                        ))}
                      </select>
                    </label>

                    <label className="text-xs text-arda-text-secondary">
                      Brand
                      <input
                        type="text"
                        value={item.brand || ''}
                        onChange={(event) => handleEditableItemChange(item, 'brand', event.target.value)}
                        onBlur={() => void persistBarcodeById(item.id)}
                        className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white"
                        placeholder="Brand"
                      />
                    </label>

                    <label className="text-xs text-arda-text-secondary">
                      Category
                      <input
                        type="text"
                        value={item.category || ''}
                        onChange={(event) => handleEditableItemChange(item, 'category', event.target.value)}
                        onBlur={() => void persistBarcodeById(item.id)}
                        className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white"
                        placeholder="Category"
                      />
                    </label>
                  </div>

                  <div className="w-24 text-right text-xs text-arda-text-muted space-y-1">
                    <div className="px-2 py-1 rounded-lg font-medium bg-arda-bg-tertiary border border-arda-border text-arda-text-secondary inline-block">
                      {item.source === 'mobile' ? 'Mobile' : 'Desktop'}
                    </div>
                    <div>{new Date(item.scannedAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                    {savingBarcodeId === item.id && (
                      <div className="inline-flex items-center gap-1 text-arda-accent">
                        <Icons.Loader2 className="w-3 h-3 animate-spin" />
                        <span>Saving</span>
                      </div>
                    )}
                    {item.matchedToEmailItem && (
                      <div className="inline-flex items-center gap-1 text-green-600">
                        <Icons.Link className="w-3 h-3" />
                        <span>Matched</span>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      <div className="bg-white/70 border border-arda-border rounded-arda-lg px-4 py-3">
        <div className="flex items-start gap-3">
          <Icons.Lightbulb className="w-5 h-5 text-arda-accent flex-shrink-0 mt-0.5" />
          <div className="text-sm text-arda-text-secondary">
            <p className="font-medium text-arda-text-primary mb-1">Tips for scanning</p>
            <ul className="list-disc list-inside space-y-0.5 text-arda-text-secondary">
              <li>US products typically have UPC-A (12 digits) or EAN-13 (13 digits)</li>
              <li>The mobile scanner supports continuous scanning - just point and scan</li>
              <li>Scanned items will automatically match to email orders when possible</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
};

```

### `src/views/CSVReconcileStep.tsx`

```tsx
import { useState, useEffect, useMemo, useRef } from 'react';
import { Icons } from '../components/Icons';
import { InventoryItem } from '../types';
import { ScannedBarcode, CapturedPhoto, ReconciliationItem } from './OnboardingFlow';

interface CSVReconcileStepProps {
  emailItems: InventoryItem[];
  scannedBarcodes: ScannedBarcode[];
  capturedPhotos: CapturedPhoto[];
  onComplete: (items: ReconciliationItem[]) => void;
  onBack: () => void;
}

// CSV column mapping options
interface ColumnMapping {
  name?: string;
  sku?: string;
  barcode?: string;
  supplier?: string;
  location?: string;
  minQty?: string;
  orderQty?: string;
  unitPrice?: string;
}

export const CSVReconcileStep: React.FC<CSVReconcileStepProps> = ({
  emailItems,
  scannedBarcodes,
  capturedPhotos,
  onComplete,
  onBack,
}) => {
  // CSV state
  const [csvData, setCsvData] = useState<Record<string, string>[]>([]);
  const [csvHeaders, setCsvHeaders] = useState<string[]>([]);
  const [columnMapping, setColumnMapping] = useState<ColumnMapping>({});
  const [showMappingModal, setShowMappingModal] = useState(false);
  
  // Reconciliation state
  const [reconciliationItems, setReconciliationItems] = useState<ReconciliationItem[]>([]);
  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());
  const [filter, setFilter] = useState<'all' | 'duplicates' | 'needs_review' | 'approved'>('all');
  const [searchQuery, setSearchQuery] = useState('');
  
  // Push to Arda state
  const [isPushing, setIsPushing] = useState(false);
  const [pushProgress, setPushProgress] = useState({ current: 0, total: 0 });
  const [pushError, setPushError] = useState<string | null>(null);
  
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Build initial reconciliation items from all sources
  useEffect(() => {
    const items: ReconciliationItem[] = [];
    
    // Add email items
    emailItems.forEach(item => {
      items.push({
        id: `email-${item.id}`,
        source: 'email',
        name: item.name,
        normalizedName: item.name.toLowerCase().replace(/[^a-z0-9]/g, ''),
        supplier: item.supplier,
        location: item.location,
        barcode: item.amazonEnriched?.upc,
        asin: item.asin,
        quantity: item.totalQuantityOrdered,
        minQty: item.recommendedMin,
        orderQty: item.recommendedOrderQty,
        unitPrice: item.lastPrice,
        imageUrl: item.imageUrl,
        productUrl: item.productUrl,
        isApproved: false,
        needsReview: false,
      });
    });
    
    // Add scanned barcodes
    scannedBarcodes.forEach(barcode => {
      items.push({
        id: `barcode-${barcode.id}`,
        source: 'barcode',
        name: barcode.productName || `Unknown (${barcode.barcode})`,
        normalizedName: (barcode.productName || barcode.barcode).toLowerCase().replace(/[^a-z0-9]/g, ''),
        barcode: barcode.barcode,
        imageUrl: barcode.imageUrl,
        isApproved: false,
        needsReview: !barcode.productName,
      });
    });
    
    // Add photo-captured items
    capturedPhotos.forEach(photo => {
      if (photo.suggestedName) {
        items.push({
          id: `photo-${photo.id}`,
          source: 'photo',
          name: photo.suggestedName,
          normalizedName: photo.suggestedName.toLowerCase().replace(/[^a-z0-9]/g, ''),
          supplier: photo.suggestedSupplier,
          barcode: photo.detectedBarcodes?.[0],
          imageUrl: photo.imageData,
          isApproved: false,
          needsReview: true,
        });
      }
    });
    
    // Find duplicates using normalized names
    const nameMap = new Map<string, string[]>();
    items.forEach(item => {
      if (item.normalizedName) {
        const existing = nameMap.get(item.normalizedName) || [];
        nameMap.set(item.normalizedName, [...existing, item.id]);
      }
    });
    
    // Mark duplicates
    nameMap.forEach((ids) => {
      if (ids.length > 1) {
        ids.slice(1).forEach(id => {
          const item = items.find(i => i.id === id);
          if (item) {
            item.isDuplicate = true;
            item.duplicateOf = ids[0];
            item.needsReview = true;
          }
        });
      }
    });
    
    setReconciliationItems(items);
  }, [emailItems, scannedBarcodes, capturedPhotos]);

  // Handle CSV file upload
  const handleCSVUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const text = event.target?.result as string;
      parseCSV(text);
    };
    reader.readAsText(file);
    e.target.value = '';
  };

  // Parse CSV text
  const parseCSV = (text: string) => {
    const lines = text.split('\n').filter(line => line.trim());
    if (lines.length < 2) return;
    
    // Parse headers
    const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
    setCsvHeaders(headers);
    
    // Parse data rows
    const data: Record<string, string>[] = [];
    for (let i = 1; i < lines.length; i++) {
      const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
      const row: Record<string, string> = {};
      headers.forEach((header, index) => {
        row[header] = values[index] || '';
      });
      data.push(row);
    }
    
    setCsvData(data);
    
    // Auto-detect column mappings
    const mapping: ColumnMapping = {};
    headers.forEach(header => {
      const lower = header.toLowerCase();
      if (lower.includes('name') || lower.includes('item') || lower.includes('product')) {
        mapping.name = header;
      } else if (lower.includes('sku') || lower.includes('part')) {
        mapping.sku = header;
      } else if (lower.includes('barcode') || lower.includes('upc') || lower.includes('ean')) {
        mapping.barcode = header;
      } else if (lower.includes('supplier') || lower.includes('vendor')) {
        mapping.supplier = header;
      } else if (lower.includes('location') || lower.includes('bin')) {
        mapping.location = header;
      } else if (lower.includes('min') && lower.includes('qty')) {
        mapping.minQty = header;
      } else if (lower.includes('order') && lower.includes('qty')) {
        mapping.orderQty = header;
      } else if (lower.includes('price') || lower.includes('cost')) {
        mapping.unitPrice = header;
      }
    });
    
    setColumnMapping(mapping);
    setShowMappingModal(true);
  };

  // Apply CSV data with mapping
  const applyCSVMapping = () => {
    const newItems: ReconciliationItem[] = csvData.map((row, index) => ({
      id: `csv-${index}`,
      source: 'csv' as const,
      name: row[columnMapping.name || ''] || `Row ${index + 1}`,
      normalizedName: (row[columnMapping.name || ''] || '').toLowerCase().replace(/[^a-z0-9]/g, ''),
      sku: row[columnMapping.sku || ''],
      barcode: row[columnMapping.barcode || ''],
      supplier: row[columnMapping.supplier || ''],
      location: row[columnMapping.location || ''],
      minQty: columnMapping.minQty ? parseFloat(row[columnMapping.minQty]) || undefined : undefined,
      orderQty: columnMapping.orderQty ? parseFloat(row[columnMapping.orderQty]) || undefined : undefined,
      unitPrice: columnMapping.unitPrice ? parseFloat(row[columnMapping.unitPrice]) || undefined : undefined,
      isApproved: false,
      needsReview: true,
    }));
    
    // Merge with existing items
    setReconciliationItems(prev => {
      const combined = [...prev, ...newItems];
      
      // Re-detect duplicates
      const nameMap = new Map<string, string[]>();
      combined.forEach(item => {
        if (item.normalizedName) {
          const existing = nameMap.get(item.normalizedName) || [];
          nameMap.set(item.normalizedName, [...existing, item.id]);
        }
      });
      
      nameMap.forEach((ids) => {
        if (ids.length > 1) {
          ids.slice(1).forEach(id => {
            const item = combined.find(i => i.id === id);
            if (item) {
              item.isDuplicate = true;
              item.duplicateOf = ids[0];
              item.needsReview = true;
            }
          });
        }
      });
      
      return combined;
    });
    
    setShowMappingModal(false);
    setCsvData([]);
  };

  // Filter items
  const filteredItems = useMemo(() => {
    let items = reconciliationItems;
    
    // Apply filter
    switch (filter) {
      case 'duplicates':
        items = items.filter(i => i.isDuplicate);
        break;
      case 'needs_review':
        items = items.filter(i => i.needsReview && !i.isExcluded);
        break;
      case 'approved':
        items = items.filter(i => i.isApproved);
        break;
    }
    
    // Apply search
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      items = items.filter(i => 
        i.name.toLowerCase().includes(query) ||
        i.sku?.toLowerCase().includes(query) ||
        i.barcode?.includes(query) ||
        i.supplier?.toLowerCase().includes(query)
      );
    }
    
    return items;
  }, [reconciliationItems, filter, searchQuery]);

  // Toggle item selection
  const toggleSelection = (id: string) => {
    setSelectedItems(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  // Bulk approve selected
  const approveSelected = () => {
    setReconciliationItems(prev => 
      prev.map(item => 
        selectedItems.has(item.id) 
          ? { ...item, isApproved: true, needsReview: false }
          : item
      )
    );
    setSelectedItems(new Set());
  };

  // Bulk exclude selected
  const excludeSelected = () => {
    setReconciliationItems(prev =>
      prev.map(item =>
        selectedItems.has(item.id)
          ? { ...item, isExcluded: true, needsReview: false }
          : item
      )
    );
    setSelectedItems(new Set());
  };

  // Merge duplicate with original
  const mergeDuplicate = (duplicateId: string) => {
    const duplicate = reconciliationItems.find(i => i.id === duplicateId);
    if (!duplicate?.duplicateOf) return;
    
    setReconciliationItems(prev => {
      // Find original and merge data
      return prev.map(item => {
        if (item.id === duplicate.duplicateOf) {
          return {
            ...item,
            barcode: item.barcode || duplicate.barcode,
            sku: item.sku || duplicate.sku,
            imageUrl: item.imageUrl || duplicate.imageUrl,
            location: item.location || duplicate.location,
          };
        }
        if (item.id === duplicateId) {
          return { ...item, isExcluded: true, needsReview: false };
        }
        return item;
      });
    });
  };

  // Update single item
  const updateItem = (id: string, updates: Partial<ReconciliationItem>) => {
    setReconciliationItems(prev =>
      prev.map(item => item.id === id ? { ...item, ...updates } : item)
    );
  };

  // Push to Arda
  const pushToArda = async () => {
    const itemsToPush = reconciliationItems.filter(i => i.isApproved && !i.isExcluded);
    if (itemsToPush.length === 0) return;
    
    setIsPushing(true);
    setPushProgress({ current: 0, total: itemsToPush.length });
    setPushError(null);
    
    try {
      for (let i = 0; i < itemsToPush.length; i++) {
        const item = itemsToPush[i];
        
        await fetch('/api/arda/items', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({
            name: item.name,
            sku: item.sku,
            barcode: item.barcode,
            supplier: item.supplier,
            location: item.location,
            minQty: item.minQty,
            orderQty: item.orderQty,
            unitPrice: item.unitPrice,
            imageUrl: item.imageUrl,
            productUrl: item.productUrl,
          }),
        });
        
        setPushProgress({ current: i + 1, total: itemsToPush.length });
      }
      
      onComplete(itemsToPush);
    } catch (error) {
      setPushError(error instanceof Error ? error.message : 'Failed to push items to Arda');
    } finally {
      setIsPushing(false);
    }
  };

  // Stats
  const stats = useMemo(() => ({
    total: reconciliationItems.length,
    approved: reconciliationItems.filter(i => i.isApproved).length,
    duplicates: reconciliationItems.filter(i => i.isDuplicate).length,
    needsReview: reconciliationItems.filter(i => i.needsReview && !i.isExcluded).length,
    excluded: reconciliationItems.filter(i => i.isExcluded).length,
  }), [reconciliationItems]);

  // Source badge
  const getSourceBadge = (source: ReconciliationItem['source']) => {
    switch (source) {
      case 'email':
        return <span className="px-1.5 py-0.5 bg-blue-100 text-blue-700 text-xs rounded">📧 Email</span>;
      case 'barcode':
        return <span className="px-1.5 py-0.5 bg-green-100 text-green-700 text-xs rounded">📊 Barcode</span>;
      case 'photo':
        return <span className="px-1.5 py-0.5 bg-purple-100 text-purple-700 text-xs rounded">📷 Photo</span>;
      case 'csv':
        return <span className="px-1.5 py-0.5 bg-orange-100 text-orange-700 text-xs rounded">📄 CSV</span>;
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Review & Push to Arda</h1>
          <p className="text-gray-500 mt-1">
            Deduplicate, reconcile fields, and sync items to your Arda inventory
          </p>
        </div>
        <div className="flex items-center gap-3">
          <button
            onClick={onBack}
            className="px-4 py-2 text-gray-600 hover:text-gray-900 transition-colors"
          >
            ← Back
          </button>
          <button
            onClick={pushToArda}
            disabled={isPushing || stats.approved === 0}
            className="px-6 py-2 bg-green-500 hover:bg-green-600 disabled:bg-gray-300 text-white rounded-lg font-medium transition-colors flex items-center gap-2"
          >
            {isPushing ? (
              <>
                <Icons.Loader2 className="w-4 h-4 animate-spin" />
                Pushing...
              </>
            ) : (
              <>
                <Icons.Upload className="w-4 h-4" />
                Push to Arda ({stats.approved})
              </>
            )}
          </button>
        </div>
      </div>

      {/* Stats bar */}
      <div className="grid grid-cols-5 gap-4">
        <button
          onClick={() => setFilter('all')}
          className={`p-4 rounded-lg border-2 transition-colors ${
            filter === 'all' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white hover:border-gray-300'
          }`}
        >
          <div className="text-2xl font-bold text-gray-900">{stats.total}</div>
          <div className="text-sm text-gray-500">Total Items</div>
        </button>
        <button
          onClick={() => setFilter('duplicates')}
          className={`p-4 rounded-lg border-2 transition-colors ${
            filter === 'duplicates' ? 'border-yellow-500 bg-yellow-50' : 'border-gray-200 bg-white hover:border-gray-300'
          }`}
        >
          <div className="text-2xl font-bold text-yellow-600">{stats.duplicates}</div>
          <div className="text-sm text-gray-500">Duplicates</div>
        </button>
        <button
          onClick={() => setFilter('needs_review')}
          className={`p-4 rounded-lg border-2 transition-colors ${
            filter === 'needs_review' ? 'border-orange-500 bg-orange-50' : 'border-gray-200 bg-white hover:border-gray-300'
          }`}
        >
          <div className="text-2xl font-bold text-orange-600">{stats.needsReview}</div>
          <div className="text-sm text-gray-500">Needs Review</div>
        </button>
        <button
          onClick={() => setFilter('approved')}
          className={`p-4 rounded-lg border-2 transition-colors ${
            filter === 'approved' ? 'border-green-500 bg-green-50' : 'border-gray-200 bg-white hover:border-gray-300'
          }`}
        >
          <div className="text-2xl font-bold text-green-600">{stats.approved}</div>
          <div className="text-sm text-gray-500">Approved</div>
        </button>
        <div className="p-4 rounded-lg border-2 border-gray-200 bg-white">
          <div className="text-2xl font-bold text-gray-400">{stats.excluded}</div>
          <div className="text-sm text-gray-500">Excluded</div>
        </div>
      </div>

      {/* Actions bar */}
      <div className="flex items-center gap-4 bg-white rounded-lg border border-gray-200 p-4">
        <div className="flex-1 relative">
          <Icons.Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400" />
          <input
            type="text"
            placeholder="Search items..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-10 pr-4 py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <button
          onClick={() => fileInputRef.current?.click()}
          className="px-4 py-2 border border-gray-200 rounded-lg hover:bg-gray-50 flex items-center gap-2"
        >
          <Icons.Upload className="w-4 h-4" />
          Upload CSV
        </button>
        <input
          ref={fileInputRef}
          type="file"
          accept=".csv"
          onChange={handleCSVUpload}
          className="hidden"
          aria-label="Upload CSV file"
        />
        
        {selectedItems.size > 0 && (
          <>
            <div className="h-6 w-px bg-gray-200" />
            <span className="text-sm text-gray-500">{selectedItems.size} selected</span>
            <button
              onClick={approveSelected}
              className="px-3 py-1.5 bg-green-100 text-green-700 rounded-lg text-sm font-medium hover:bg-green-200"
            >
              Approve
            </button>
            <button
              onClick={excludeSelected}
              className="px-3 py-1.5 bg-red-100 text-red-700 rounded-lg text-sm font-medium hover:bg-red-200"
            >
              Exclude
            </button>
          </>
        )}
      </div>

      {/* Items table */}
      <div className="bg-white rounded-xl border border-gray-200 overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 border-b border-gray-200">
              <tr>
                <th className="w-10 px-4 py-3">
                  <input
                    type="checkbox"
                    checked={selectedItems.size === filteredItems.length && filteredItems.length > 0}
                    onChange={(e) => {
                      if (e.target.checked) {
                        setSelectedItems(new Set(filteredItems.map(i => i.id)));
                      } else {
                        setSelectedItems(new Set());
                      }
                    }}
                    className="rounded"
                    aria-label="Select all items"
                    title="Select all items"
                  />
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Item</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Source</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Barcode</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Supplier</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Location</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Min/Order Qty</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Status</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Actions</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-100">
              {filteredItems.map((item) => (
                <tr 
                  key={item.id} 
                  className={`
                    hover:bg-gray-50 transition-colors
                    ${item.isExcluded ? 'opacity-50 bg-gray-50' : ''}
                    ${item.isDuplicate ? 'bg-yellow-50' : ''}
                  `}
                >
                  <td className="px-4 py-3">
                    <input
                      type="checkbox"
                      checked={selectedItems.has(item.id)}
                      onChange={() => toggleSelection(item.id)}
                      disabled={item.isExcluded}
                      className="rounded"
                      aria-label={`Select ${item.name}`}
                      title={`Select ${item.name}`}
                    />
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex items-center gap-3">
                      {item.imageUrl && (
                        <img 
                          src={item.imageUrl} 
                          alt="" 
                          className="w-10 h-10 rounded object-cover"
                        />
                      )}
                      <div>
                        <p className="font-medium text-gray-900">{item.name}</p>
                        {item.sku && <p className="text-xs text-gray-400">SKU: {item.sku}</p>}
                      </div>
                    </div>
                  </td>
                  <td className="px-4 py-3">{getSourceBadge(item.source)}</td>
                  <td className="px-4 py-3">
                    <span className="font-mono text-sm text-gray-600">{item.barcode || '-'}</span>
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-600">{item.supplier || '-'}</td>
                  <td className="px-4 py-3 text-sm text-gray-600">{item.location || '-'}</td>
                  <td className="px-4 py-3 text-sm text-gray-600">
                    {item.minQty || item.orderQty ? `${item.minQty || '-'} / ${item.orderQty || '-'}` : '-'}
                  </td>
                  <td className="px-4 py-3">
                    {item.isExcluded ? (
                      <span className="px-2 py-0.5 bg-gray-100 text-gray-500 rounded text-xs">Excluded</span>
                    ) : item.isApproved ? (
                      <span className="px-2 py-0.5 bg-green-100 text-green-700 rounded text-xs">Approved</span>
                    ) : item.isDuplicate ? (
                      <span className="px-2 py-0.5 bg-yellow-100 text-yellow-700 rounded text-xs">Duplicate</span>
                    ) : item.needsReview ? (
                      <span className="px-2 py-0.5 bg-orange-100 text-orange-700 rounded text-xs">Review</span>
                    ) : (
                      <span className="px-2 py-0.5 bg-gray-100 text-gray-500 rounded text-xs">Pending</span>
                    )}
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex items-center gap-1">
                      {item.isDuplicate && !item.isExcluded && (
                        <button
                          onClick={() => mergeDuplicate(item.id)}
                          title="Merge with original"
                          className="p-1.5 hover:bg-yellow-100 rounded text-yellow-600"
                        >
                          <Icons.GitMerge className="w-4 h-4" />
                        </button>
                      )}
                      {!item.isApproved && !item.isExcluded && (
                        <button
                          onClick={() => updateItem(item.id, { isApproved: true, needsReview: false })}
                          title="Approve"
                          className="p-1.5 hover:bg-green-100 rounded text-green-600"
                        >
                          <Icons.Check className="w-4 h-4" />
                        </button>
                      )}
                      {!item.isExcluded && (
                        <button
                          onClick={() => updateItem(item.id, { isExcluded: true, needsReview: false })}
                          title="Exclude"
                          className="p-1.5 hover:bg-red-100 rounded text-red-600"
                        >
                          <Icons.X className="w-4 h-4" />
                        </button>
                      )}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
        
        {filteredItems.length === 0 && (
          <div className="px-6 py-12 text-center text-gray-400">
            <Icons.Search className="w-12 h-12 mx-auto mb-3 opacity-50" />
            <p>No items match your filter</p>
          </div>
        )}
      </div>

      {/* CSV Mapping Modal */}
      {showMappingModal && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl shadow-xl max-w-lg w-full mx-4 p-6 space-y-4">
            <h3 className="text-lg font-semibold">Map CSV Columns</h3>
            <p className="text-sm text-gray-500">
              Match your CSV columns to the item fields. {csvData.length} rows detected.
            </p>
            
            <div className="space-y-3">
              {[
                { key: 'name', label: 'Item Name *' },
                { key: 'sku', label: 'SKU/Part Number' },
                { key: 'barcode', label: 'Barcode (UPC/EAN)' },
                { key: 'supplier', label: 'Supplier' },
                { key: 'location', label: 'Location' },
                { key: 'minQty', label: 'Min Quantity' },
                { key: 'orderQty', label: 'Order Quantity' },
                { key: 'unitPrice', label: 'Unit Price' },
              ].map(({ key, label }) => (
                <div key={key} className="flex items-center gap-4">
                  <label htmlFor={`mapping-${key}`} className="w-32 text-sm text-gray-600">{label}</label>
                  <select
                    id={`mapping-${key}`}
                    value={columnMapping[key as keyof ColumnMapping] || ''}
                    onChange={(e) => setColumnMapping(prev => ({ ...prev, [key]: e.target.value || undefined }))}
                    className="flex-1 px-3 py-2 border border-gray-200 rounded-lg"
                    aria-label={`Select column for ${label}`}
                  >
                    <option value="">-- Select column --</option>
                    {csvHeaders.map(header => (
                      <option key={header} value={header}>{header}</option>
                    ))}
                  </select>
                </div>
              ))}
            </div>
            
            <div className="flex justify-end gap-3 pt-4">
              <button
                onClick={() => { setShowMappingModal(false); setCsvData([]); }}
                className="px-4 py-2 text-gray-600 hover:text-gray-900"
              >
                Cancel
              </button>
              <button
                onClick={applyCSVMapping}
                disabled={!columnMapping.name}
                className="px-4 py-2 bg-blue-500 text-white rounded-lg disabled:bg-gray-300"
              >
                Import {csvData.length} Items
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Push progress */}
      {isPushing && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl shadow-xl max-w-sm w-full mx-4 p-6 text-center">
            <Icons.Loader2 className="w-12 h-12 animate-spin text-blue-500 mx-auto mb-4" />
            <p className="text-lg font-medium">Pushing to Arda...</p>
            <p className="text-gray-500 mt-1">
              {pushProgress.current} of {pushProgress.total} items
            </p>
            <div className="mt-4 h-2 bg-gray-100 rounded-full overflow-hidden">
              <div 
                className="h-full bg-blue-500 transition-all"
                style={{ width: `${(pushProgress.current / pushProgress.total) * 100}%` }}
              />
            </div>
          </div>
        </div>
      )}

      {/* Push error */}
      {pushError && (
        <div className="bg-red-50 border border-red-200 rounded-lg px-4 py-3 flex items-center gap-3">
          <Icons.AlertCircle className="w-5 h-5 text-red-500" />
          <span className="text-red-700">{pushError}</span>
          <button 
            onClick={() => setPushError(null)} 
            className="ml-auto text-red-500 hover:text-red-700"
            aria-label="Dismiss error"
            title="Dismiss error"
          >
            <Icons.X className="w-4 h-4" />
          </button>
        </div>
      )}
    </div>
  );
};

```

### `src/views/CSVUploadStep.tsx`

```tsx
import { useState, useRef, useCallback, useEffect } from 'react';
import { Icons } from '../components/Icons';

// CSV item with approval status
export interface CSVItem {
  id: string;
  rowIndex: number;
  // Core fields from CSV
  name: string;
  sku?: string;
  barcode?: string;
  supplier?: string;
  location?: string;
  minQty?: number;
  orderQty?: number;
  unitPrice?: number;
  // URLs and media
  productUrl?: string;
  imageUrl?: string;
  // Arda-specific
  color?: string;
  // Approval status
  isApproved: boolean;
  isRejected: boolean;
  // Original row data for reference
  rawData: Record<string, string>;
}

// Column mapping configuration
interface ColumnMapping {
  name?: string;
  sku?: string;
  barcode?: string;
  supplier?: string;
  location?: string;
  minQty?: string;
  orderQty?: string;
  unitPrice?: string;
  productUrl?: string;
  imageUrl?: string;
  color?: string;
}

interface CSVUploadStepProps {
  onComplete: (approvedItems: CSVItem[]) => void;
  onBack?: () => void;
  onFooterStateChange?: (state: CSVFooterState) => void;
}

export interface CSVFooterState {
  approvedCount: number;
  canContinue: boolean;
  onSkip: () => void;
  onContinue: () => void;
}

export const CSVUploadStep: React.FC<CSVUploadStepProps> = ({
  onComplete,
  onFooterStateChange,
}) => {
  // CSV parsing state
  const [csvHeaders, setCsvHeaders] = useState<string[]>([]);
  const [csvData, setCsvData] = useState<Record<string, string>[]>([]);
  const [columnMapping, setColumnMapping] = useState<ColumnMapping>({});
  const [showMappingModal, setShowMappingModal] = useState(false);
  const [fileName, setFileName] = useState<string | null>(null);
  
  // Items after mapping
  const [items, setItems] = useState<CSVItem[]>([]);
  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());
  
  // Filter state
  const [filter, setFilter] = useState<'all' | 'pending' | 'approved' | 'rejected'>('all');
  const [searchQuery, setSearchQuery] = useState('');
  
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Parse CSV file
  const parseCSV = useCallback((text: string) => {
    const lines = text.split('\n').filter(line => line.trim());
    if (lines.length === 0) return;
    
    // Parse headers
    const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
    setCsvHeaders(headers);
    
    // Parse data rows
    const data: Record<string, string>[] = [];
    for (let i = 1; i < lines.length; i++) {
      const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
      const row: Record<string, string> = {};
      headers.forEach((header, index) => {
        row[header] = values[index] || '';
      });
      data.push(row);
    }
    
    setCsvData(data);
    
    // Auto-detect column mappings
    const mapping: ColumnMapping = {};
    headers.forEach(header => {
      const h = header.toLowerCase();
      if (h.includes('name') || h.includes('description') || h.includes('item')) {
        mapping.name = mapping.name || header;
      }
      if (h.includes('sku') || h.includes('part') || h.includes('number')) {
        mapping.sku = mapping.sku || header;
      }
      if (h.includes('barcode') || h.includes('upc') || h.includes('ean')) {
        mapping.barcode = mapping.barcode || header;
      }
      if (h.includes('supplier') || h.includes('vendor')) {
        mapping.supplier = mapping.supplier || header;
      }
      if (h.includes('location') || h.includes('bin') || h.includes('shelf')) {
        mapping.location = mapping.location || header;
      }
      if (h.includes('min') && (h.includes('qty') || h.includes('quantity'))) {
        mapping.minQty = mapping.minQty || header;
      }
      if (h.includes('order') && (h.includes('qty') || h.includes('quantity'))) {
        mapping.orderQty = mapping.orderQty || header;
      }
      if (h.includes('price') || h.includes('cost')) {
        mapping.unitPrice = mapping.unitPrice || header;
      }
      if (h.includes('product') && h.includes('url') || h === 'url' || h === 'link') {
        mapping.productUrl = mapping.productUrl || header;
      }
      if (h.includes('image') || h.includes('img') || h.includes('photo') || h.includes('picture')) {
        mapping.imageUrl = mapping.imageUrl || header;
      }
      if (h.includes('color') || h.includes('colour')) {
        mapping.color = mapping.color || header;
      }
    });
    
    setColumnMapping(mapping);
    setShowMappingModal(true);
  }, []);

  // Handle file upload
  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    setFileName(file.name);
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const text = event.target?.result as string;
      parseCSV(text);
    };
    reader.readAsText(file);
    e.target.value = ''; // Reset for re-selection
  };

  // Apply column mapping and create items
  const applyMapping = () => {
    const newItems: CSVItem[] = csvData.map((row, index) => ({
      id: `csv-${Date.now()}-${index}`,
      rowIndex: index + 2, // +2 for 1-indexed and header row
      name: row[columnMapping.name || ''] || `Row ${index + 2}`,
      sku: row[columnMapping.sku || ''],
      barcode: row[columnMapping.barcode || ''],
      supplier: row[columnMapping.supplier || ''],
      location: row[columnMapping.location || ''],
      minQty: columnMapping.minQty ? parseFloat(row[columnMapping.minQty]) || undefined : undefined,
      orderQty: columnMapping.orderQty ? parseFloat(row[columnMapping.orderQty]) || undefined : undefined,
      unitPrice: columnMapping.unitPrice ? parseFloat(row[columnMapping.unitPrice]) || undefined : undefined,
      productUrl: row[columnMapping.productUrl || ''] || undefined,
      imageUrl: row[columnMapping.imageUrl || ''] || undefined,
      color: row[columnMapping.color || ''] || undefined,
      isApproved: false,
      isRejected: false,
      rawData: row,
    }));
    
    setItems(newItems);
    setShowMappingModal(false);
  };

  // Approval actions
  const approveItem = (id: string) => {
    setItems(prev => prev.map(item => 
      item.id === id ? { ...item, isApproved: true, isRejected: false } : item
    ));
  };

  const rejectItem = (id: string) => {
    setItems(prev => prev.map(item => 
      item.id === id ? { ...item, isApproved: false, isRejected: true } : item
    ));
  };

  const approveSelected = () => {
    setItems(prev => prev.map(item => 
      selectedItems.has(item.id) ? { ...item, isApproved: true, isRejected: false } : item
    ));
    setSelectedItems(new Set());
  };

  const approveAll = () => {
    setItems(prev => prev.map(item => ({ ...item, isApproved: true, isRejected: false })));
  };

  const rejectSelected = () => {
    setItems(prev => prev.map(item => 
      selectedItems.has(item.id) ? { ...item, isApproved: false, isRejected: true } : item
    ));
    setSelectedItems(new Set());
  };

  // Toggle selection
  const toggleSelection = (id: string) => {
    setSelectedItems(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  const toggleSelectAll = () => {
    if (selectedItems.size === filteredItems.length) {
      setSelectedItems(new Set());
    } else {
      setSelectedItems(new Set(filteredItems.map(item => item.id)));
    }
  };

  // Filter items
  const filteredItems = items.filter(item => {
    // Filter by status
    if (filter === 'pending' && (item.isApproved || item.isRejected)) return false;
    if (filter === 'approved' && !item.isApproved) return false;
    if (filter === 'rejected' && !item.isRejected) return false;
    
    // Filter by search
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      return (
        item.name.toLowerCase().includes(query) ||
        item.sku?.toLowerCase().includes(query) ||
        item.barcode?.toLowerCase().includes(query) ||
        item.supplier?.toLowerCase().includes(query)
      );
    }
    return true;
  });

  // Stats
  const stats = {
    total: items.length,
    pending: items.filter(i => !i.isApproved && !i.isRejected).length,
    approved: items.filter(i => i.isApproved).length,
    rejected: items.filter(i => i.isRejected).length,
  };

  const handleSkip = useCallback(() => {
    onComplete([]);
  }, [onComplete]);

  // Handle completion
  const handleComplete = useCallback(() => {
    const approvedItems = items.filter(item => item.isApproved);
    onComplete(approvedItems);
  }, [items, onComplete]);

  useEffect(() => {
    onFooterStateChange?.({
      approvedCount: stats.approved,
      canContinue: stats.approved > 0,
      onSkip: handleSkip,
      onContinue: handleComplete,
    });
  }, [handleComplete, handleSkip, onFooterStateChange, stats.approved]);

  return (
    <div className="space-y-4">
      {/* Upload area or items list */}
      {items.length === 0 ? (
        <div className="bg-white rounded-arda-lg border-2 border-dashed border-arda-border p-12 shadow-arda">
          <div className="text-center">
            <Icons.FileSpreadsheet className="w-16 h-16 mx-auto text-arda-text-muted mb-4 opacity-70" />
            <h3 className="text-lg font-semibold text-arda-text-primary mb-2">
              Upload a CSV File
            </h3>
            <p className="text-arda-text-secondary mb-6 max-w-md mx-auto">
              Import your inventory, supplier catalog, or item list. We'll help you map the columns.
            </p>
            <input
              ref={fileInputRef}
              type="file"
              accept=".csv"
              onChange={handleFileUpload}
              className="hidden"
            />
            <button
              onClick={() => fileInputRef.current?.click()}
              className="btn-arda-primary inline-flex items-center gap-2 px-6 py-3 rounded-xl"
            >
              <Icons.Upload className="w-5 h-5" />
              Select CSV File
            </button>
            <p className="text-sm text-arda-text-muted mt-4">
              Supports: .csv files with headers
            </p>
          </div>
        </div>
      ) : (
        <>
          {/* Stats bar */}
          <div className="card-arda p-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-6">
                <div className="flex items-center gap-2">
                  <Icons.FileSpreadsheet className="w-5 h-5 text-arda-text-muted" />
                  <span className="font-medium text-arda-text-primary">{fileName}</span>
                </div>
                <div className="flex items-center gap-4 text-sm">
                  <span className="text-arda-text-secondary">{stats.total} items</span>
                  <span className="text-yellow-600">{stats.pending} pending</span>
                  <span className="text-green-600">{stats.approved} approved</span>
                  <span className="text-red-600">{stats.rejected} rejected</span>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={() => fileInputRef.current?.click()}
                  className="btn-arda-outline px-3 py-1.5 text-sm"
                >
                  Upload Different File
                </button>
                <input
                  ref={fileInputRef}
                  type="file"
                  accept=".csv"
                  onChange={handleFileUpload}
                  className="hidden"
                />
              </div>
            </div>
          </div>

          {/* Filter bar */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              {(['all', 'pending', 'approved', 'rejected'] as const).map(f => (
                <button
                  key={f}
                  onClick={() => setFilter(f)}
                  className={[
                    'px-3 py-1.5 rounded-arda text-sm font-medium transition-colors border',
                    filter === f
                      ? 'bg-arda-accent text-white border-orange-600'
                      : 'bg-white/70 text-arda-text-secondary border-arda-border hover:bg-arda-bg-tertiary',
                  ].join(' ')}
                >
                  {f.charAt(0).toUpperCase() + f.slice(1)}
                </button>
              ))}
            </div>
            <div className="flex items-center gap-3">
              <div className="relative">
                <Icons.Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-arda-text-muted" />
                <input
                  type="text"
                  placeholder="Search items..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="input-arda pl-9 pr-4 py-2 text-sm bg-white"
                />
              </div>
            </div>
          </div>

          {/* Bulk actions */}
          {selectedItems.size > 0 && (
            <div className="bg-orange-50 border border-orange-200 rounded-arda-lg p-4 flex items-center justify-between">
              <span className="text-orange-800 font-medium">
                {selectedItems.size} items selected
              </span>
              <div className="flex items-center gap-2">
                <button
                  onClick={approveSelected}
                  className="px-4 py-2 bg-green-600 text-white rounded-arda text-sm font-medium hover:bg-green-700 transition-colors"
                >
                  Approve Selected
                </button>
                <button
                  onClick={rejectSelected}
                  className="px-4 py-2 bg-red-600 text-white rounded-arda text-sm font-medium hover:bg-red-700 transition-colors"
                >
                  Reject Selected
                </button>
              </div>
            </div>
          )}

          {/* Items table */}
          <div className="card-arda overflow-hidden">
            <table className="table-arda">
              <thead className="bg-arda-bg-secondary border-b border-arda-border">
                <tr>
                  <th className="px-4 py-3 text-left">
                    <input
                      type="checkbox"
                      checked={selectedItems.size === filteredItems.length && filteredItems.length > 0}
                      onChange={toggleSelectAll}
                      className="rounded border-gray-300"
                    />
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-semibold text-arda-text-secondary uppercase tracking-wider">
                    Item
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-semibold text-arda-text-secondary uppercase tracking-wider">
                    SKU / Barcode
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-semibold text-arda-text-secondary uppercase tracking-wider">
                    Supplier
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-semibold text-arda-text-secondary uppercase tracking-wider">
                    Location
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-semibold text-arda-text-secondary uppercase tracking-wider">
                    Min Qty
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-semibold text-arda-text-secondary uppercase tracking-wider">
                    Status
                  </th>
                  <th className="px-4 py-3 text-right text-xs font-semibold text-arda-text-secondary uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-arda-border">
                {filteredItems.map(item => (
                  <tr 
                    key={item.id} 
                    className={`
                      hover:bg-arda-bg-tertiary transition-colors
                      ${item.isApproved ? 'bg-green-50' : ''}
                      ${item.isRejected ? 'bg-red-50 opacity-60' : ''}
                    `}
                  >
                    <td className="px-4 py-3">
                      <input
                        type="checkbox"
                        checked={selectedItems.has(item.id)}
                        onChange={() => toggleSelection(item.id)}
                        className="rounded border-gray-300"
                      />
                    </td>
                    <td className="px-4 py-3">
                      <div className="font-medium text-arda-text-primary">{item.name}</div>
                      <div className="text-xs text-arda-text-muted">Row {item.rowIndex}</div>
                    </td>
                    <td className="px-4 py-3 text-sm text-arda-text-secondary">
                      {item.sku && <div>SKU: {item.sku}</div>}
                      {item.barcode && <div>Barcode: {item.barcode}</div>}
                      {!item.sku && !item.barcode && <span className="text-arda-text-muted">—</span>}
                    </td>
                    <td className="px-4 py-3 text-sm text-arda-text-secondary">
                      {item.supplier || <span className="text-arda-text-muted">—</span>}
                    </td>
                    <td className="px-4 py-3 text-sm text-arda-text-secondary">
                      {item.location || <span className="text-arda-text-muted">—</span>}
                    </td>
                    <td className="px-4 py-3 text-sm text-arda-text-secondary">
                      {item.minQty ?? <span className="text-arda-text-muted">—</span>}
                    </td>
                    <td className="px-4 py-3">
                      {item.isApproved && (
                        <span className="px-2 py-1 bg-green-100 text-green-700 rounded-full text-xs font-medium">
                          Approved
                        </span>
                      )}
                      {item.isRejected && (
                        <span className="px-2 py-1 bg-red-100 text-red-700 rounded-full text-xs font-medium">
                          Rejected
                        </span>
                      )}
                      {!item.isApproved && !item.isRejected && (
                        <span className="px-2 py-1 bg-yellow-100 text-yellow-700 rounded-full text-xs font-medium">
                          Pending
                        </span>
                      )}
                    </td>
                    <td className="px-4 py-3 text-right">
                      <div className="flex items-center justify-end gap-1">
                        <button
                          onClick={() => approveItem(item.id)}
                          className={`p-1.5 rounded transition-colors ${
                            item.isApproved 
                              ? 'bg-green-100 text-green-600' 
                              : 'hover:bg-green-100 text-gray-400 hover:text-green-600'
                          }`}
                          title="Approve"
                        >
                          <Icons.Check className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => rejectItem(item.id)}
                          className={`p-1.5 rounded transition-colors ${
                            item.isRejected 
                              ? 'bg-red-100 text-red-600' 
                              : 'hover:bg-red-100 text-gray-400 hover:text-red-600'
                          }`}
                          title="Reject"
                        >
                          <Icons.X className="w-4 h-4" />
                        </button>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
            
            {filteredItems.length === 0 && (
              <div className="p-12 text-center text-arda-text-muted">
                <Icons.Search className="w-12 h-12 mx-auto mb-3 opacity-40" />
                <p>No items match your filter</p>
              </div>
            )}
          </div>

          {/* Quick actions */}
          <div className="flex items-center justify-between">
            <button
              onClick={approveAll}
              className="px-4 py-2 bg-green-100 text-green-800 rounded-arda font-medium hover:bg-green-200 transition-colors"
            >
              Approve All Items
            </button>
            <div className="text-sm text-arda-text-secondary">
              {stats.approved} of {stats.total} items will be added to your master list
            </div>
          </div>
        </>
      )}

      {/* Column mapping modal */}
      {showMappingModal && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="arda-glass rounded-2xl w-full max-w-2xl max-h-[80vh] overflow-auto">
            <div className="p-6 border-b border-arda-border/70">
              <h3 className="text-lg font-semibold text-arda-text-primary">Map CSV Columns</h3>
              <p className="text-sm text-arda-text-secondary mt-1">
                Tell us which columns contain which data. We've made some guesses.
              </p>
            </div>
            
            <div className="p-6 space-y-4">
              {[
                { key: 'name', label: 'Item Name', required: true },
                { key: 'sku', label: 'SKU / Part Number' },
                { key: 'barcode', label: 'Barcode (UPC/EAN)' },
                { key: 'supplier', label: 'Supplier' },
                { key: 'location', label: 'Location / Bin' },
                { key: 'minQty', label: 'Minimum Quantity' },
                { key: 'orderQty', label: 'Order Quantity' },
                { key: 'unitPrice', label: 'Unit Price' },
                { key: 'productUrl', label: 'Product URL' },
                { key: 'imageUrl', label: 'Image URL' },
                { key: 'color', label: 'Color' },
              ].map(({ key, label, required }) => (
                <div key={key} className="flex items-center gap-4">
                  <label className="w-40 text-sm font-medium text-arda-text-secondary">
                    {label} {required && <span className="text-red-500">*</span>}
                  </label>
                  <select
                    value={columnMapping[key as keyof ColumnMapping] || ''}
                    onChange={(e) => setColumnMapping(prev => ({ 
                      ...prev, 
                      [key]: e.target.value || undefined 
                    }))}
                    className="input-arda flex-1 text-sm bg-white"
                  >
                    <option value="">— Select column —</option>
                    {csvHeaders.map(header => (
                      <option key={header} value={header}>{header}</option>
                    ))}
                  </select>
                </div>
              ))}
              
              {/* Preview */}
              <div className="mt-6 pt-6 border-t border-arda-border/70">
                <h4 className="text-sm font-medium text-arda-text-primary mb-3">Preview (first 3 rows)</h4>
                <div className="overflow-x-auto">
                  <table className="w-full text-xs">
                    <thead className="bg-arda-bg-secondary">
                      <tr>
                        <th className="px-2 py-1 text-left">Name</th>
                        <th className="px-2 py-1 text-left">SKU</th>
                        <th className="px-2 py-1 text-left">Supplier</th>
                      </tr>
                    </thead>
                    <tbody>
                      {csvData.slice(0, 3).map((row, i) => (
                        <tr key={i} className="border-t border-gray-100">
                          <td className="px-2 py-1">{row[columnMapping.name || ''] || '—'}</td>
                          <td className="px-2 py-1">{row[columnMapping.sku || ''] || '—'}</td>
                          <td className="px-2 py-1">{row[columnMapping.supplier || ''] || '—'}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            
            <div className="p-6 border-t border-arda-border/70 flex items-center justify-end gap-3">
              <button
                onClick={() => {
                  setShowMappingModal(false);
                  setCsvData([]);
                  setCsvHeaders([]);
                }}
                className="btn-arda-outline"
              >
                Cancel
              </button>
              <button
                onClick={applyMapping}
                disabled={!columnMapping.name}
                className={[
                  'px-6 py-2 rounded-arda font-semibold text-sm transition-colors',
                  columnMapping.name
                    ? 'bg-arda-accent text-white hover:bg-arda-accent-hover'
                    : 'bg-arda-border text-arda-text-muted cursor-not-allowed',
                ].join(' ')}
              >
                Apply Mapping
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

```

### `src/views/CadenceView.tsx`

```tsx
import { InventoryItem, ExtractedOrder } from '../types';
import { Icons } from '../components/Icons';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, Cell, CartesianGrid } from 'recharts';

interface CadenceViewProps {
  inventory: InventoryItem[];
  orders?: ExtractedOrder[];
}

type CadenceDatum = {
  name: string;
  fullName: string;
  cadence: number;
  orderCount: number;
};

type VelocityDatum = {
  name: string;
  fullName: string;
  velocity: number;
  supplier: string;
};

export const CadenceView: React.FC<CadenceViewProps> = ({ inventory }) => {
  // Cadence chart data (days between orders)
  const cadenceData: CadenceDatum[] = inventory
    .map(item => ({
      name: item.name.substring(0, 15) + (item.name.length > 15 ? '...' : ''),
      fullName: item.name,
      cadence: Math.round(item.averageCadenceDays),
      orderCount: item.orderCount,
    }))
    .sort((a, b) => a.cadence - b.cadence)
    .slice(0, 10); // Top 10

  // Velocity chart data (units per day - consumption rate)
  const velocityData: VelocityDatum[] = inventory
    .map(item => ({
      name: item.name.substring(0, 15) + (item.name.length > 15 ? '...' : ''),
      fullName: item.name,
      velocity: parseFloat(item.dailyBurnRate.toFixed(2)),
      supplier: item.supplier,
    }))
    .sort((a, b) => b.velocity - a.velocity)
    .slice(0, 10); // Top 10 fastest movers

  // Build complete line item history from inventory
  const lineItemHistory = inventory
    .flatMap(item =>
      item.history.map(h => ({
        date: h.date,
        itemName: item.name,
        supplier: item.supplier,
        quantity: h.quantity,
        unitPrice: item.lastPrice,
      }))
    )
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    .slice(0, 50); // Last 50 transactions

  // Summary stats
  const totalItems = inventory.length; // Unique item types
  const avgCadence = inventory.length > 0
    ? Math.round(inventory.reduce((sum, i) => sum + i.averageCadenceDays, 0) / inventory.length)
    : 0;
  const totalLineItems = inventory.reduce((sum, i) => sum + i.history.length, 0); // Total line item occurrences
  const fastestMover = velocityData[0];

  if (inventory.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-96 text-arda-text-muted">
        <Icons.TrendingUp className="w-16 h-16 mb-4 opacity-50" />
        <p className="text-lg">No order data for analysis</p>
        <p className="text-sm mt-2">Process emails from the Ingestion Engine to see analytics</p>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-arda-text-primary">Cadence & Velocity Analysis</h2>
          <p className="text-arda-text-muted text-sm">Purchase patterns and consumption rates</p>
        </div>
      </div>

      {/* Summary Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <div className="bg-white p-4 rounded-lg border border-arda-border">
          <div className="flex items-center gap-3">
            <div className="bg-arda-bg-tertiary p-2 rounded">
              <Icons.Package className="text-arda-accent w-5 h-5" />
            </div>
            <div>
              <div className="text-2xl font-bold text-arda-text-primary">{totalItems}</div>
              <div className="text-xs text-arda-text-muted">Unique Items Tracked</div>
            </div>
          </div>
        </div>
        <div className="bg-white p-4 rounded-lg border border-arda-border">
          <div className="flex items-center gap-3">
            <div className="bg-arda-bg-tertiary p-2 rounded">
              <Icons.Calendar className="text-arda-accent w-5 h-5" />
            </div>
            <div>
              <div className="text-2xl font-bold text-arda-text-primary">{avgCadence} days</div>
              <div className="text-xs text-arda-text-muted">Avg Order Cadence</div>
            </div>
          </div>
        </div>
        <div className="bg-white p-4 rounded-lg border border-arda-border">
          <div className="flex items-center gap-3">
            <div className="bg-arda-bg-tertiary p-2 rounded">
              <Icons.Inbox className="text-arda-accent w-5 h-5" />
            </div>
            <div>
              <div className="text-2xl font-bold text-arda-text-primary">{totalLineItems}</div>
              <div className="text-xs text-arda-text-muted">Total Line Items</div>
            </div>
          </div>
        </div>
        <div className="bg-white p-4 rounded-lg border border-arda-border">
          <div className="flex items-center gap-3">
            <div className="bg-arda-bg-tertiary p-2 rounded">
              <Icons.TrendingUp className="text-arda-accent w-5 h-5" />
            </div>
            <div>
              <div className="text-lg font-bold text-arda-text-primary truncate max-w-[150px]" title={fastestMover?.fullName}>
                {fastestMover?.fullName.substring(0, 16) || '-'}
              </div>
              <div className="text-xs text-arda-text-muted">Fastest Mover ({fastestMover?.velocity}/day)</div>
            </div>
          </div>
        </div>
      </div>

      {/* Charts Row */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Cadence Chart */}
        <div className="bg-white border border-arda-border rounded-lg p-6">
          <h3 className="text-lg font-semibold text-arda-text-primary mb-4">Order Cadence (Days)</h3>
          <p className="text-arda-text-muted text-xs mb-4">Average days between orders per item</p>
          <div className="h-72">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={cadenceData} layout="vertical" margin={{ top: 5, right: 30, left: 10, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="#E5E7EB" horizontal={false} />
                <XAxis type="number" stroke="#6B7280" fontSize={12} tickLine={false} axisLine={false} />
                <YAxis
                  dataKey="name"
                  type="category"
                  stroke="#6B7280"
                  fontSize={10}
                  tickLine={false}
                  axisLine={false}
                  width={100}
                />
                <Tooltip
                  cursor={{ fill: '#F3F4F6' }}
                  contentStyle={{ background: '#FFFFFF', border: '1px solid #E5E7EB', color: '#111827' }}
                  formatter={(value, _name, props) => {
                    const payload = props?.payload as CadenceDatum;
                    return [`${value} days (${payload.orderCount} orders)`, payload.fullName];
                  }}
                />
                <Bar dataKey="cadence" fill="#58a6ff" radius={[0, 4, 4, 0]} barSize={18}>
                  {cadenceData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={entry.cadence < 14 ? '#f85149' : '#58a6ff'} />
                  ))}
                </Bar>
              </BarChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Velocity Chart */}
        <div className="bg-white border border-arda-border rounded-lg p-6">
          <h3 className="text-lg font-semibold text-arda-text-primary mb-4">Consumption Velocity</h3>
          <p className="text-arda-text-muted text-xs mb-4">Units consumed per day (burn rate)</p>
          <div className="h-72">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={velocityData} layout="vertical" margin={{ top: 5, right: 30, left: 10, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="#E5E7EB" horizontal={false} />
                <XAxis type="number" stroke="#6B7280" fontSize={12} tickLine={false} axisLine={false} />
                <YAxis
                  dataKey="name"
                  type="category"
                  stroke="#6B7280"
                  fontSize={10}
                  tickLine={false}
                  axisLine={false}
                  width={100}
                />
                <Tooltip
                  cursor={{ fill: '#F3F4F6' }}
                  contentStyle={{ background: '#FFFFFF', border: '1px solid #E5E7EB', color: '#111827' }}
                  formatter={(value, _name, props) => {
                    const payload = props?.payload as VelocityDatum;
                    return [`${value} units/day`, payload.fullName];
                  }}
                />
                <Bar dataKey="velocity" fill="#3fb950" radius={[0, 4, 4, 0]} barSize={18} />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>

      {/* Order Line Item History Table */}
      <div className="bg-white border border-arda-border rounded-lg overflow-hidden">
        <div className="p-4 border-b border-arda-border">
          <h3 className="text-lg font-semibold text-arda-text-primary">Order Line Item History</h3>
          <p className="text-arda-text-muted text-xs">Complete history of ordered items from emails</p>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-arda-bg-tertiary">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-arda-text-muted uppercase tracking-wider">Date</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-arda-text-muted uppercase tracking-wider">Supplier</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-arda-text-muted uppercase tracking-wider">Item Name</th>
                <th className="px-4 py-3 text-right text-xs font-medium text-arda-text-muted uppercase tracking-wider">Qty</th>
                <th className="px-4 py-3 text-right text-xs font-medium text-arda-text-muted uppercase tracking-wider">Unit Price</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-arda-border">
              {lineItemHistory.map((item, idx) => (
                <tr key={idx} className="hover:bg-arda-bg-tertiary/50 transition-colors">
                  <td className="px-4 py-3 text-sm text-arda-text-secondary">
                    {new Date(item.date).toLocaleDateString()}
                  </td>
                  <td className="px-4 py-3 text-sm text-arda-text-primary">{item.supplier}</td>
                  <td className="px-4 py-3 text-sm text-arda-text-primary font-medium">{item.itemName}</td>
                  <td className="px-4 py-3 text-sm text-arda-text-secondary text-right">{item.quantity}</td>
                  <td className="px-4 py-3 text-sm text-arda-text-secondary text-right">
                    {item.unitPrice > 0 ? `$${item.unitPrice.toFixed(2)}` : '—'}
                  </td>
                </tr>
              ))}
              {lineItemHistory.length === 0 && (
                <tr>
                  <td colSpan={5} className="px-4 py-8 text-center text-arda-text-muted">
                    No order history yet
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

```

### `src/views/ComposeEmail.tsx`

```tsx
import { useState, useEffect } from 'react';
import { Icons } from '../components/Icons';
import { sendGmailEmail } from '../services/gmailService';
import { improveEmailDraft } from '../services/geminiService';

interface ComposeEmailProps {
  gmailToken: string;
  isMockConnected: boolean;
  prefill?: { to: string, subject: string, body: string } | null;
  onClearDraft?: () => void;
  apiKey?: string; // Passed from parent for Gemini polish
}

export const ComposeEmail: React.FC<ComposeEmailProps> = ({ 
  gmailToken, 
  isMockConnected, 
  prefill, 
  onClearDraft,
  apiKey 
}) => {
  const [to, setTo] = useState('');
  const [cc, setCc] = useState('');
  const [bcc, setBcc] = useState('');
  const [subject, setSubject] = useState('');
  const [body, setBody] = useState('');
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [isImproving, setIsImproving] = useState(false);
  const [status, setStatus] = useState<{ type: 'success' | 'error' | null, message: string }>({ type: null, message: '' });

  // Handle pre-fill data from reorder buttons
  useEffect(() => {
    if (prefill) {
      setTo(prefill.to);
      setSubject(prefill.subject);
      setBody(prefill.body);
    }
  }, [prefill]);

  const handleImproveDraft = async () => {
    if (!body || !apiKey) {
      if (!apiKey) alert("Please configure your Gemini API Key in the Ingestion Engine first.");
      return;
    }
    
    setIsImproving(true);
    try {
      const polished = await improveEmailDraft(body, apiKey);
      setBody(polished);
    } catch (e) {
      console.error(e);
    } finally {
      setIsImproving(false);
    }
  };

  const handleSend = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!to || !subject || !body) {
      setStatus({ type: 'error', message: 'Please fill in the To, Subject, and Body fields.' });
      return;
    }

    if (!gmailToken && !isMockConnected) {
      setStatus({ type: 'error', message: 'Please connect to Gmail or Demo mode first.' });
      return;
    }

    setIsSending(true);
    setStatus({ type: null, message: '' });

    if (isMockConnected) {
      await new Promise(resolve => setTimeout(resolve, 1500));
      setStatus({ type: 'success', message: 'Simulation: Email sent successfully!' });
      resetForm();
    } else {
      const success = await sendGmailEmail(gmailToken, to, subject, body, cc, bcc);
      if (success) {
        setStatus({ type: 'success', message: 'Email sent successfully!' });
        resetForm();
      } else {
        setStatus({ type: 'error', message: 'Failed to send email. Check your connection.' });
      }
    }
    setIsSending(false);
  };

  const resetForm = () => {
    setTo('');
    setCc('');
    setBcc('');
    setSubject('');
    setBody('');
    if (onClearDraft) onClearDraft();
  };

  return (
    <div className="max-w-4xl mx-auto space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-arda-text-primary">Compose Message</h2>
          <p className="text-arda-text-muted text-sm">Send reorder requests or supplier inquiries directly.</p>
        </div>
        <div className="flex items-center gap-3">
          {prefill && (
            <div className="bg-arda-accent/10 border border-arda-accent/30 text-arda-accent px-3 py-1 rounded-full text-[10px] uppercase font-bold tracking-widest">
              Draft from Intelligence
            </div>
          )}
          {apiKey && (
            <button
              onClick={handleImproveDraft}
              disabled={isImproving || !body}
              className={`flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-bold transition-all border ${
                isImproving 
                  ? 'bg-arda-bg-tertiary border-arda-border text-arda-text-muted' 
                  : 'bg-arda-accent/10 border-arda-accent/30 text-arda-accent hover:bg-arda-accent hover:text-white'
              }`}
            >
              {isImproving ? <Icons.Loader2 className="w-3 h-3 animate-spin" /> : '✨'}
              {isImproving ? 'Improving...' : 'Improve with AI'}
            </button>
          )}
        </div>
      </div>

      <div className="bg-white border border-arda-border rounded-xl overflow-hidden shadow-arda transition-all duration-300">
        <form onSubmit={handleSend} className="divide-y divide-arda-border">
          {/* Recipient */}
          <div className="p-4 flex items-center gap-4 bg-arda-bg-secondary">
            <label className="text-arda-text-muted font-medium w-16 text-sm">To:</label>
            <div className="flex-1 relative flex items-center">
              <Icons.Mail className="absolute left-0 top-1/2 -translate-y-1/2 w-4 h-4 text-arda-text-muted" />
              <input 
                type="text" 
                value={to}
                onChange={(e) => setTo(e.target.value)}
                placeholder="supplier@example.com"
                className="w-full bg-transparent border-none text-arda-text-primary focus:ring-0 pl-7 py-1 text-sm placeholder:text-arda-text-muted"
                disabled={isSending}
              />
              <button 
                type="button"
                onClick={() => setShowAdvanced(!showAdvanced)}
                className="text-xs text-arda-accent hover:underline px-2"
              >
                {showAdvanced ? 'Hide CC/BCC' : 'Cc/Bcc'}
              </button>
            </div>
          </div>

          {/* CC & BCC (Optional) */}
          {showAdvanced && (
            <div className="bg-arda-bg-tertiary animate-in slide-in-from-top-2 duration-200">
              <div className="p-4 flex items-center gap-4 border-b border-arda-border/50">
                <label className="text-arda-text-muted font-medium w-16 text-sm">Cc:</label>
                <div className="flex-1 relative">
                  <input 
                    type="text" 
                    value={cc}
                    onChange={(e) => setCc(e.target.value)}
                    placeholder="accounts@yourbusiness.com"
                    className="w-full bg-transparent border-none text-arda-text-primary focus:ring-0 py-1 text-sm placeholder:text-arda-text-muted"
                    disabled={isSending}
                  />
                </div>
              </div>
              <div className="p-4 flex items-center gap-4">
                <label className="text-arda-text-muted font-medium w-16 text-sm">Bcc:</label>
                <div className="flex-1 relative">
                  <input 
                    type="text" 
                    value={bcc}
                    onChange={(e) => setBcc(e.target.value)}
                    placeholder="archive@yourbusiness.com"
                    className="w-full bg-transparent border-none text-arda-text-primary focus:ring-0 py-1 text-sm placeholder:text-arda-text-muted"
                    disabled={isSending}
                  />
                </div>
              </div>
            </div>
          )}

          {/* Subject */}
          <div className="p-4 flex items-center gap-4">
            <label className="text-arda-text-muted font-medium w-16 text-sm">Subject:</label>
            <input 
              type="text" 
              value={subject}
              onChange={(e) => setSubject(e.target.value)}
              placeholder="Order Inquiry / Restock Request"
              className="flex-1 bg-transparent border-none text-arda-text-primary focus:ring-0 py-1 text-sm placeholder:text-arda-text-muted font-medium"
              disabled={isSending}
            />
          </div>

          {/* Body */}
          <div className="p-4 bg-arda-bg-tertiary relative">
            <textarea 
              rows={12}
              value={body}
              onChange={(e) => setBody(e.target.value)}
              placeholder="Write your message here... Or type a quick note and use 'Improve with AI'"
              className="w-full bg-transparent border-none text-arda-text-primary focus:ring-0 text-sm placeholder:text-arda-text-muted resize-none leading-relaxed min-h-[300px]"
              disabled={isSending || isImproving}
            />
            {isImproving && (
              <div className="absolute inset-0 bg-white/40 backdrop-blur-[1px] flex items-center justify-center animate-pulse">
                <div className="text-arda-accent text-xs font-mono">Polishing draft...</div>
              </div>
            )}
          </div>

          {/* Footer */}
          <div className="p-4 bg-arda-bg-secondary flex items-center justify-between">
            <div className="flex items-center gap-2">
              {status.type === 'success' && (
                <span className="text-arda-success text-xs flex items-center gap-1 animate-in fade-in slide-in-from-left-2">
                  <Icons.CheckCircle2 className="w-3 h-3" /> {status.message}
                </span>
              )}
              {status.type === 'error' && (
                <span className="text-arda-danger text-xs flex items-center gap-1 animate-in fade-in slide-in-from-left-2">
                  <Icons.AlertCircle className="w-3 h-3" /> {status.message}
                </span>
              )}
            </div>
            
            <div className="flex gap-3">
              <button
                type="button"
                onClick={resetForm}
                className="text-arda-text-muted hover:text-arda-text-primary text-xs px-4"
                disabled={isSending}
              >
                Clear
              </button>
              <button
                type="submit"
                disabled={isSending || isImproving}
                className="bg-arda-accent text-white px-6 py-2 rounded-md font-bold text-sm hover:bg-blue-600 flex items-center gap-2 transition-all active:scale-95 disabled:opacity-50 shadow-lg shadow-blue-500/20"
              >
                {isSending ? (
                  <>
                    <Icons.Loader2 className="w-4 h-4 animate-spin" />
                    Sending...
                  </>
                ) : (
                  <>
                    <Icons.Send className="w-4 h-4" />
                    Send Email
                  </>
                )}
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
};

```

### `src/views/Dashboard.tsx`

```tsx
import { InventoryItem, ExtractedOrder } from '../types';
import { Icons } from '../components/Icons';
import { buildVelocityProfiles } from '../utils/inventoryLogic';
import { VelocityBadge } from '../components/VelocityBadge';
import { ReorderSparkline } from '../components/ReorderSparkline';

interface DashboardProps {
  orders: ExtractedOrder[];
  inventory: InventoryItem[];
  onReorder: (item: InventoryItem) => void;
}

export const Dashboard: React.FC<DashboardProps> = ({ orders, inventory, onReorder }) => {
  const totalSpend = orders.reduce((acc, curr) => acc + (curr.totalAmount || 0), 0);
  
  // Build velocity profiles
  const velocityProfiles = buildVelocityProfiles(orders);
  const profilesArray = Array.from(velocityProfiles.values());
  
  // Analytics calculations
  const avgCadence = inventory.length > 0
    ? Math.round(inventory.reduce((sum, i) => sum + i.averageCadenceDays, 0) / inventory.length)
    : 0;
  
  const fastestMover = inventory.length > 0
    ? inventory.reduce((fastest, item) => 
        item.dailyBurnRate > fastest.dailyBurnRate ? item : fastest
      , inventory[0])
    : null;

  const totalLineItems = orders.reduce((sum, o) => sum + o.items.length, 0);
  
  // Top Movers: Fastest by burn rate
  const topBurnRate = profilesArray
    .filter(p => p.dailyBurnRate > 0)
    .sort((a, b) => b.dailyBurnRate - a.dailyBurnRate)
    .slice(0, 3);
  
  // Top Movers: Shortest cadence (most frequently ordered)
  const topCadence = profilesArray
    .filter(p => p.averageCadenceDays > 0 && p.orderCount >= 2)
    .sort((a, b) => a.averageCadenceDays - b.averageCadenceDays)
    .slice(0, 3);
  
  // Next Orders: Items predicted to need reordering in next 7 days
  const today = new Date();
  const sevenDaysFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
  const nextOrders = profilesArray
    .filter(p => {
      if (!p.nextPredictedOrder) return false;
      const predictedDate = new Date(p.nextPredictedOrder);
      return predictedDate >= today && predictedDate <= sevenDaysFromNow;
    })
    .sort((a, b) => {
      const dateA = new Date(a.nextPredictedOrder!).getTime();
      const dateB = new Date(b.nextPredictedOrder!).getTime();
      return dateA - dateB;
    });
  
  const getUrgencyColor = (dateStr: string): { text: string; bg: string } => {
    const date = new Date(dateStr);
    const daysUntil = Math.ceil((date.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
    if (daysUntil <= 2) return { text: 'text-red-500', bg: 'bg-red-500' };
    if (daysUntil <= 4) return { text: 'text-orange-500', bg: 'bg-orange-500' };
    return { text: 'text-yellow-500', bg: 'bg-yellow-500' };
  };

  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold text-arda-text-primary">Overview</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <StatsCard 
          title="Total Orders" 
          value={orders.length.toString()} 
          icon="Inbox"
          subtitle={totalLineItems > 0 ? `${totalLineItems} line items` : undefined}
        />
        <StatsCard 
          title="Unique Items" 
          value={inventory.length.toString()} 
          icon="Package"
        />
        <StatsCard 
          title="Avg Cadence" 
          value={avgCadence > 0 ? `${avgCadence} days` : '—'} 
          icon="Calendar"
          subtitle="Between orders"
        />
        <StatsCard 
          title="Est. Spend" 
          value={`$${totalSpend.toLocaleString()}`} 
          icon="DollarSign"
          highlight
        />
      </div>

      {/* Fastest Mover Highlight */}
      {fastestMover && fastestMover.dailyBurnRate > 0 && (
        <div className="bg-gradient-to-r from-orange-50 to-amber-50 border border-orange-200 rounded-xl p-4 flex items-center gap-4">
          <div className="bg-orange-100 p-3 rounded-lg">
            <Icons.TrendingUp className="w-6 h-6 text-arda-accent" />
          </div>
          <div className="flex-1">
            <div className="text-sm text-arda-text-secondary">Fastest Moving Item</div>
            <div className="text-lg font-semibold text-arda-text-primary">{fastestMover.name}</div>
            <div className="text-xs text-arda-text-muted">
              {fastestMover.dailyBurnRate.toFixed(1)} units/day • From {fastestMover.supplier}
            </div>
          </div>
        </div>
      )}

      {/* Top Movers Section */}
      {(topBurnRate.length > 0 || topCadence.length > 0) && (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Top Burn Rate */}
          {topBurnRate.length > 0 && (
            <div className="bg-white border border-arda-border rounded-xl shadow-arda p-4">
              <h3 className="text-sm font-semibold text-arda-text-primary mb-3 flex items-center gap-2">
                <Icons.Zap className="w-4 h-4 text-arda-accent" />
                Fastest Moving
              </h3>
              <div className="space-y-2">
                {topBurnRate.map((profile, idx) => (
                  <div key={profile.normalizedName} className="flex items-center justify-between p-2 rounded-lg hover:bg-arda-bg-tertiary transition-colors">
                    <div className="flex items-center gap-2 flex-1 min-w-0">
                      <span className="text-xs font-medium text-arda-text-muted w-5">{idx + 1}.</span>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-arda-text-primary truncate">{profile.displayName}</div>
                        <div className="text-xs text-arda-text-muted truncate">{profile.supplier}</div>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      {profile.orders.length >= 2 && (
                        <div className="hidden sm:block">
                          <ReorderSparkline
                            orders={profile.orders.map(o => ({ date: o.date, quantity: o.quantity }))}
                            width={60}
                            height={20}
                          />
                        </div>
                      )}
                      <VelocityBadge
                        dailyBurnRate={profile.dailyBurnRate}
                        averageCadenceDays={profile.averageCadenceDays}
                        orderCount={profile.orderCount}
                        compact
                      />
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Top Cadence */}
          {topCadence.length > 0 && (
            <div className="bg-white border border-arda-border rounded-xl shadow-arda p-4">
              <h3 className="text-sm font-semibold text-arda-text-primary mb-3 flex items-center gap-2">
                <Icons.Calendar className="w-4 h-4 text-arda-accent" />
                Most Frequent Orders
              </h3>
              <div className="space-y-2">
                {topCadence.map((profile, idx) => (
                  <div key={profile.normalizedName} className="flex items-center justify-between p-2 rounded-lg hover:bg-arda-bg-tertiary transition-colors">
                    <div className="flex items-center gap-2 flex-1 min-w-0">
                      <span className="text-xs font-medium text-arda-text-muted w-5">{idx + 1}.</span>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-arda-text-primary truncate">{profile.displayName}</div>
                        <div className="text-xs text-arda-text-muted truncate">{profile.supplier}</div>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      {profile.orders.length >= 2 && (
                        <div className="hidden sm:block">
                          <ReorderSparkline
                            orders={profile.orders.map(o => ({ date: o.date, quantity: o.quantity }))}
                            width={60}
                            height={20}
                          />
                        </div>
                      )}
                      <div className="text-xs text-arda-text-muted">
                        {Math.round(profile.averageCadenceDays)}d cadence
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}

      {/* Next Orders Section */}
      {nextOrders.length > 0 && (
        <div className="bg-white border border-arda-border rounded-xl shadow-arda p-4">
          <h3 className="text-sm font-semibold text-arda-text-primary mb-3 flex items-center gap-2">
            <Icons.Clock className="w-4 h-4 text-arda-accent" />
            Next Orders (Next 7 Days)
          </h3>
          <div className="space-y-2">
            {nextOrders.map((profile) => {
              const daysUntil = Math.ceil((new Date(profile.nextPredictedOrder!).getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
              const urgency = getUrgencyColor(profile.nextPredictedOrder!);
              return (
                <div key={profile.normalizedName} className="flex items-center justify-between p-2 rounded-lg hover:bg-arda-bg-tertiary transition-colors">
                  <div className="flex items-center gap-2 flex-1 min-w-0">
                    <div className={`w-2 h-2 rounded-full ${urgency.bg}`} />
                    <div className="flex-1 min-w-0">
                      <div className="text-sm font-medium text-arda-text-primary truncate">{profile.displayName}</div>
                      <div className="text-xs text-arda-text-muted truncate">{profile.supplier}</div>
                    </div>
                  </div>
                  <div className="flex items-center gap-3">
                    <VelocityBadge
                      dailyBurnRate={profile.dailyBurnRate}
                      averageCadenceDays={profile.averageCadenceDays}
                      orderCount={profile.orderCount}
                      compact
                    />
                    <div className={`text-xs font-medium ${urgency.text}`}>
                      {daysUntil === 0 ? 'Today' : daysUntil === 1 ? 'Tomorrow' : `${daysUntil}d`}
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2 bg-white border border-arda-border rounded-xl shadow-arda p-6">
          <h3 className="text-lg font-semibold text-arda-text-primary mb-4">Recent Activity</h3>
          <div className="space-y-4">
            {orders.length === 0 ? (
               <div className="text-sm text-arda-text-muted italic">No orders processed yet.</div>
            ) : (
              orders.slice(0, 5).map((order) => (
                <div key={order.id} className="flex items-center justify-between border-b border-arda-border pb-3 last:border-0 last:pb-0">
                  <div className="flex items-center gap-3">
                    <div className="w-8 h-8 rounded-lg bg-orange-50 flex items-center justify-center">
                      <Icons.Inbox className="w-4 h-4 text-arda-accent" />
                    </div>
                    <div>
                      <div className="text-arda-text-primary text-sm font-medium">{order.supplier}</div>
                      <div className="text-xs text-arda-text-muted">{new Date(order.orderDate).toLocaleDateString()}</div>
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="text-arda-text-primary text-sm font-mono font-semibold">${order.totalAmount?.toFixed(2)}</div>
                    <div className="text-xs text-arda-text-muted">{order.items.length} items</div>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>

        <div className="bg-white border border-arda-border rounded-xl shadow-arda p-6">
          <h3 className="text-lg font-semibold text-arda-text-primary mb-4">Reorder Alerts</h3>
          <div className="space-y-3">
             {inventory.filter(i => i.recommendedOrderQty > 5).length === 0 && (
                <div className="text-sm text-arda-text-muted">All stock levels healthy.</div>
             )}
             {inventory.filter(i => i.recommendedOrderQty > 5).slice(0, 5).map(item => (
               <div key={item.id} className="bg-red-50 p-3 rounded-lg border border-red-100 flex items-center justify-between group hover:shadow-arda transition-shadow">
                 <div className="truncate flex-1 pr-2">
                   <div className="text-sm text-arda-text-primary font-medium truncate">{item.name}</div>
                   <div className="text-xs text-arda-danger">Low Stock Alert</div>
                 </div>
                 <button 
                  onClick={() => onReorder(item)}
                  className="bg-arda-accent hover:bg-arda-accent-hover text-white w-8 h-8 rounded-lg flex items-center justify-center transition-all opacity-0 group-hover:opacity-100 shadow-lg shadow-orange-500/20"
                  title="Quick Reorder"
                 >
                   <Icons.Send className="w-4 h-4" />
                 </button>
                 <div className="text-right group-hover:hidden">
                   <div className="text-xs text-arda-text-muted">Rec. Qty</div>
                   <div className="text-sm font-mono text-arda-accent font-semibold">{item.recommendedOrderQty}</div>
                 </div>
               </div>
             ))}
          </div>
        </div>
      </div>
    </div>
  );
};

interface StatsCardProps {
  title: string;
  value: string;
  icon: keyof typeof Icons;
  trend?: string;
  subtitle?: string;
  highlight?: boolean;
}

const StatsCard: React.FC<StatsCardProps> = ({ title, value, icon, trend, subtitle, highlight }) => {
  const Icon = Icons[icon];
  return (
    <div className={`p-6 rounded-xl border shadow-arda ${highlight ? 'bg-orange-50 border-orange-200' : 'bg-white border-arda-border'}`}>
      <div className="flex justify-between items-start mb-2">
        <span className="text-arda-text-secondary text-sm font-medium">{title}</span>
        <Icon className={`w-5 h-5 ${highlight ? 'text-arda-accent' : 'text-arda-text-muted'}`} />
      </div>
      <div className="text-2xl font-bold text-arda-text-primary tracking-tight">{value}</div>
      {subtitle && <div className="text-xs text-arda-text-muted mt-1">{subtitle}</div>}
      {trend && <div className="text-xs text-arda-success mt-1">{trend} from last month</div>}
    </div>
  );
};

```

### `src/views/IntegrationsStep.tsx`

```tsx
import { useCallback, useEffect, useMemo, useState } from 'react';
import { Icons } from '../components/Icons';
import {
  IntegrationConnection,
  IntegrationSyncRun,
  integrationsApi,
  isSessionExpiredError,
} from '../services/api';

interface Integration {
  name: string;
  category: 'erp' | 'inventory';
  description: string;
}

const INTEGRATIONS: Integration[] = [
  {
    name: 'NetSuite',
    category: 'erp',
    description: 'Cloud ERP for finance, operations, and supply chain.',
  },
  {
    name: 'Odoo',
    category: 'erp',
    description: 'Modular ERP platform for inventory, purchasing, and manufacturing.',
  },
  {
    name: 'Katana',
    category: 'inventory',
    description: 'Cloud inventory and manufacturing planning.',
  },
  {
    name: 'Fishbowl',
    category: 'inventory',
    description: 'Inventory and warehouse management with operations workflows.',
  },
  {
    name: 'Cin7',
    category: 'inventory',
    description: 'Multi-channel inventory and order orchestration.',
  },
  {
    name: 'Finale Inventory',
    category: 'inventory',
    description: 'Warehouse and inventory control with barcode operations.',
  },
  {
    name: 'SOS Inventory',
    category: 'inventory',
    description: 'Inventory and order management focused on SMB operations.',
  },
  {
    name: 'Sortly',
    category: 'inventory',
    description: 'Simple inventory tracking with mobile-first workflows.',
  },
];

const CATEGORY_CONFIG = {
  erp: {
    title: 'Cloud ERP',
    icon: Icons.Building2,
  },
  inventory: {
    title: 'Inventory Solutions',
    icon: Icons.Package,
  },
} as const;

const SESSION_EXPIRED_MESSAGE = 'Session expired. Please sign in again.';
type LatestRun = IntegrationSyncRun | NonNullable<IntegrationConnection['lastRun']>;

function hasSyncCounts(run: LatestRun): run is IntegrationSyncRun {
  return 'ordersUpserted' in run && 'itemsUpserted' in run;
}

export const IntegrationsStep: React.FC = () => {
  const [connections, setConnections] = useState<IntegrationConnection[]>([]);
  const [runsByConnection, setRunsByConnection] = useState<Record<string, IntegrationSyncRun | undefined>>({});
  const [notice, setNotice] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [actionKey, setActionKey] = useState<string | null>(null);

  const getErrorMessage = useCallback((input: unknown, fallback: string): string => {
    if (isSessionExpiredError(input)) {
      return SESSION_EXPIRED_MESSAGE;
    }
    return input instanceof Error && input.message ? input.message : fallback;
  }, []);

  const loadConnections = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const { connections: loadedConnections } = await integrationsApi.listConnections();
      setConnections(loadedConnections);

      const runPairs = await Promise.all(
        loadedConnections.map(async (connection) => {
          try {
            const { runs } = await integrationsApi.getConnectionRuns(connection.id);
            return [connection.id, runs[0]] as const;
          } catch {
            return [connection.id, undefined] as const;
          }
        }),
      );

      const nextRuns: Record<string, IntegrationSyncRun | undefined> = {};
      runPairs.forEach(([connectionId, run]) => {
        nextRuns[connectionId] = run;
      });
      setRunsByConnection(nextRuns);
    } catch (loadError) {
      const message = getErrorMessage(loadError, 'Failed to load accounting integrations.');
      if (!message.toLowerCase().includes('disabled')) {
        setError(message);
      }
      setConnections([]);
      setRunsByConnection({});
    } finally {
      setIsLoading(false);
    }
  }, [getErrorMessage]);

  const handleConnect = useCallback(async (provider: 'quickbooks' | 'xero') => {
    setActionKey(`connect:${provider}`);
    setError(null);
    setNotice(null);
    try {
      const { authUrl } = await integrationsApi.connectProvider(provider);
      window.location.assign(authUrl);
    } catch (connectError) {
      setError(getErrorMessage(connectError, `Failed to connect ${provider}.`));
    } finally {
      setActionKey(null);
    }
  }, [getErrorMessage]);

  const handleSync = useCallback(async (connectionId: string) => {
    setActionKey(`sync:${connectionId}`);
    setError(null);
    try {
      await integrationsApi.syncConnection(connectionId);
      setNotice('Sync started. Refreshing status shortly...');
      window.setTimeout(() => {
        void loadConnections();
      }, 2500);
    } catch (syncError) {
      setError(getErrorMessage(syncError, 'Failed to start provider sync.'));
    } finally {
      setActionKey(null);
    }
  }, [getErrorMessage, loadConnections]);

  const handleDisconnect = useCallback(async (connectionId: string) => {
    setActionKey(`disconnect:${connectionId}`);
    setError(null);
    try {
      await integrationsApi.disconnectConnection(connectionId);
      setNotice('Integration disconnected.');
      await loadConnections();
    } catch (disconnectError) {
      setError(getErrorMessage(disconnectError, 'Failed to disconnect integration.'));
    } finally {
      setActionKey(null);
    }
  }, [getErrorMessage, loadConnections]);

  useEffect(() => {
    void loadConnections();
  }, [loadConnections]);

  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const provider = params.get('integration_provider');
    const status = params.get('integration_status');
    const reason = params.get('integration_reason');

    if (!provider || !status) return;

    if (status === 'connected') {
      setNotice(`${provider === 'quickbooks' ? 'QuickBooks' : 'Xero'} connected. Initial backfill started.`);
    } else {
      setError(reason || `Failed to connect ${provider}.`);
    }

    params.delete('integration_provider');
    params.delete('integration_status');
    params.delete('integration_reason');
    const nextQuery = params.toString();
    const nextUrl = `${window.location.pathname}${nextQuery ? `?${nextQuery}` : ''}${window.location.hash || ''}`;
    window.history.replaceState({}, document.title, nextUrl);
  }, []);

  const connectionByProvider = useMemo(() => {
    const map = new Map<'quickbooks' | 'xero', IntegrationConnection>();
    for (const connection of connections) {
      if (connection.provider === 'quickbooks' || connection.provider === 'xero') {
        map.set(connection.provider, connection);
      }
    }
    return map;
  }, [connections]);

  const grouped = useMemo(() => ({
    erp: INTEGRATIONS.filter(integration => integration.category === 'erp'),
    inventory: INTEGRATIONS.filter(integration => integration.category === 'inventory'),
  }), []);

  return (
    <div className="space-y-4">
      <section className="border-2 border-emerald-200 bg-emerald-50 rounded-2xl p-6 space-y-4">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-xl font-bold text-arda-text-primary">Accounting Integrations</h3>
            <p className="text-sm text-arda-text-secondary">
              Import purchase orders from QuickBooks and Xero into Orders.
            </p>
          </div>
          {isLoading && (
            <div className="flex items-center gap-2 text-emerald-700 text-sm">
              <Icons.Loader2 className="w-4 h-4 animate-spin" />
              Refreshing
            </div>
          )}
        </div>

        {notice && (
          <div className="bg-emerald-100 border border-emerald-300 rounded-lg px-3 py-2 text-sm text-emerald-800">
            {notice}
          </div>
        )}

        {error && (
          <div className="bg-red-50 border border-red-200 rounded-lg px-3 py-2 text-sm text-red-700">
            {error}
          </div>
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {(['quickbooks', 'xero'] as const).map(provider => {
            const connection = connectionByProvider.get(provider);
            const latestRun: LatestRun | undefined = connection
              ? (runsByConnection[connection.id] || connection.lastRun)
              : undefined;
            const providerLabel = provider === 'quickbooks' ? 'QuickBooks' : 'Xero';
            const isConnected = Boolean(connection && connection.status === 'connected');
            const statusText = !connection
              ? 'Not connected'
              : connection.status === 'connected'
                ? `Connected${connection.tenantName ? ` • ${connection.tenantName}` : ''}`
                : connection.status === 'reauth_required'
                  ? 'Reconnect required'
                  : connection.status;
            const runSummary = latestRun
              ? latestRun.status === 'failed'
                ? latestRun.error || 'Last sync failed'
                : latestRun.status === 'running'
                  ? 'Sync in progress'
                  : (() => {
                    if (hasSyncCounts(latestRun)) {
                      return `Last sync: ${latestRun.ordersUpserted} orders, ${latestRun.itemsUpserted} items`;
                    }
                    return 'Last sync completed';
                  })()
              : 'No sync runs yet';

            const connectActionKey = `connect:${provider}`;
            const syncActionKey = connection ? `sync:${connection.id}` : '';
            const disconnectActionKey = connection ? `disconnect:${connection.id}` : '';

            return (
              <div key={provider} className="bg-white border border-emerald-200 rounded-xl p-4 space-y-3">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Icons.Link className="w-4 h-4 text-emerald-700" />
                    <span className="font-semibold text-arda-text-primary">{providerLabel}</span>
                  </div>
                  <span className={`text-xs px-2 py-1 rounded-full ${
                    isConnected ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'
                  }`}>
                    {statusText}
                  </span>
                </div>

                <p className="text-xs text-arda-text-secondary">{runSummary}</p>

                <div className="flex items-center gap-2">
                  {!isConnected ? (
                    <button
                      type="button"
                      onClick={() => void handleConnect(provider)}
                      disabled={actionKey !== null}
                      className="px-3 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-700 text-white text-sm font-medium disabled:opacity-60 disabled:cursor-not-allowed"
                    >
                      {actionKey === connectActionKey ? 'Connecting...' : connection?.status === 'reauth_required' ? `Reconnect ${providerLabel}` : `Connect ${providerLabel}`}
                    </button>
                  ) : (
                    <>
                      <button
                        type="button"
                        onClick={() => connection && void handleSync(connection.id)}
                        disabled={actionKey !== null}
                        className="px-3 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium disabled:opacity-60 disabled:cursor-not-allowed flex items-center gap-1"
                      >
                        <Icons.RefreshCw className={`w-3.5 h-3.5 ${actionKey === syncActionKey ? 'animate-spin' : ''}`} />
                        {actionKey === syncActionKey ? 'Syncing...' : 'Sync now'}
                      </button>
                      <button
                        type="button"
                        onClick={() => connection && void handleDisconnect(connection.id)}
                        disabled={actionKey !== null}
                        className="px-3 py-2 rounded-lg border border-gray-300 text-sm font-medium text-arda-text-secondary hover:bg-gray-50 disabled:opacity-60 disabled:cursor-not-allowed"
                      >
                        {actionKey === disconnectActionKey ? 'Disconnecting...' : 'Disconnect'}
                      </button>
                    </>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      </section>

      {(Object.keys(grouped) as Array<keyof typeof grouped>).map(category => {
        const config = CATEGORY_CONFIG[category];
        const CategoryIcon = config.icon;

        return (
          <section key={category} className="bg-white border border-arda-border rounded-2xl p-5 shadow-sm">
            <div className="flex items-center gap-2 mb-4">
              <CategoryIcon className="w-4 h-4 text-arda-accent" />
              <h3 className="text-sm font-semibold text-arda-text-primary">{config.title}</h3>
            </div>

            <div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
              {grouped[category].map(integration => (
                <article
                  key={integration.name}
                  className="rounded-xl border border-arda-border bg-arda-bg-secondary/30 p-3"
                >
                  <div className="flex items-center justify-between gap-2">
                    <p className="font-medium text-sm text-arda-text-primary">{integration.name}</p>
                    <span className="text-[11px] font-medium rounded-full border border-arda-border px-2 py-0.5 text-arda-text-muted">
                      Coming soon
                    </span>
                  </div>
                  <p className="mt-1 text-xs text-arda-text-secondary leading-relaxed">
                    {integration.description}
                  </p>
                </article>
              ))}
            </div>
          </section>
        );
      })}
    </div>
  );
};

```

### `src/views/InventoryView.tsx`

```tsx
import { useState, useCallback } from 'react';
import { InventoryItem, ItemColor, ReviewStatus } from '../types';
import { Icons } from '../components/Icons';
import { ardaApi, ArdaItemInput, ArdaTenantResolutionDetails, isApiRequestError } from '../services/api';
import { exportItemsToCSV } from '../utils/exportUtils';

interface InventoryViewProps {
  inventory: InventoryItem[];
  onReorder?: (item: InventoryItem) => void;
  onUpdateItem?: (id: string, updates: Partial<InventoryItem>) => void;
  title?: string;
  subtitle?: string;
  showBulkSync?: boolean;
  showHistoryAction?: boolean;
  showReorderAction?: boolean;
  emptyMessage?: string;
  reviewStatusById?: Record<string, ReviewStatus>;
  onReviewStatusChange?: (id: string, status: ReviewStatus) => void;
  showReviewColumn?: boolean;
  onAmazonLookup?: (item: InventoryItem) => void;
  showAmazonLookupAction?: boolean;
  amazonLookupLoadingIds?: Set<string>;
}

// Available colors for the color picker
const ITEM_COLORS: ItemColor[] = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Gray', 'Pink', 'Purple'];

// Color to Tailwind class mapping
const colorClasses: Record<ItemColor, string> = {
  Red: 'bg-red-500',
  Orange: 'bg-orange-500',
  Yellow: 'bg-yellow-400',
  Green: 'bg-green-500',
  Blue: 'bg-blue-500',
  Gray: 'bg-gray-400',
  Pink: 'bg-pink-400',
  Purple: 'bg-purple-500',
};

// Editable cell component
const EditableCell: React.FC<{
  value: string | number | undefined;
  type?: 'text' | 'number' | 'url';
  onSave: (value: string | number) => void;
  className?: string;
  placeholder?: string;
}> = ({ value, type = 'text', onSave, className = '', placeholder = '—' }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(String(value ?? ''));

  const handleSave = () => {
    setIsEditing(false);
    const newValue = type === 'number' ? parseFloat(editValue) || 0 : editValue;
    if (newValue !== value) {
      onSave(newValue);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') handleSave();
    if (e.key === 'Escape') {
      setEditValue(String(value ?? ''));
      setIsEditing(false);
    }
  };

  if (isEditing) {
    return (
      <input
        type={type}
        value={editValue}
        onChange={(e) => setEditValue(e.target.value)}
        onBlur={handleSave}
        onKeyDown={handleKeyDown}
        autoFocus
        aria-label="Edit value"
        placeholder={placeholder}
        className={`w-full px-2 py-1 text-sm border border-arda-accent rounded bg-white focus:outline-none focus:ring-2 focus:ring-arda-accent/30 ${className}`}
      />
    );
  }

  return (
    <div
      onClick={() => {
        setEditValue(String(value ?? ''));
        setIsEditing(true);
      }}
      className={`cursor-pointer hover:bg-arda-bg-tertiary px-2 py-1 rounded transition-colors min-h-[28px] ${className}`}
    >
      {value !== undefined && value !== '' ? (
        type === 'url' && value ? (
          <a 
            href={String(value)} 
            target="_blank" 
            rel="noopener noreferrer" 
            className="text-arda-accent hover:underline truncate block max-w-[120px]"
            onClick={(e) => e.stopPropagation()}
          >
            {String(value).replace(/^https?:\/\//, '').substring(0, 20)}...
          </a>
        ) : (
          value
        )
      ) : (
        <span className="text-arda-text-muted italic">{placeholder}</span>
      )}
    </div>
  );
};

// Color picker component
const ColorPicker: React.FC<{
  value?: ItemColor;
  onSelect: (color: ItemColor | undefined) => void;
}> = ({ value, onSelect }) => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-8 h-8 rounded-lg border border-arda-border hover:border-arda-accent transition-colors flex items-center justify-center"
      >
        {value ? (
          <span className={`w-5 h-5 rounded-full ${colorClasses[value]}`} />
        ) : (
          <span className="w-5 h-5 rounded-full border-2 border-dashed border-arda-border" />
        )}
      </button>
      
      {isOpen && (
        <>
          <div className="fixed inset-0 z-10" onClick={() => setIsOpen(false)} />
          <div className="absolute top-10 left-0 z-20 bg-white border border-arda-border rounded-lg shadow-lg p-2 grid grid-cols-4 gap-1 min-w-[120px]">
            {ITEM_COLORS.map((color) => (
              <button
                key={color}
                onClick={() => {
                  onSelect(color);
                  setIsOpen(false);
                }}
                className={`w-6 h-6 rounded-full ${colorClasses[color]} hover:ring-2 ring-offset-1 ring-arda-accent transition-all ${
                  value === color ? 'ring-2 ring-arda-accent' : ''
                }`}
                title={color}
              />
            ))}
            <button
              onClick={() => {
                onSelect(undefined);
                setIsOpen(false);
              }}
              className="w-6 h-6 rounded-full border-2 border-dashed border-gray-300 hover:border-arda-accent transition-colors flex items-center justify-center text-gray-400 text-xs"
              title="No color"
            >
              ✕
            </button>
          </div>
        </>
      )}
    </div>
  );
};

export const InventoryView: React.FC<InventoryViewProps> = ({
  inventory,
  onReorder,
  onUpdateItem,
  title = 'Inventory Intelligence',
  subtitle,
  showBulkSync = true,
  showHistoryAction = true,
  showReorderAction = true,
  emptyMessage,
  reviewStatusById,
  onReviewStatusChange,
  showReviewColumn = false,
  onAmazonLookup,
  showAmazonLookupAction = false,
  amazonLookupLoadingIds,
}) => {
  const reviewBadgeClasses: Record<ReviewStatus, string> = {
    pending: 'bg-yellow-50 text-yellow-700 border-yellow-200',
    approved: 'bg-green-50 text-green-700 border-green-200',
    excluded: 'bg-red-50 text-red-700 border-red-200',
  };
  const [historyItem, setHistoryItem] = useState<InventoryItem | null>(null);
  const [syncingItems, setSyncingItems] = useState<Set<string>>(new Set());
  const [syncResults, setSyncResults] = useState<Record<string, 'success' | 'error' | null>>({});
  const [, setSyncErrors] = useState<Record<string, string>>({});
  const [isBulkSyncing, setIsBulkSyncing] = useState(false);
  const [bulkSyncError, setBulkSyncError] = useState<string | null>(null);
  // Local state for items when no external handler
  const [localItems, setLocalItems] = useState<InventoryItem[]>(inventory);

  // Use provided items or local state
  const items = onUpdateItem ? inventory : localItems;

  const resolveTenantForSync = useCallback(async (details?: ArdaTenantResolutionDetails): Promise<boolean> => {
    if (!details?.canCreateTenant) {
      return false;
    }

    try {
      const resolution = await ardaApi.resolveTenant('create_new');
      return resolution.success;
    } catch {
      return false;
    }
  }, []);

  const exportInventoryItemsFallback = useCallback((itemsToExport: InventoryItem[]) => {
    exportItemsToCSV(
      itemsToExport.map((item) => ({
        source: 'inventory',
        name: item.name,
        supplier: item.supplier,
        location: item.location,
        orderMethod: 'email',
        minQty: item.recommendedMin,
        orderQty: item.recommendedOrderQty,
        unitPrice: item.lastPrice,
        asin: item.asin,
        productUrl: item.productUrl,
        imageUrl: item.imageUrl,
        color: item.color,
      })),
      'inventory-tenant-unresolved'
    );
  }, []);

  // Update handler
  const handleUpdate = useCallback((id: string, updates: Partial<InventoryItem>) => {
    if (onUpdateItem) {
      onUpdateItem(id, updates);
    } else {
      setLocalItems(prev => prev.map(item => 
        item.id === id ? { ...item, ...updates } : item
      ));
    }
  }, [onUpdateItem]);

  // Sync single item to Arda
  const handleSyncToArda = async (item: InventoryItem) => {
    setSyncingItems(prev => new Set(prev).add(item.id));
    setSyncResults(prev => ({ ...prev, [item.id]: null }));
    setSyncErrors(prev => ({ ...prev, [item.id]: '' }));

    try {
      const ardaItem: ArdaItemInput = {
        name: item.name,
        orderMechanism: 'email',
        minQty: item.recommendedMin,
        minQtyUnit: 'each',
        primarySupplier: item.supplier,
        orderQty: item.recommendedOrderQty,
        orderQtyUnit: 'each',
        location: item.location,
        primarySupplierLink: item.productUrl,
        imageUrl: item.imageUrl,
      };
      try {
        await ardaApi.createItem(ardaItem);
      } catch (error) {
        if (isApiRequestError(error) && error.code === 'TENANT_REQUIRED') {
          const resolved = await resolveTenantForSync(error.details as ArdaTenantResolutionDetails | undefined);
          if (resolved) {
            await ardaApi.createItem(ardaItem);
          } else {
            const tenantDetails = error.details as ArdaTenantResolutionDetails | undefined;
            const unresolvedMessage = tenantDetails?.autoProvisionError
              || tenantDetails?.message
              || error.message
              || 'Tenant could not be auto-provisioned.';
            exportInventoryItemsFallback([item]);
            throw new Error(
              `${unresolvedMessage} Exported item to CSV.`
            );
          }
        } else {
          throw error;
        }
      }

      setSyncResults(prev => ({ ...prev, [item.id]: 'success' }));
      // Mark as no longer draft
      handleUpdate(item.id, { isDraft: false });
    } catch (error) {
      console.error('Failed to sync to Arda:', error);
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      setSyncResults(prev => ({ ...prev, [item.id]: 'error' }));
      setSyncErrors(prev => ({ ...prev, [item.id]: errorMsg }));
    } finally {
      setSyncingItems(prev => {
        const next = new Set(prev);
        next.delete(item.id);
        return next;
      });
    }
  };

  // Bulk sync all items to Arda
  const handleBulkSync = async () => {
    setIsBulkSyncing(true);
    setBulkSyncError(null);
    try {
      const ardaItems: ArdaItemInput[] = items.map(item => ({
        name: item.name,
        orderMechanism: 'email',
        minQty: item.recommendedMin,
        minQtyUnit: 'each',
        primarySupplier: item.supplier,
        orderQty: item.recommendedOrderQty,
        orderQtyUnit: 'each',
        location: item.location,
        primarySupplierLink: item.productUrl,
        imageUrl: item.imageUrl,
      }));
      let result = await ardaApi.bulkCreateItems(ardaItems);
      if (!result.success && result.code === 'TENANT_REQUIRED') {
        const resolved = await resolveTenantForSync(result.details);
        if (resolved) {
          result = await ardaApi.bulkCreateItems(ardaItems);
        } else {
          const unresolvedMessage = result.details?.autoProvisionError
            || result.details?.message
            || result.error
            || 'Tenant could not be auto-provisioned.';
          exportInventoryItemsFallback(items);
          setBulkSyncError(`${unresolvedMessage} Exported items to CSV.`);
          return;
        }
      }
      
      // Check for overall success
      if (!result.success && result.error) {
        setBulkSyncError(result.error);
        if (result.details) {
          setBulkSyncError(`${result.error}: ${result.details.message || JSON.stringify(result.details)}`);
        }
      }
      
      result.results?.forEach((r, i: number) => {
        const status = (r as { status?: string }).status;
        const errorMsg = (r as { error?: string }).error;
        if (items[i]) {
          setSyncResults(prev => ({
            ...prev,
            [items[i].id]: status === 'fulfilled' ? 'success' : 'error',
          }));
          if (errorMsg) {
            setSyncErrors(prev => ({ ...prev, [items[i].id]: errorMsg }));
          }
          if (status === 'fulfilled') {
            handleUpdate(items[i].id, { isDraft: false });
          }
        }
      });
    } catch (error) {
      console.error('Bulk sync failed:', error);
      if (isApiRequestError(error) && error.code === 'TENANT_REQUIRED') {
        try {
          const resolved = await resolveTenantForSync(error.details as ArdaTenantResolutionDetails | undefined);
          if (resolved) {
            const ardaItems: ArdaItemInput[] = items.map(item => ({
              name: item.name,
              orderMechanism: 'email',
              minQty: item.recommendedMin,
              minQtyUnit: 'each',
              primarySupplier: item.supplier,
              orderQty: item.recommendedOrderQty,
              orderQtyUnit: 'each',
              location: item.location,
              primarySupplierLink: item.productUrl,
              imageUrl: item.imageUrl,
            }));
            const retryResult = await ardaApi.bulkCreateItems(ardaItems);
            if (!retryResult.success && retryResult.error) {
              setBulkSyncError(retryResult.details?.message || retryResult.error);
            }
            retryResult.results?.forEach((r, i: number) => {
              const status = (r as { status?: string }).status;
              const errorMsg = (r as { error?: string }).error;
              if (items[i]) {
                setSyncResults(prev => ({
                  ...prev,
                  [items[i].id]: status === 'fulfilled' ? 'success' : 'error',
                }));
                if (errorMsg) {
                  setSyncErrors(prev => ({ ...prev, [items[i].id]: errorMsg }));
                }
                if (status === 'fulfilled') {
                  handleUpdate(items[i].id, { isDraft: false });
                }
              }
            });
            return;
          }
          exportInventoryItemsFallback(items);
          const tenantDetails = error.details as ArdaTenantResolutionDetails | undefined;
          const unresolvedMessage = tenantDetails?.autoProvisionError
            || tenantDetails?.message
            || error.message
            || 'Tenant could not be auto-provisioned.';
          setBulkSyncError(`${unresolvedMessage} Exported items to CSV.`);
          return;
        } catch (retryError) {
          const retryMsg = retryError instanceof Error ? retryError.message : 'Unknown error';
          setBulkSyncError(retryMsg);
          return;
        }
      }
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      setBulkSyncError(errorMsg);
    } finally {
      setIsBulkSyncing(false);
    }
  };

  if (items.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-96 text-arda-text-muted">
        <Icons.Package className="w-16 h-16 mb-4 opacity-20 text-arda-accent" />
        <p>{emptyMessage || 'No inventory data derived yet. Go to Ingestion Engine to process emails.'}</p>
      </div>
    );
  }

  // Sort: drafts first, then by name
  const sortedItems = [...items].sort((a, b) => {
    if (a.isDraft && !b.isDraft) return -1;
    if (!a.isDraft && b.isDraft) return 1;
    return a.name.localeCompare(b.name);
  });

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold text-arda-text-primary">{title}</h2>
          {subtitle && (
            <p className="text-xs text-arda-text-secondary mt-1">{subtitle}</p>
          )}
        </div>
        <div className="flex gap-2">
          {showBulkSync && (
            <button
              onClick={handleBulkSync}
              disabled={isBulkSyncing}
              className="bg-arda-success/10 hover:bg-arda-success text-arda-success hover:text-white px-3 py-1.5 rounded-lg text-xs font-bold transition-all flex items-center gap-1.5 border border-arda-success/30 disabled:opacity-50"
            >
              {isBulkSyncing ? (
                <Icons.Loader2 className="w-3 h-3 animate-spin" />
              ) : (
                <Icons.Upload className="w-3 h-3" />
              )}
              Sync All to Arda
            </button>
          )}
          <span className="bg-arda-bg-tertiary text-arda-text-secondary px-3 py-1 rounded-lg text-sm flex items-center gap-2 border border-arda-border">
            <Icons.Package className="w-4 h-4"/> {items.length} Items
          </span>
        </div>
      </div>

      {/* Error Banner */}
      {bulkSyncError && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 flex items-start gap-3">
          <Icons.AlertCircle className="w-5 h-5 text-red-500 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <h4 className="font-semibold text-red-800 text-sm">Sync Failed</h4>
            <p className="text-red-700 text-sm mt-1">{bulkSyncError}</p>
          </div>
          <button
            onClick={() => setBulkSyncError(null)}
            title="Dismiss error"
            aria-label="Dismiss error"
            className="text-red-400 hover:text-red-600 p-1"
          >
            <Icons.X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* Table */}
      <div className="bg-white border border-arda-border rounded-xl shadow-arda overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="bg-arda-bg-secondary border-b border-arda-border">
              <tr className="text-arda-text-muted font-medium text-xs uppercase tracking-wide">
                <th className="px-3 py-3 text-left w-12">Color</th>
                <th className="px-3 py-3 text-left min-w-[180px]">Item Name</th>
                <th className="px-3 py-3 text-left min-w-[120px]">Supplier</th>
                <th className="px-3 py-3 text-left min-w-[120px]">Location</th>
                <th className="px-3 py-3 text-right w-20">Order Qty</th>
                <th className="px-3 py-3 text-right w-20">Min Qty</th>
                <th className="px-3 py-3 text-left w-32">Image URL</th>
                <th className="px-3 py-3 text-left w-32">Product URL</th>
                {showReviewColumn && (
                  <th className="px-3 py-3 text-left w-40">Review</th>
                )}
                <th className="px-3 py-3 text-center w-12">Status</th>
                <th className="px-3 py-3 text-right w-28">Actions</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-arda-border">
              {sortedItems.map((item) => (
                <tr 
                  key={item.id} 
                  className={`hover:bg-arda-bg-tertiary/50 transition-colors ${
                    item.isDraft ? 'bg-yellow-50/50 border-l-2 border-l-yellow-400' : ''
                  }`}
                >
                  {/* Color */}
                  <td className="px-3 py-2">
                    <ColorPicker
                      value={item.color}
                      onSelect={(color) => handleUpdate(item.id, { color })}
                    />
                  </td>

                  {/* Item Name */}
                  <td className="px-1 py-2">
                    <div title={item.originalName || item.name}>
                      <EditableCell
                        value={item.name}
                        onSave={(val) => handleUpdate(item.id, { name: String(val) })}
                        className="font-medium text-arda-text-primary"
                      />
                      {item.originalName && (
                        <span className="ml-1 text-[10px] text-arda-text-muted" title="Name simplified by AI">
                          ✨
                        </span>
                      )}
                      {item.isDraft && (
                        <span className="ml-2 text-[10px] bg-yellow-100 text-yellow-700 px-1.5 py-0.5 rounded font-medium">
                          DRAFT
                        </span>
                      )}
                    </div>
                  </td>

                  {/* Supplier */}
                  <td className="px-1 py-2">
                    <EditableCell
                      value={item.supplier}
                      onSave={(val) => handleUpdate(item.id, { supplier: String(val) })}
                      className="text-arda-text-secondary"
                    />
                  </td>

                  {/* Location */}
                  <td className="px-1 py-2">
                    <EditableCell
                      value={item.location}
                      onSave={(val) => handleUpdate(item.id, { location: String(val) })}
                      className="text-arda-text-secondary"
                      placeholder="Add location"
                    />
                  </td>

                  {/* Order Qty */}
                  <td className="px-1 py-2 text-right">
                    <EditableCell
                      value={item.recommendedOrderQty}
                      type="number"
                      onSave={(val) => handleUpdate(item.id, { recommendedOrderQty: Number(val) })}
                      className="text-arda-accent font-mono font-bold text-right"
                    />
                  </td>

                  {/* Min Qty */}
                  <td className="px-1 py-2 text-right">
                    <EditableCell
                      value={item.recommendedMin}
                      type="number"
                      onSave={(val) => handleUpdate(item.id, { recommendedMin: Number(val) })}
                      className="font-mono text-right"
                    />
                  </td>

                  {/* Image URL */}
                  <td className="px-1 py-2">
                    <div className="flex items-center gap-2">
                      {item.imageUrl && (
                        <img 
                          src={item.imageUrl} 
                          alt="" 
                          className="w-6 h-6 rounded object-cover border border-arda-border"
                          onError={(e) => (e.currentTarget.style.display = 'none')}
                        />
                      )}
                      <EditableCell
                        value={item.imageUrl}
                        type="url"
                        onSave={(val) => handleUpdate(item.id, { imageUrl: String(val) })}
                        placeholder="Add image"
                      />
                    </div>
                  </td>

                  {/* Product URL */}
                  <td className="px-1 py-2">
                    <EditableCell
                      value={item.productUrl}
                      type="url"
                      onSave={(val) => handleUpdate(item.id, { productUrl: String(val) })}
                      placeholder="Add URL"
                    />
                  </td>

                  {/* Review */}
                  {showReviewColumn && (
                    <td className="px-3 py-2">
                      <div className="flex items-center gap-2">
                        <span className={`text-[10px] px-2 py-0.5 rounded-full border ${reviewBadgeClasses[reviewStatusById?.[item.id] || 'pending']}`}>
                          {(reviewStatusById?.[item.id] || 'pending').toUpperCase()}
                        </span>
                        <div className="flex gap-1">
                          <button
                            type="button"
                            onClick={() => {
                              if (!onReviewStatusChange) return;
                              const current = reviewStatusById?.[item.id] || 'pending';
                              onReviewStatusChange(item.id, current === 'approved' ? 'pending' : 'approved');
                            }}
                            className="text-xs px-2 py-1 rounded border border-green-200 text-green-700 hover:bg-green-50 transition-colors"
                            title="Approve item"
                            aria-label="Approve item"
                          >
                            Approve
                          </button>
                          <button
                            type="button"
                            onClick={() => {
                              if (!onReviewStatusChange) return;
                              const current = reviewStatusById?.[item.id] || 'pending';
                              onReviewStatusChange(item.id, current === 'excluded' ? 'pending' : 'excluded');
                            }}
                            className="text-xs px-2 py-1 rounded border border-red-200 text-red-700 hover:bg-red-50 transition-colors"
                            title="Exclude item"
                            aria-label="Exclude item"
                          >
                            Exclude
                          </button>
                        </div>
                      </div>
                    </td>
                  )}

                  {/* Status */}
                  <td className="px-3 py-2 text-center">
                    {syncResults[item.id] === 'success' && (
                      <span className="text-arda-success" title="Synced">
                        <Icons.Check className="w-4 h-4 inline" />
                      </span>
                    )}
                    {syncResults[item.id] === 'error' && (
                      <span className="text-arda-danger" title="Sync failed">
                        <Icons.AlertCircle className="w-4 h-4 inline" />
                      </span>
                    )}
                    {syncingItems.has(item.id) && (
                      <Icons.Loader2 className="w-4 h-4 inline animate-spin text-arda-accent" />
                    )}
                  </td>

                  {/* Actions */}
                  <td className="px-3 py-2">
                    <div className="flex justify-end gap-1">
                      {showHistoryAction && (
                        <button
                          onClick={() => setHistoryItem(item)}
                          className="p-1.5 text-arda-text-muted hover:text-arda-accent transition-colors rounded hover:bg-arda-accent/10"
                          title="View history"
                        >
                          <Icons.Clock className="w-4 h-4" />
                        </button>
                      )}
                      {showAmazonLookupAction && onAmazonLookup && (
                        <button
                          onClick={() => onAmazonLookup(item)}
                          disabled={(!item.asin && !item.productUrl) || amazonLookupLoadingIds?.has(item.id)}
                          className="p-1.5 text-arda-text-muted hover:text-arda-accent transition-colors rounded hover:bg-arda-accent/10 disabled:opacity-50"
                          title="Lookup Amazon info"
                          aria-label="Lookup Amazon info"
                        >
                          {amazonLookupLoadingIds?.has(item.id) ? (
                            <Icons.Loader2 className="w-4 h-4 animate-spin text-arda-accent" />
                          ) : (
                            <Icons.Search className="w-4 h-4" />
                          )}
                        </button>
                      )}
                      <button
                        onClick={() => handleSyncToArda(item)}
                        disabled={syncingItems.has(item.id)}
                        className="p-1.5 text-arda-success hover:bg-arda-success/10 transition-colors rounded disabled:opacity-50"
                        title="Sync to Arda"
                      >
                        <Icons.Upload className="w-4 h-4" />
                      </button>
                      {showReorderAction && onReorder && (
                        <button
                          onClick={() => onReorder(item)}
                          className="p-1.5 text-arda-accent hover:bg-arda-accent/10 transition-colors rounded"
                          title="Reorder"
                        >
                          <Icons.Send className="w-4 h-4" />
                        </button>
                      )}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* History Modal */}
      {historyItem && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/30 backdrop-blur-sm animate-in fade-in duration-200">
          <div className="bg-white border border-arda-border rounded-xl w-full max-w-lg shadow-2xl overflow-hidden animate-in zoom-in-95 duration-200">
            <div className="p-4 border-b border-arda-border flex justify-between items-center bg-arda-bg-secondary">
              <div>
                <h3 className="text-lg font-bold text-arda-text-primary">{historyItem.name}</h3>
                <p className="text-xs text-arda-text-muted">Purchase History from {historyItem.supplier}</p>
              </div>
              <button 
                onClick={() => setHistoryItem(null)}
                title="Close history"
                aria-label="Close history"
                className="text-arda-text-muted hover:text-arda-text-primary transition-colors p-1"
              >
                <Icons.X className="w-6 h-6" />
              </button>
            </div>
            
            <div className="max-h-[60vh] overflow-y-auto p-4">
              <table className="w-full text-left text-sm">
                <thead>
                  <tr className="text-arda-text-muted border-b border-arda-border font-mono text-xs uppercase">
                    <th className="pb-3 font-medium">Order Date</th>
                    <th className="pb-3 font-medium text-right">Quantity</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-arda-border font-mono">
                  {historyItem.history.slice().reverse().map((record, idx) => (
                    <tr key={idx} className="group hover:bg-arda-bg-tertiary transition-colors">
                      <td className="py-3 text-arda-text-secondary">
                        {new Date(record.date).toLocaleDateString(undefined, {
                          year: 'numeric',
                          month: 'short',
                          day: 'numeric'
                        })}
                      </td>
                      <td className="py-3 text-right text-arda-text-primary font-medium">
                        {record.quantity} units
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            <div className="p-4 bg-arda-bg-secondary border-t border-arda-border flex justify-between items-center">
              <div className="text-xs text-arda-text-muted">
                Total Orders: <span className="text-arda-text-primary font-bold">{historyItem.orderCount}</span>
              </div>
              <div className="flex gap-2">
                <button
                  onClick={() => handleSyncToArda(historyItem)}
                  disabled={syncingItems.has(historyItem.id)}
                  className="bg-arda-success/10 hover:bg-arda-success text-arda-success hover:text-white px-3 py-2 rounded-lg text-xs font-bold transition-all flex items-center gap-2 border border-arda-success/20 disabled:opacity-50"
                >
                  <Icons.Upload className="w-3 h-3" />
                  Sync to Arda
                </button>
                {onReorder && (
                  <button
                    onClick={() => {
                      onReorder(historyItem);
                      setHistoryItem(null);
                    }}
                    className="bg-arda-accent text-white px-4 py-2 rounded-lg text-xs font-bold hover:bg-arda-accent-hover transition-all flex items-center gap-2"
                  >
                    <Icons.Send className="w-3 h-3" />
                    Reorder Item
                  </button>
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

```

### `src/views/JourneyView.tsx`

```tsx
import React, { useState, useMemo } from 'react';
import { ExtractedOrder, InventoryItem, LineItemNodeData, ItemVelocityProfile, RawEmail } from '../types';
import { Icons } from '../components/Icons';
import { buildVelocityProfiles } from '../utils/inventoryLogic';
import { exportVelocityToCSV, exportOrdersToCSV } from '../utils/exportUtils';
import { VelocityBadge } from '../components/VelocityBadge';

interface JourneyViewProps {
  orders: ExtractedOrder[];
  inventory: InventoryItem[];
  emails?: RawEmail[];
  onReorder?: (item: InventoryItem) => void;
}

type ViewMode = 'timeline' | 'suppliers' | 'items';

const isCodeLikeName = (name: string): boolean => {
  const trimmed = name.trim();
  return /^[A-Z0-9-]{8,}$/.test(trimmed) || /^amazon product/i.test(trimmed);
};

const parsePriceValue = (price?: string): number | undefined => {
  if (!price) return undefined;
  const parsed = parseFloat(price.replace(/[^0-9.]/g, ''));
  return Number.isFinite(parsed) ? parsed : undefined;
};

const getHumanItemName = (item: { name: string; amazonEnriched?: { itemName?: string }; asin?: string }): string => {
  const enrichedName = item.amazonEnriched?.itemName?.trim();
  if (enrichedName) return enrichedName;
  const raw = item.name?.trim() || '';
  if (!raw) return item.asin ? 'Amazon product' : 'Item';
  if (isCodeLikeName(raw)) return item.asin ? 'Amazon product' : 'Item';
  return raw;
};

export const JourneyView: React.FC<JourneyViewProps> = ({
  orders,
  inventory,
  onReorder,
}) => {
  const [viewMode, setViewMode] = useState<ViewMode>('timeline');
  const [searchQuery, setSearchQuery] = useState('');
  const [expandedSuppliers, setExpandedSuppliers] = useState<Set<string>>(new Set());
  const [expandedOrders, setExpandedOrders] = useState<Set<string>>(new Set());
  const [selectedItem, setSelectedItem] = useState<LineItemNodeData | null>(null);

  // Build velocity profiles
  const velocityProfiles = useMemo(() => buildVelocityProfiles(orders), [orders]);
  // Get selected item's profile
  const selectedProfile = selectedItem 
    ? velocityProfiles.get(selectedItem.normalizedName) 
    : undefined;

  // Find matching inventory item for reorder
  const matchingInventoryItem = selectedItem 
    ? inventory.find(i => i.name.toLowerCase().trim() === selectedItem.normalizedName)
    : undefined;

  // Selected item details (prefer Amazon enrichment)
  const selectedAmazon = selectedItem?.amazonEnriched;
  const selectedDisplayName = selectedItem ? getHumanItemName(selectedItem) : '';
  const selectedUnitPrice = selectedItem?.unitPrice ?? selectedAmazon?.unitPrice ?? parsePriceValue(selectedAmazon?.price);
  const selectedTotalPrice = selectedUnitPrice
    ? selectedUnitPrice * (selectedItem?.quantity || 1)
    : selectedItem?.totalPrice;
  const selectedImage = selectedAmazon?.imageUrl || selectedProfile?.imageUrl;
  const selectedAmazonUrl = selectedAmazon?.amazonUrl || selectedProfile?.amazonUrl;

  // Stats
  const stats = useMemo(() => {
    const suppliers = new Set<string>();
    let totalItems = 0;
    orders.forEach(o => {
      suppliers.add(o.supplier);
      totalItems += o.items.length;
    });
    return {
      orders: orders.length,
      suppliers: suppliers.size,
      items: totalItems,
      uniqueItems: velocityProfiles.size,
    };
  }, [orders, velocityProfiles]);

  // Group orders by supplier
  const ordersBySupplier = useMemo(() => {
    const map = new Map<string, ExtractedOrder[]>();
    orders.forEach(order => {
      const list = map.get(order.supplier) || [];
      list.push(order);
      map.set(order.supplier, list);
    });
    // Sort suppliers by order count
    return Array.from(map.entries())
      .sort((a, b) => b[1].length - a[1].length);
  }, [orders]);

  // Filter based on search
  const filteredOrders = useMemo(() => {
    if (!searchQuery.trim()) return orders;
    const q = searchQuery.toLowerCase();
    return orders.filter(o => 
      o.supplier.toLowerCase().includes(q) ||
      o.items.some(i => i.name.toLowerCase().includes(q))
    );
  }, [orders, searchQuery]);

  const filteredProfiles = useMemo(() => {
    if (!searchQuery.trim()) return Array.from(velocityProfiles.values());
    const q = searchQuery.toLowerCase();
    return Array.from(velocityProfiles.values()).filter(p =>
      p.displayName.toLowerCase().includes(q) ||
      p.supplier.toLowerCase().includes(q) ||
      p.sku?.toLowerCase().includes(q)
    );
  }, [velocityProfiles, searchQuery]);

  const toggleSupplier = (supplier: string) => {
    setExpandedSuppliers(prev => {
      const next = new Set(prev);
      if (next.has(supplier)) {
        next.delete(supplier);
      } else {
        next.add(supplier);
      }
      return next;
    });
  };

  const toggleOrder = (orderId: string) => {
    setExpandedOrders(prev => {
      const next = new Set(prev);
      if (next.has(orderId)) {
        next.delete(orderId);
      } else {
        next.add(orderId);
      }
      return next;
    });
  };

  const handleItemClick = (item: LineItemNodeData) => {
    setSelectedItem(item);
  };

  const handleExportOrders = () => exportOrdersToCSV(orders);
  const handleExportItems = () => exportVelocityToCSV(Array.from(velocityProfiles.values()));

  // Empty state
  if (orders.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-[calc(100vh-12rem)] text-center">
        <div className="w-16 h-16 rounded-2xl bg-arda-bg-tertiary flex items-center justify-center mb-4">
          <Icons.GitBranch className="w-8 h-8 text-arda-text-muted" />
        </div>
        <h2 className="text-xl font-semibold text-arda-text-primary mb-2">No Orders Yet</h2>
        <p className="text-arda-text-muted max-w-md">
          Run the ingestion engine to process your emails and see your complete order journey here.
        </p>
      </div>
    );
  }

  return (
    <div className="flex h-[calc(100vh-6rem)] gap-6">
      {/* Main Content */}
      <div className="flex-1 flex flex-col min-w-0">
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <div>
            <h1 className="text-2xl font-bold text-arda-text-primary">Order Journey</h1>
            <p className="text-arda-text-secondary text-sm mt-1">
              Trace the flow from suppliers to orders to items
            </p>
          </div>
          <div className="flex items-center gap-2">
            <button
              onClick={handleExportOrders}
              className="flex items-center gap-2 px-3 py-2 text-sm bg-white hover:bg-arda-bg-tertiary text-arda-text-secondary border border-arda-border rounded-lg transition-colors"
            >
              <Icons.Download className="w-4 h-4" />
              Orders
            </button>
            <button
              onClick={handleExportItems}
              className="flex items-center gap-2 px-3 py-2 text-sm bg-white hover:bg-arda-bg-tertiary text-arda-text-secondary border border-arda-border rounded-lg transition-colors"
            >
              <Icons.Download className="w-4 h-4" />
              Items
            </button>
          </div>
        </div>

        {/* Stats Row */}
        <div className="grid grid-cols-4 gap-4 mb-6">
          <div className="bg-white rounded-xl p-4 border border-arda-border">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-lg bg-arda-bg-tertiary flex items-center justify-center">
                <Icons.Building2 className="w-5 h-5 text-arda-accent" />
              </div>
              <div>
                <div className="text-2xl font-bold text-arda-text-primary">{stats.suppliers}</div>
                <div className="text-xs text-arda-text-muted">Suppliers</div>
              </div>
            </div>
          </div>
          <div className="bg-white rounded-xl p-4 border border-arda-border">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-lg bg-arda-bg-tertiary flex items-center justify-center">
                <Icons.Package className="w-5 h-5 text-arda-accent" />
              </div>
              <div>
                <div className="text-2xl font-bold text-arda-text-primary">{stats.orders}</div>
                <div className="text-xs text-arda-text-muted">Orders</div>
              </div>
            </div>
          </div>
          <div className="bg-white rounded-xl p-4 border border-arda-border">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-lg bg-arda-bg-tertiary flex items-center justify-center">
                <Icons.Box className="w-5 h-5 text-arda-accent" />
              </div>
              <div>
                <div className="text-2xl font-bold text-arda-text-primary">{stats.items}</div>
                <div className="text-xs text-arda-text-muted">Line Items</div>
              </div>
            </div>
          </div>
          <div className="bg-white rounded-xl p-4 border border-arda-border">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-lg bg-arda-bg-tertiary flex items-center justify-center">
                <Icons.Activity className="w-5 h-5 text-arda-accent" />
              </div>
              <div>
                <div className="text-2xl font-bold text-arda-text-primary">{stats.uniqueItems}</div>
                <div className="text-xs text-arda-text-muted">Unique Items</div>
              </div>
            </div>
          </div>
        </div>

        {/* View Controls */}
        <div className="flex items-center gap-4 mb-4">
          {/* View Mode Toggle */}
          <div className="flex bg-arda-bg-tertiary rounded-lg p-1 border border-arda-border">
            <button
              onClick={() => setViewMode('timeline')}
              className={`px-4 py-2 text-sm font-medium rounded-md transition-colors ${
                viewMode === 'timeline'
                  ? 'bg-arda-accent text-white'
                  : 'text-arda-text-secondary hover:text-arda-text-primary'
              }`}
            >
              By Date
            </button>
            <button
              onClick={() => setViewMode('suppliers')}
              className={`px-4 py-2 text-sm font-medium rounded-md transition-colors ${
                viewMode === 'suppliers'
                  ? 'bg-arda-accent text-white'
                  : 'text-arda-text-secondary hover:text-arda-text-primary'
              }`}
            >
              By Supplier
            </button>
            <button
              onClick={() => setViewMode('items')}
              className={`px-4 py-2 text-sm font-medium rounded-md transition-colors ${
                viewMode === 'items'
                  ? 'bg-arda-accent text-white'
                  : 'text-arda-text-secondary hover:text-arda-text-primary'
              }`}
            >
              By Item
            </button>
          </div>

          {/* Search */}
          <div className="flex-1 relative">
            <Icons.Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-arda-text-muted" />
            <input
              type="text"
              placeholder="Search orders, suppliers, items..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-full bg-white border border-arda-border rounded-lg pl-10 pr-10 py-2 text-sm text-arda-text-primary placeholder-arda-text-muted focus:outline-none focus:ring-2 focus:ring-arda-accent focus:border-transparent"
            />
            {searchQuery && (
              <button
                onClick={() => setSearchQuery('')}
                aria-label="Clear search"
                className="absolute right-3 top-1/2 -translate-y-1/2 text-arda-text-muted hover:text-arda-text-primary"
              >
                <Icons.X className="w-4 h-4" />
              </button>
            )}
          </div>
        </div>

        {/* Content Area */}
        <div className="flex-1 overflow-y-auto bg-white rounded-xl border border-arda-border p-4">
          {viewMode === 'timeline' && (
            <TimelineView 
              orders={filteredOrders}
              expandedOrders={expandedOrders}
              toggleOrder={toggleOrder}
              onItemClick={handleItemClick}
              velocityProfiles={velocityProfiles}
            />
          )}
          {viewMode === 'suppliers' && (
            <SupplierView
              ordersBySupplier={ordersBySupplier}
              expandedSuppliers={expandedSuppliers}
              expandedOrders={expandedOrders}
              toggleSupplier={toggleSupplier}
              toggleOrder={toggleOrder}
              onItemClick={handleItemClick}
              velocityProfiles={velocityProfiles}
              searchQuery={searchQuery}
            />
          )}
          {viewMode === 'items' && (
            <ItemsView
              profiles={filteredProfiles}
              onItemClick={handleItemClick}
              selectedItem={selectedItem}
            />
          )}
        </div>
      </div>

      {/* Detail Panel */}
      {selectedItem && selectedProfile && (
        <div className="w-96 flex-shrink-0 bg-white border border-arda-border rounded-xl overflow-hidden flex flex-col">
          {/* Header with Amazon Image */}
          <div className="p-5 border-b border-arda-border">
            <div className="flex items-start gap-4">
              {/* Product Image from Amazon or placeholder */}
              {selectedImage ? (
                <img 
                  src={selectedImage}
                  alt=""
                  className="w-20 h-20 rounded-lg object-contain bg-white flex-shrink-0"
                />
              ) : (
                <div className="w-16 h-16 rounded-lg bg-arda-bg-tertiary flex items-center justify-center flex-shrink-0">
                  <Icons.Package className="w-8 h-8 text-arda-accent" />
                </div>
              )}
              
              <div className="flex-1 min-w-0">
                <div className="flex items-start justify-between">
                  <h3 className="text-lg font-semibold text-arda-text-primary leading-tight">
                    {selectedDisplayName}
                  </h3>
                  <button
                    onClick={() => setSelectedItem(null)}
                    aria-label="Close item details"
                    className="p-1 text-arda-text-muted hover:text-arda-text-primary hover:bg-arda-bg-tertiary rounded-lg transition-colors"
                  >
                    <Icons.X className="w-4 h-4" />
                  </button>
                </div>
                <p className="text-sm text-arda-text-secondary mt-1">{selectedItem.supplier || selectedProfile.supplier}</p>
                <div className="flex flex-wrap gap-1 mt-2">
                  {(selectedItem.sku || selectedProfile.sku) && (
                    <span className="px-2 py-0.5 bg-arda-bg-tertiary text-arda-text-secondary text-xs rounded font-mono">
                      SKU: {selectedItem.sku || selectedProfile.sku}
                    </span>
                  )}
                  {(selectedItem.asin || selectedProfile.asin) && (
                    <span className="px-2 py-0.5 bg-orange-100 text-orange-700 text-xs rounded font-mono">
                      ASIN: {selectedItem.asin || selectedProfile.asin}
                    </span>
                  )}
                </div>
                {selectedAmazonUrl && (
                  <a 
                    href={selectedAmazonUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="inline-flex items-center gap-1 mt-2 text-xs text-arda-accent hover:underline"
                  >
                    View on Amazon <Icons.ExternalLink className="w-3 h-3" />
                  </a>
                )}
              </div>
            </div>
          </div>

          {/* Item Details */}
          <div className="p-5 border-b border-arda-border space-y-3">
            <h4 className="text-sm font-medium text-arda-text-primary">Item Details</h4>
            <div className="space-y-2 text-sm">
              <div className="flex items-center justify-between">
                <span className="text-arda-text-secondary">Order Date</span>
                <span className="text-arda-text-primary">{selectedItem.orderDate || selectedProfile.lastOrderDate}</span>
              </div>
              <div className="flex items-center justify-between">
                <span className="text-arda-text-secondary">Quantity</span>
                <span className="text-arda-text-primary">{selectedItem.quantity} {selectedItem.unit}</span>
              </div>
              {selectedUnitPrice !== undefined && (
                <div className="flex items-center justify-between">
                  <span className="text-arda-text-secondary">Unit Price</span>
                  <span className="text-arda-accent font-semibold">${selectedUnitPrice.toFixed(2)}</span>
                </div>
              )}
              {selectedTotalPrice !== undefined && (
                <div className="flex items-center justify-between">
                  <span className="text-arda-text-secondary">Total</span>
                  <span className="text-arda-accent font-semibold">${selectedTotalPrice.toFixed(2)}</span>
                </div>
              )}
              {selectedAmazon?.price && (
                <div className="flex items-center justify-between">
                  <span className="text-arda-text-secondary">Amazon Price</span>
                  <span className="text-arda-text-primary">{selectedAmazon.price}</span>
                </div>
              )}
              {selectedAmazon?.unitCount !== undefined && (
                <div className="flex items-center justify-between">
                  <span className="text-arda-text-secondary">Unit Count</span>
                  <span className="text-arda-text-primary">{selectedAmazon.unitCount}</span>
                </div>
              )}
              {selectedAmazon?.upc && (
                <div className="flex items-center justify-between">
                  <span className="text-arda-text-secondary">UPC</span>
                  <span className="text-arda-text-primary font-mono">{selectedAmazon.upc}</span>
                </div>
              )}
            </div>
          </div>

          {/* Stats */}
          <div className="grid grid-cols-2 gap-3 p-5 border-b border-arda-border">
            <StatCard 
              value={selectedProfile.dailyBurnRate.toFixed(1)} 
              label="Units/Day" 
              color="orange" 
            />
            <StatCard 
              value={Math.round(selectedProfile.averageCadenceDays).toString()} 
              label="Days Between Orders" 
              color="blue" 
            />
            <StatCard 
              value={selectedProfile.totalQuantityOrdered.toString()} 
              label="Total Ordered" 
              color="green" 
            />
            <StatCard 
              value={selectedProfile.orderCount.toString()} 
              label="Orders Placed" 
              color="purple" 
            />
          </div>

          {/* Recommendations */}
          <div className="p-5 border-b border-arda-border">
            <h4 className="text-sm font-medium text-arda-text-primary mb-3">Kanban Settings</h4>
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <span className="text-sm text-arda-text-secondary">Min Qty (Reorder Point)</span>
                <span className="text-sm font-semibold text-arda-text-primary bg-arda-bg-tertiary px-2 py-1 rounded">
                  {selectedProfile.recommendedMin}
                </span>
              </div>
              <div className="flex items-center justify-between">
                <span className="text-sm text-arda-text-secondary">Order Qty</span>
                <span className="text-sm font-semibold text-arda-text-primary bg-arda-bg-tertiary px-2 py-1 rounded">
                  {selectedProfile.recommendedOrderQty}
                </span>
              </div>
              {selectedProfile.nextPredictedOrder && (
                <div className="flex items-center justify-between">
                  <span className="text-sm text-arda-text-secondary">Next Predicted Order</span>
                  <span className="text-sm font-semibold text-arda-accent">
                    {new Date(selectedProfile.nextPredictedOrder).toLocaleDateString()}
                  </span>
                </div>
              )}
            </div>
          </div>

          {/* Order History */}
          <div className="flex-1 overflow-y-auto p-5">
          <h4 className="text-sm font-medium text-arda-text-primary mb-3">Order History</h4>
            <div className="space-y-2">
              {selectedProfile.orders
                .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
                .map((order, idx) => (
                  <div 
                    key={`${order.orderId}-${idx}`}
                  className="flex items-center justify-between p-3 bg-arda-bg-tertiary rounded-lg hover:bg-arda-bg-secondary transition-colors"
                  >
                    <div>
                    <div className="text-sm text-arda-text-primary font-medium">
                        {new Date(order.date).toLocaleDateString('en-US', {
                          month: 'short',
                          day: 'numeric',
                          year: 'numeric',
                        })}
                      </div>
                    </div>
                    <div className="text-right">
                    <div className="text-sm font-semibold text-arda-text-primary">
                        ×{order.quantity}
                      </div>
                      {order.unitPrice && (
                      <div className="text-xs text-arda-text-muted">
                          ${order.unitPrice.toFixed(2)} ea
                        </div>
                      )}
                    </div>
                  </div>
                ))}
            </div>
          </div>

          {/* Actions */}
        <div className="p-5 border-t border-arda-border space-y-2">
            {matchingInventoryItem && onReorder && (
              <button
                onClick={() => onReorder(matchingInventoryItem)}
                className="w-full bg-arda-accent hover:bg-arda-accent-hover text-white py-2.5 px-4 rounded-lg font-medium transition-colors flex items-center justify-center gap-2"
              >
                <Icons.Send className="w-4 h-4" />
                Create Reorder Email
              </button>
            )}
            <button
            className="w-full bg-white hover:bg-arda-bg-tertiary text-arda-text-primary py-2.5 px-4 rounded-lg font-medium transition-colors flex items-center justify-center gap-2 border border-arda-border"
            >
              <Icons.Upload className="w-4 h-4" />
              Push to Arda
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

// Stat Card Component
const StatCard: React.FC<{ value: string; label: string; color: string }> = ({ value, label, color }) => {
  const colorClasses: Record<string, string> = {
    orange: 'text-arda-accent',
    blue: 'text-arda-accent',
    green: 'text-arda-accent',
    purple: 'text-arda-accent',
  };
  
  return (
    <div className="bg-arda-bg-tertiary rounded-lg p-3 border border-arda-border">
      <div className={`text-2xl font-bold ${colorClasses[color]}`}>{value}</div>
      <div className="text-xs text-arda-text-muted mt-1">{label}</div>
    </div>
  );
};

// Timeline View Component
const TimelineView: React.FC<{
  orders: ExtractedOrder[];
  expandedOrders: Set<string>;
  toggleOrder: (id: string) => void;
  onItemClick: (item: LineItemNodeData) => void;
  velocityProfiles: Map<string, ItemVelocityProfile>;
}> = ({ orders, expandedOrders, toggleOrder, onItemClick, velocityProfiles }) => {
  // Sort by date descending
  const sortedOrders = useMemo(() => 
    [...orders].sort((a, b) => new Date(b.orderDate).getTime() - new Date(a.orderDate).getTime()),
    [orders]
  );

  return (
    <div className="space-y-3">
      {sortedOrders.map((order) => (
        <OrderCard
          key={order.id}
          order={order}
          isExpanded={expandedOrders.has(order.id)}
          onToggle={() => toggleOrder(order.id)}
          onItemClick={onItemClick}
          velocityProfiles={velocityProfiles}
        />
      ))}
    </div>
  );
};

// Supplier View Component
const SupplierView: React.FC<{
  ordersBySupplier: [string, ExtractedOrder[]][];
  expandedSuppliers: Set<string>;
  expandedOrders: Set<string>;
  toggleSupplier: (supplier: string) => void;
  toggleOrder: (id: string) => void;
  onItemClick: (item: LineItemNodeData) => void;
  velocityProfiles: Map<string, ItemVelocityProfile>;
  searchQuery: string;
}> = ({ ordersBySupplier, expandedSuppliers, expandedOrders, toggleSupplier, toggleOrder, onItemClick, velocityProfiles, searchQuery }) => {
  const filtered = useMemo(() => {
    if (!searchQuery.trim()) return ordersBySupplier;
    const q = searchQuery.toLowerCase();
    return ordersBySupplier.filter(([supplier, orders]) =>
      supplier.toLowerCase().includes(q) ||
      orders.some(o => o.items.some(i => i.name.toLowerCase().includes(q)))
    );
  }, [ordersBySupplier, searchQuery]);

  return (
    <div className="space-y-4">
      {filtered.map(([supplier, supplierOrders]) => (
        <div key={supplier} className="bg-white rounded-lg overflow-hidden border border-arda-border">
          {/* Supplier Header */}
          <button
            onClick={() => toggleSupplier(supplier)}
            className="w-full flex items-center gap-3 p-4 hover:bg-arda-bg-tertiary transition-colors"
          >
            <div className="w-10 h-10 rounded-lg bg-arda-bg-tertiary flex items-center justify-center flex-shrink-0">
              <Icons.Building2 className="w-5 h-5 text-arda-accent" />
            </div>
            <div className="flex-1 text-left">
              <div className="text-arda-text-primary font-medium">{supplier}</div>
              <div className="text-sm text-arda-text-secondary">{supplierOrders.length} orders</div>
            </div>
            <Icons.ChevronRight 
              className={`w-5 h-5 text-arda-text-muted transition-transform ${
                expandedSuppliers.has(supplier) ? 'rotate-90' : ''
              }`}
            />
          </button>

          {/* Supplier Orders */}
          {expandedSuppliers.has(supplier) && (
            <div className="px-4 pb-4 space-y-2">
              {supplierOrders
                .sort((a, b) => new Date(b.orderDate).getTime() - new Date(a.orderDate).getTime())
                .map((order) => (
                  <OrderCard
                    key={order.id}
                    order={order}
                    isExpanded={expandedOrders.has(order.id)}
                    onToggle={() => toggleOrder(order.id)}
                    onItemClick={onItemClick}
                    velocityProfiles={velocityProfiles}
                    compact
                  />
                ))}
            </div>
          )}
        </div>
      ))}
    </div>
  );
};

// Items View Component
const ItemsView: React.FC<{
  profiles: ItemVelocityProfile[];
  onItemClick: (item: LineItemNodeData) => void;
  selectedItem: LineItemNodeData | null;
}> = ({ profiles, onItemClick, selectedItem }) => {
  // Sort by daily burn rate
  const sorted = useMemo(() => 
    [...profiles].sort((a, b) => b.dailyBurnRate - a.dailyBurnRate),
    [profiles]
  );

  return (
    <div className="grid gap-3">
      {sorted.map((profile) => {
        const isSelected = selectedItem?.normalizedName === profile.normalizedName;
        
        return (
          <button
            key={profile.normalizedName}
            onClick={() => onItemClick({
              lineItemId: profile.normalizedName,
              orderId: '',
              emailId: '',
              name: profile.displayName,
              normalizedName: profile.normalizedName,
              quantity: profile.totalQuantityOrdered,
              unit: 'total',
              sku: profile.sku,
              asin: profile.asin,
              supplier: profile.supplier,
              amazonEnriched: profile.asin ? {
                asin: profile.asin,
                itemName: profile.displayName,
                imageUrl: profile.imageUrl,
                amazonUrl: profile.amazonUrl,
              } : undefined,
            })}
            className={`w-full text-left p-4 rounded-lg transition-all ${
              isSelected 
                ? 'bg-arda-accent/20 border-2 border-arda-accent' 
                : 'bg-white border border-arda-border hover:bg-arda-bg-tertiary'
            }`}
          >
            <div className="flex items-start justify-between gap-4">
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2">
                  <span className="text-arda-text-primary font-medium truncate">{profile.displayName}</span>
                  {profile.sku && (
                    <span className="text-xs text-arda-text-muted font-mono bg-arda-bg-tertiary px-1.5 py-0.5 rounded">
                      {profile.sku}
                    </span>
                  )}
                </div>
                <div className="text-sm text-arda-text-secondary mt-1">{profile.supplier}</div>
              </div>
              <VelocityBadge
                dailyBurnRate={profile.dailyBurnRate}
                averageCadenceDays={profile.averageCadenceDays}
                orderCount={profile.orderCount}
                compact
              />
            </div>
            
            {/* Order dates as small pills */}
            <div className="flex flex-wrap gap-1.5 mt-3">
              {profile.orders
                .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
                .slice(0, 5)
                .map((order, idx) => (
                  <span
                    key={idx}
                    className="text-xs bg-arda-bg-tertiary text-arda-text-secondary px-2 py-0.5 rounded"
                  >
                    {new Date(order.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                    <span className="text-arda-text-muted ml-1">×{order.quantity}</span>
                  </span>
                ))}
              {profile.orders.length > 5 && (
                <span className="text-xs text-arda-text-muted">
                  +{profile.orders.length - 5} more
                </span>
              )}
            </div>
          </button>
        );
      })}
    </div>
  );
};

// Order Card Component
const OrderCard: React.FC<{
  order: ExtractedOrder;
  isExpanded: boolean;
  onToggle: () => void;
  onItemClick: (item: LineItemNodeData) => void;
  velocityProfiles: Map<string, ItemVelocityProfile>;
  compact?: boolean;
}> = ({ order, isExpanded, onToggle, onItemClick, velocityProfiles, compact = false }) => {
  return (
    <div className={`bg-white rounded-lg overflow-hidden border border-arda-border ${
      compact ? '' : ''
    }`}>
      {/* Order Header */}
      <button
        onClick={onToggle}
        className="w-full flex items-center gap-3 p-4 hover:bg-arda-bg-tertiary transition-colors"
      >
        <div className={`rounded-lg flex items-center justify-center flex-shrink-0 ${
          compact ? 'w-8 h-8 bg-arda-bg-tertiary' : 'w-10 h-10 bg-arda-bg-tertiary'
        }`}>
          <Icons.Package className={`text-arda-accent ${compact ? 'w-4 h-4' : 'w-5 h-5'}`} />
        </div>
        
        <div className="flex-1 text-left min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-arda-text-primary font-medium">
              {compact ? '' : `${order.supplier} - `}
              {new Date(order.orderDate).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
              })}
            </span>
            {order.confidence && order.confidence < 0.8 && (
              <span className="text-xs bg-orange-100 text-orange-700 px-1.5 py-0.5 rounded">
                Low confidence
              </span>
            )}
          </div>
          <div className="text-sm text-arda-text-secondary">
            {order.items.length} item{order.items.length !== 1 ? 's' : ''}
            {order.totalAmount && ` • $${order.totalAmount.toFixed(2)}`}
          </div>
        </div>

        <Icons.ChevronRight 
          className={`w-5 h-5 text-arda-text-muted transition-transform ${isExpanded ? 'rotate-90' : ''}`}
        />
      </button>

      {/* Order Items */}
      {isExpanded && (
        <div className="border-t border-arda-border p-3 space-y-2">
          {order.items.map((item, idx) => {
            const normalizedName = item.normalizedName || item.name.toLowerCase().trim();
            const profile = velocityProfiles.get(normalizedName);
            const displayName = getHumanItemName(item);
            const unitPrice = item.unitPrice ?? item.amazonEnriched?.unitPrice ?? parsePriceValue(item.amazonEnriched?.price);
            const totalPrice = unitPrice ? unitPrice * item.quantity : undefined;
            
            const itemData: LineItemNodeData = {
              lineItemId: item.id || `${order.id}-${idx}`,
              orderId: order.id,
              emailId: order.originalEmailId,
              name: displayName,
              normalizedName,
              quantity: item.quantity,
              unit: item.unit,
              unitPrice: unitPrice,
              sku: item.sku || item.asin,
              asin: item.asin,
              supplier: order.supplier,
              orderDate: order.orderDate,
              totalPrice,
              amazonEnriched: item.amazonEnriched,
            };

            return (
              <div
                key={idx}
                className="w-full rounded-lg bg-arda-bg-tertiary border border-arda-border"
              >
                <button
                  onClick={() => onItemClick(itemData)}
                  className="w-full flex items-center gap-3 p-3 hover:bg-arda-bg-secondary transition-colors text-left rounded-lg"
                >
                {/* Amazon product image or fallback icon */}
                {item.amazonEnriched?.imageUrl ? (
                  <img 
                    src={item.amazonEnriched.imageUrl} 
                    alt=""
                    className="w-12 h-12 rounded-lg object-contain bg-white flex-shrink-0"
                  />
                ) : (
                  <div className="w-10 h-10 rounded-lg bg-arda-bg-tertiary flex items-center justify-center flex-shrink-0">
                    <Icons.Box className="w-5 h-5 text-arda-accent" />
                  </div>
                )}
                
                <div className="flex-1 min-w-0">
                  <div className="text-sm text-arda-text-primary truncate">
                    {displayName}
                  </div>
                  <div className="flex items-center flex-wrap gap-2 text-xs text-arda-text-muted">
                    <span>{item.quantity} {item.unit}</span>
                    {unitPrice && <span className="text-arda-accent font-medium">@ ${unitPrice.toFixed(2)}</span>}
                    {totalPrice && <span className="text-arda-accent">Total: ${totalPrice.toFixed(2)}</span>}
                    {item.asin && <span className="text-arda-accent">ASIN: {item.asin}</span>}
                  </div>
                </div>

                {profile && profile.orderCount > 1 && (
                  <VelocityBadge
                    dailyBurnRate={profile.dailyBurnRate}
                    averageCadenceDays={profile.averageCadenceDays}
                    orderCount={profile.orderCount}
                    compact
                  />
                )}
                </button>
                {item.amazonEnriched?.amazonUrl && (
                  <div className="px-3 pb-3 pl-16">
                    <a 
                      href={item.amazonEnriched.amazonUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-xs text-arda-accent hover:underline"
                    >
                      View on Amazon →
                    </a>
                  </div>
                )}
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
};

export default JourneyView;

```

### `src/views/LoginScreen.tsx`

```tsx
import { useState, type FormEvent } from 'react';
import { Icons } from '../components/Icons';
import { InstructionCard } from '../components/InstructionCard';
import { API_BASE_URL, authApi, isApiRequestError } from '../services/api';

interface LoginScreenProps {
  onCheckingAuth?: boolean;
  onLoginSuccess?: (user: { id: string; email: string; name: string; picture_url: string }) => void;
}

export const LoginScreen: React.FC<LoginScreenProps> = ({ onCheckingAuth, onLoginSuccess }) => {
  const handleGoogleLogin = () => {
    window.location.href = `${API_BASE_URL}/auth/google`;
  };

  const [isSignup, setIsSignup] = useState(false);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleLocalSubmit = async (event: FormEvent) => {
    event.preventDefault();
    if (!email || !password || (isSignup && !name)) {
      setError('Please fill out all required fields.');
      return;
    }

    setIsSubmitting(true);
    setError(null);

    try {
      const response = isSignup
        ? await authApi.signup(email, password, name)
        : await authApi.login(email, password);
      if (response.user && onLoginSuccess) {
        onLoginSuccess(response.user);
      }
    } catch (err) {
      if (isApiRequestError(err)) {
        setError(err.message || 'Unable to sign in.');
      } else {
        setError('Unable to sign in.');
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="relative min-h-screen arda-mesh flex items-center justify-center p-6">
      <div className="absolute inset-0 pointer-events-none overflow-hidden">
        <div className="absolute -top-10 left-6 w-48 h-48 rounded-full bg-orange-400/15 blur-3xl animate-float" />
        <div className="absolute bottom-0 right-12 w-64 h-64 rounded-full bg-blue-500/15 blur-3xl animate-float" />
      </div>

      <div className="relative z-10 w-full max-w-5xl grid lg:grid-cols-2 gap-8 items-center">
        {/* Left: brand story */}
        <div className="space-y-6">
          <div className="arda-pill w-fit">
            <Icons.Link className="w-4 h-4" />
            Arda Order Intelligence
          </div>
          <h1 className="text-4xl lg:text-5xl font-bold text-arda-text-primary leading-tight">
            The easiest way to never run out.
          </h1>
          <p className="text-arda-text-secondary text-lg max-w-xl">
            Connect your email and let Arda's AI automatically discover your suppliers,
            track order velocity, and surface replenishment signals before stockouts happen.
          </p>
          <div className="flex flex-wrap gap-3 text-sm text-arda-text-secondary">
            <div className="flex items-center gap-2 px-3 py-2 rounded-xl bg-white/80 border border-arda-border shadow-arda">
              <Icons.ShieldCheck className="w-4 h-4 text-arda-accent" />
              Secure &amp; private
            </div>
            <div className="flex items-center gap-2 px-3 py-2 rounded-xl bg-white/80 border border-arda-border shadow-arda">
              <Icons.Activity className="w-4 h-4 text-arda-accent" />
              Live velocity signals
            </div>
            <div className="flex items-center gap-2 px-3 py-2 rounded-xl bg-white/80 border border-arda-border shadow-arda">
              <Icons.Sparkles className="w-4 h-4 text-arda-accent" />
              AI-powered extraction
            </div>
          </div>
        </div>

        {/* Right: sign-in card */}
        <div className="arda-glass rounded-2xl p-8 lg:p-10">
          <div className="flex items-center justify-between mb-6">
            <div>
              <p className="text-sm uppercase tracking-wide text-arda-text-muted">Sign in</p>
              <h2 className="text-2xl font-bold text-arda-text-primary">Continue with Arda</h2>
            </div>
            <div className="w-12 h-12 rounded-2xl bg-gradient-to-br from-orange-500 to-orange-600 flex items-center justify-center shadow-arda-lg">
              <Icons.Inbox className="w-6 h-6 text-white" />
            </div>
          </div>

          <InstructionCard
            title="What to do"
            icon="Lock"
            steps={[
              'Sign in with Google to connect Gmail.',
              'Or create an Arda account.',
              'You will continue into onboarding after sign-in.',
            ]}
            className="mb-5"
          />

          <div className="space-y-4">
            {onCheckingAuth ? (
              <div className="flex flex-col items-center py-6">
                <div className="animate-spin w-10 h-10 border-2 border-orange-500 border-t-transparent rounded-full mb-4" />
                <span className="text-arda-text-muted">Checking authentication...</span>
              </div>
            ) : (
              <>
                <form onSubmit={handleLocalSubmit} className="space-y-3">
                  {isSignup && (
                    <input
                      type="text"
                      placeholder="Full name"
                      value={name}
                      onChange={(e) => setName(e.target.value)}
                      className="w-full px-4 py-3 rounded-xl border border-arda-border bg-white/90 text-arda-text-primary focus:outline-none focus:ring-2 focus:ring-orange-400"
                      required
                    />
                  )}
                  <input
                    type="email"
                    placeholder="Email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="w-full px-4 py-3 rounded-xl border border-arda-border bg-white/90 text-arda-text-primary focus:outline-none focus:ring-2 focus:ring-orange-400"
                    required
                  />
                  <input
                    type="password"
                    placeholder="Password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="w-full px-4 py-3 rounded-xl border border-arda-border bg-white/90 text-arda-text-primary focus:outline-none focus:ring-2 focus:ring-orange-400"
                    required
                  />
                  {error && (
                    <div className="text-sm text-red-600">{error}</div>
                  )}
                  <button
                    type="submit"
                    disabled={isSubmitting}
                    className="w-full flex items-center justify-center gap-3 bg-arda-accent hover:bg-arda-accent/90 text-white font-semibold py-3 px-4 rounded-xl transition-all shadow-arda-lg hover:shadow-arda-hover disabled:opacity-70"
                  >
                    {isSubmitting ? 'Working...' : isSignup ? 'Create account' : 'Sign in'}
                  </button>
                </form>

                <div className="flex items-center gap-2 text-xs text-arda-text-muted">
                  <div className="h-px flex-1 bg-arda-border" />
                  or
                  <div className="h-px flex-1 bg-arda-border" />
                </div>

                <button
                  onClick={handleGoogleLogin}
                  className="w-full flex items-center justify-center gap-3 bg-white hover:bg-gray-50 text-arda-text-primary font-semibold py-3 px-4 rounded-xl transition-all shadow-arda-lg hover:shadow-arda-hover border border-arda-border"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" aria-hidden="true">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                  </svg>
                  Continue with Google
                </button>

                <button
                  type="button"
                  onClick={() => {
                    setIsSignup((prev) => !prev);
                    setError(null);
                  }}
                  className="w-full text-sm text-arda-text-secondary hover:text-arda-text-primary"
                >
                  {isSignup ? 'Already have an account? Sign in' : 'New here? Create an account'}
                </button>
              </>
            )}

            <div className="rounded-xl bg-arda-bg-secondary border border-arda-border p-4 text-sm text-arda-text-secondary">
              <div className="flex items-center gap-2 mb-2">
                <Icons.Lock className="w-4 h-4 text-arda-accent" />
                Your data stays private
              </div>
              <p className="text-arda-text-muted">
                We only request Gmail scopes required for purchase-order detection.
                Your email content is never stored or shared.
              </p>
            </div>
          </div>

          <div className="mt-6 grid grid-cols-3 gap-4 text-center text-xs text-arda-text-muted">
            <div className="flex flex-col items-center gap-1">
              <Icons.Mail className="w-4 h-4 text-arda-accent" />
              Email ingestion
            </div>
            <div className="flex flex-col items-center gap-1">
              <Icons.TrendingUp className="w-4 h-4 text-arda-accent" />
              Velocity models
            </div>
            <div className="flex flex-col items-center gap-1">
              <Icons.Box className="w-4 h-4 text-arda-accent" />
              Kanban-ready items
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

```

### `src/views/MasterListStep.tsx`

```tsx
import { useMemo, useCallback, useEffect } from 'react';
import type { MasterListItem, RowSyncState, MasterListFooterState } from '../components/ItemsTable/types';

interface MasterListStepProps {
  items: MasterListItem[];
  syncStateById: Record<string, RowSyncState>;
  isBulkSyncing: boolean;
  onSyncSingle: (id: string) => Promise<boolean>;
  onSyncSelected: (ids: string[]) => Promise<void>;
  onUpdateItem: (id: string, field: keyof MasterListItem, value: unknown) => void;
  onRemoveItem: (id: string) => void;
  onComplete: () => void;
  onBack: () => void;
  onFooterStateChange?: (state: MasterListFooterState) => void;
}

export { type MasterListItem } from '../components/ItemsTable/types';
export { type MasterListFooterState } from '../components/ItemsTable/types';

export const MasterListStep: React.FC<MasterListStepProps> = ({
  items,
  syncStateById,
  isBulkSyncing,
  onSyncSelected,
  onComplete,
  onBack,
  onFooterStateChange,
}) => {
  void onBack;

  const syncedItems = useMemo(
    () => items.filter(item => syncStateById[item.id]?.status === 'success'),
    [items, syncStateById],
  );

  const hasSyncInProgress = useMemo(
    () => isBulkSyncing || Object.values(syncStateById).some(state => state.status === 'syncing'),
    [isBulkSyncing, syncStateById],
  );

  const handleComplete = useCallback(() => {
    onComplete();
  }, [onComplete]);

  const handleSyncSelected = useCallback(() => {
    const allIds = items.map(item => item.id);
    void onSyncSelected(allIds);
  }, [items, onSyncSelected]);

  useEffect(() => {
    onFooterStateChange?.({
      selectedCount: items.length,
      syncedCount: syncedItems.length,
      canSyncSelected: items.length > 0 && !hasSyncInProgress,
      canComplete: !hasSyncInProgress,
      isSyncing: isBulkSyncing,
      onSyncSelected: handleSyncSelected,
      onComplete: handleComplete,
    });
  }, [
    handleComplete,
    handleSyncSelected,
    hasSyncInProgress,
    isBulkSyncing,
    items.length,
    onFooterStateChange,
    syncedItems.length,
  ]);

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4 text-sm">
          <span className="font-medium">{items.length} items</span>
          <span className="text-green-600">{syncedItems.length} synced</span>
          {items.filter(i => syncStateById[i.id]?.status === 'error').length > 0 && (
            <span className="text-red-600">
              {items.filter(i => syncStateById[i.id]?.status === 'error').length} failed
            </span>
          )}
          {items.filter(i => i.needsAttention).length > 0 && (
            <span className="text-orange-600">
              {items.filter(i => i.needsAttention).length} need attention
            </span>
          )}
        </div>
      </div>
    </div>
  );
};

```

### `src/views/MobileScanner.tsx`

```tsx
import { useState, useEffect, useRef, useCallback } from 'react';
import { BrowserMultiFormatReader, BarcodeFormat, DecodeHintType } from '@zxing/library';
import { Icons } from '../components/Icons';
import { InstructionCard } from '../components/InstructionCard';
import { API_BASE_URL } from '../services/api';

interface MobileScannerProps {
  sessionId: string;
  mode: 'barcode' | 'photo';
}

interface ScannedItem {
  id: string;
  type: 'barcode' | 'photo';
  data: string;
  timestamp: string;
  synced: boolean;
}

export const MobileScanner: React.FC<MobileScannerProps> = ({
  sessionId,
  mode,
}) => {
  const [isScanning, setIsScanning] = useState(false);
  const [scannedItems, setScannedItems] = useState<ScannedItem[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [cameraFacing, setCameraFacing] = useState<'environment' | 'user'>('environment');
  const [flashEnabled, setFlashEnabled] = useState(false);
  
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const scanIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const idCounterRef = useRef(0);
  const readerRef = useRef<BrowserMultiFormatReader | null>(null);

  const nextId = useCallback((prefix: 'scan' | 'photo') => {
    idCounterRef.current += 1;
    return `${prefix}-${idCounterRef.current}`;
  }, []);

  // Sync item to desktop session
  const syncToDesktop = useCallback(async (item: ScannedItem) => {
    try {
      const endpoint = item.type === 'barcode' 
        ? `/api/scan/session/${sessionId}/barcode`
        : `/api/photo/session/${sessionId}/photo`;
      
      const response = await fetch(`${API_BASE_URL}${endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          id: item.id,
          data: item.data,
          timestamp: item.timestamp,
        }),
      });
      
      // Mark as synced if response is successful (2xx status)
      if (response.ok) {
        setScannedItems(prev => 
          prev.map(i => i.id === item.id ? { ...i, synced: true } : i)
        );
      } else {
        // Log non-ok responses but don't throw - item is still saved locally
        console.warn(`Sync response ${response.status}: ${response.statusText}`);
      }
    } catch (err) {
      // Network errors are logged but not surfaced to user
      // Item remains in local state and can be retried
      console.warn('Sync warning (will retry):', err);
    }
  }, [sessionId]);

  // Handle detected barcode - defined before scanForBarcode so it's in scope
  const handleBarcodeDetected = useCallback(async (barcode: string) => {
    // Avoid duplicates in quick succession
    const now = Date.now();
    const recentScans = scannedItems.filter(
      item => now - new Date(item.timestamp).getTime() < 3000
    );
    if (recentScans.some(item => item.data === barcode)) {
      return;
    }
    
    // Vibrate for feedback
    if (navigator.vibrate) {
      navigator.vibrate(100);
    }
    
    const item: ScannedItem = {
      id: nextId('scan'),
      type: 'barcode',
      data: barcode,
      timestamp: new Date().toISOString(),
      synced: false,
    };
    
    setScannedItems(prev => [item, ...prev]);
    
    // Sync to desktop
    await syncToDesktop(item);
  }, [scannedItems, nextId, syncToDesktop]);

  // Start continuous barcode scanning using ZXing
  const scanForBarcode = useCallback(async () => {
    if (!videoRef.current || !canvasRef.current) return;
    
    const video = videoRef.current;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    if (!ctx || video.videoWidth === 0 || video.readyState !== video.HAVE_ENOUGH_DATA) return;
    
    // Set canvas size to video size
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    // Draw current frame
    ctx.drawImage(video, 0, 0);
    
    // Initialize ZXing reader if needed
    if (!readerRef.current) {
      const hints = new Map();
      hints.set(DecodeHintType.POSSIBLE_FORMATS, [
        BarcodeFormat.EAN_13,
        BarcodeFormat.EAN_8,
        BarcodeFormat.UPC_A,
        BarcodeFormat.UPC_E,
        BarcodeFormat.CODE_128,
        BarcodeFormat.CODE_39,
        BarcodeFormat.ITF,
        BarcodeFormat.QR_CODE,
      ]);
      hints.set(DecodeHintType.TRY_HARDER, true);
      readerRef.current = new BrowserMultiFormatReader(hints);
    }
    
    try {
      // Convert canvas to image and decode
      const dataUrl = canvas.toDataURL('image/png');
      const result = await readerRef.current.decodeFromImage(undefined, dataUrl);
      if (result) {
        handleBarcodeDetected(result.getText());
      }
    } catch {
      // No barcode found in this frame - this is normal, just continue scanning
    }
  }, [handleBarcodeDetected]);

  const startBarcodeScanning = useCallback(() => {
    if (scanIntervalRef.current) {
      clearInterval(scanIntervalRef.current);
    }
    
    scanIntervalRef.current = setInterval(() => {
      void scanForBarcode();
    }, 200); // Scan every 200ms
  }, [scanForBarcode]);

  // Start camera
  const startCamera = useCallback(async () => {
    try {
      setError(null);
      
      // Check if we're in a secure context (HTTPS or localhost)
      if (!window.isSecureContext) {
        setError('Camera requires HTTPS. Please access this page via https://');
        return;
      }
      
      // Check if mediaDevices is available
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setError('Camera not supported in this browser. Try Chrome or Safari.');
        return;
      }
      
      // Stop existing stream
      if (streamRef.current) {
        streamRef.current.getTracks().forEach(track => track.stop());
      }
      
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: cameraFacing,
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
      });
      
      streamRef.current = stream;
      
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        await videoRef.current.play();
        setIsScanning(true);
        
        // Start continuous scanning for barcodes
        if (mode === 'barcode') {
          startBarcodeScanning();
        }
      }
    } catch (err) {
      console.error('Camera error:', err);
      const error = err as Error;
      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
        setError('Camera permission denied. Please allow camera access in your browser settings.');
      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
        setError('No camera found on this device.');
      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
        setError('Camera is in use by another app. Please close other apps using the camera.');
      } else if (error.name === 'OverconstrainedError') {
        setError('Camera does not support the requested settings. Try switching cameras.');
      } else {
        setError(`Camera error: ${error.message || 'Unknown error'}`);
      }
    }
  }, [cameraFacing, mode, startBarcodeScanning]);

  // Stop camera
  const stopCamera = useCallback(() => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }
    if (scanIntervalRef.current) {
      clearInterval(scanIntervalRef.current);
      scanIntervalRef.current = null;
    }
    if (readerRef.current) {
      readerRef.current.reset();
      readerRef.current = null;
    }
    setIsScanning(false);
  }, []);

  // Note: scanForBarcode and handleBarcodeDetected are defined above with useCallback

  // Capture photo
  const capturePhoto = async () => {
    if (!videoRef.current || !canvasRef.current) return;
    
    const video = videoRef.current;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) return;
    
    try {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0);
      
      const imageData = canvas.toDataURL('image/jpeg', 0.9);
      
      // Vibrate for feedback
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
      
      const item: ScannedItem = {
        id: nextId('photo'),
        type: 'photo',
        data: imageData,
        timestamp: new Date().toISOString(),
        synced: false,
      };
      
      setScannedItems(prev => [item, ...prev]);
      
      // Sync to desktop (errors are handled inside syncToDesktop)
      await syncToDesktop(item);
    } catch (err) {
      // Silently handle capture errors - photo still saved locally
      console.warn('Photo capture warning:', err);
    }
  };

  // Note: syncToDesktop is defined above with useCallback

  // Toggle camera facing
  const toggleCamera = () => {
    setCameraFacing(prev => prev === 'environment' ? 'user' : 'environment');
  };

  // Restart camera when facing changes
  useEffect(() => {
    if (!isScanning) return;
    const timeout = setTimeout(() => {
      void startCamera();
    }, 0);
    return () => clearTimeout(timeout);
  }, [cameraFacing, isScanning, startCamera]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      stopCamera();
    };
  }, [stopCamera]);

  const headerTitle = mode === 'barcode' ? 'Barcode Scanner' : 'Photo Capture';
  const instructionSteps = mode === 'barcode'
    ? [
      'Tap “Start camera.”',
      'Point at a barcode until it scans.',
      'Keep this page open until synced.',
    ]
    : [
      'Tap “Start camera.”',
      'Capture a clear label or packaging.',
      'Keep this page open until synced.',
    ];

  return (
    <div className="min-h-screen arda-mesh flex flex-col">
      <div className="px-4 pt-4 space-y-4">
        <div className="arda-glass rounded-2xl px-4 py-3 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-9 h-9 rounded-xl bg-gradient-to-br from-orange-500 to-orange-600 flex items-center justify-center shadow-arda">
              <Icons.Package className="w-5 h-5 text-white" />
            </div>
            <div>
              <h1 className="font-semibold leading-tight text-arda-text-primary">
                {headerTitle}
              </h1>
              <p className="text-xs text-arda-text-muted">
                Syncing to your desktop
              </p>
            </div>
          </div>
          <div className="flex items-center gap-3">
            <span className="text-arda-text-secondary text-sm">
              {scannedItems.length} scanned
            </span>
            <div className={`w-2 h-2 rounded-full ${
              scannedItems.some(i => !i.synced) ? 'bg-yellow-500 animate-pulse' : 'bg-green-500'
            }`} />
          </div>
        </div>

        <InstructionCard
          title="What to do"
          icon={mode === 'barcode' ? 'Barcode' : 'Camera'}
          steps={instructionSteps}
        />
      </div>

      {/* Camera view */}
      <div className="flex-1 px-4 py-4">
        <div className="relative h-full min-h-[360px] rounded-2xl overflow-hidden border border-arda-border shadow-arda bg-black">
          <video
            ref={videoRef}
            className="absolute inset-0 w-full h-full object-cover"
            playsInline
            muted
          />

          {/* Hidden canvas for processing */}
          <canvas ref={canvasRef} className="hidden" />

          {/* Scanning overlay for barcode mode */}
          {mode === 'barcode' && isScanning && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
              <div className="w-64 h-40 border-2 border-orange-400/60 rounded-xl relative">
                <div className="absolute top-0 left-0 w-6 h-6 border-l-4 border-t-4 border-orange-300 rounded-tl-xl" />
                <div className="absolute top-0 right-0 w-6 h-6 border-r-4 border-t-4 border-orange-300 rounded-tr-xl" />
                <div className="absolute bottom-0 left-0 w-6 h-6 border-l-4 border-b-4 border-orange-300 rounded-bl-xl" />
                <div className="absolute bottom-0 right-0 w-6 h-6 border-r-4 border-b-4 border-orange-300 rounded-br-xl" />

                {/* Scanning line animation */}
                <div className="absolute left-4 right-4 h-0.5 bg-arda-accent animate-scan" />
              </div>
              <p className="absolute bottom-6 text-white/80 text-sm">
                Position barcode within frame
              </p>
            </div>
          )}

          {/* Error state */}
          {error && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/70">
              <div className="text-center p-6">
                <Icons.AlertCircle className="w-12 h-12 text-red-500 mx-auto mb-3" />
                <p className="text-white mb-4">{error}</p>
                <button
                  onClick={startCamera}
                  className="btn-arda-primary px-6 py-2"
                >
                  Try Again
                </button>
              </div>
            </div>
          )}

          {/* Start camera prompt */}
          {!isScanning && !error && (
            <div className="absolute inset-0 flex items-center justify-center bg-black">
              <button
                onClick={startCamera}
                className="flex flex-col items-center gap-4 p-8"
              >
                <div className="w-20 h-20 bg-white/10 rounded-full flex items-center justify-center">
                  {mode === 'barcode' ? (
                    <Icons.Barcode className="w-10 h-10 text-white" />
                  ) : (
                    <Icons.Camera className="w-10 h-10 text-white" />
                  )}
                </div>
                <p className="text-white font-medium">
                  {mode === 'barcode' ? 'Tap to start scanning' : 'Tap to take photos'}
                </p>
              </button>
            </div>
          )}
        </div>
      </div>

      {scannedItems.length > 0 && (
        <div className="px-4 pb-2">
          <div className="card-arda p-3">
            <p className="text-xs text-arda-text-muted mb-2">Recent scans</p>
            <div className="flex gap-2 overflow-x-auto pb-1">
              {scannedItems.slice(0, 5).map((item) => (
                <div
                  key={item.id}
                  className={`
                    flex-shrink-0 px-3 py-2 rounded-lg flex items-center gap-2 border
                    ${item.synced ? 'bg-green-50 border-green-200' : 'bg-arda-bg-tertiary border-arda-border'}
                  `}
                >
                  {item.type === 'barcode' ? (
                    <>
                      <Icons.Barcode className="w-4 h-4 text-arda-text-secondary" />
                      <span className="text-arda-text-primary text-sm font-mono">{item.data}</span>
                    </>
                  ) : (
                    <img src={item.data} alt="" className="w-10 h-10 rounded object-cover" />
                  )}
                  {item.synced && (
                    <Icons.Check className="w-4 h-4 text-green-600" />
                  )}
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Controls */}
      <div className="px-4 pb-6 safe-area-inset-bottom">
        <div className="card-arda px-4 py-4 flex items-center justify-around">
          <button
            onClick={toggleCamera}
            aria-label="Switch camera"
            title="Switch camera"
            className="w-12 h-12 rounded-full border border-arda-border bg-white/80 flex items-center justify-center"
          >
            <Icons.RefreshCw className="w-5 h-5 text-arda-text-secondary" />
          </button>

          {mode === 'photo' && isScanning && (
            <button
              onClick={capturePhoto}
              aria-label="Capture photo"
              title="Capture photo"
              className="w-16 h-16 rounded-full bg-arda-text-primary flex items-center justify-center"
            >
              <div className="w-14 h-14 rounded-full border-4 border-white/30" />
            </button>
          )}

          {mode === 'barcode' && isScanning && (
            <div className="w-16 h-16 rounded-full bg-green-500/10 flex items-center justify-center">
              <Icons.Barcode className="w-8 h-8 text-green-600" />
            </div>
          )}

          <button
            onClick={() => setFlashEnabled(!flashEnabled)}
            aria-label={flashEnabled ? 'Disable flash' : 'Enable flash'}
            title={flashEnabled ? 'Disable flash' : 'Enable flash'}
            className={`w-12 h-12 rounded-full flex items-center justify-center border ${
              flashEnabled ? 'bg-yellow-400 border-yellow-300' : 'bg-white/80 border-arda-border'
            }`}
          >
            <Icons.Zap className={`w-5 h-5 ${flashEnabled ? 'text-black' : 'text-arda-text-secondary'}`} />
          </button>
        </div>
      </div>

      <style>{`
        @keyframes scan {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(140px); }
        }
        .animate-scan {
          animation: scan 2s ease-in-out infinite;
        }
        .safe-area-inset-bottom {
          padding-bottom: max(1.5rem, env(safe-area-inset-bottom));
        }
      `}</style>
    </div>
  );
};

```

### `src/views/OnboardingFlow.tsx`

```tsx
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Icons } from '../components/Icons';
import { ExtractedOrder } from '../types';
import { buildVelocityProfiles, normalizeItemName } from '../utils/inventoryLogic';
import { SupplierSetup, EmailScanState } from './SupplierSetup';
import { UrlScrapeStep } from './UrlScrapeStep';
import { BarcodeScanStep } from './BarcodeScanStep';
import { PhotoCaptureStep } from './PhotoCaptureStep';
import { CSVUploadStep, CSVItem, CSVFooterState } from './CSVUploadStep';
import { MasterListStep } from './MasterListStep';
import { ItemsGrid } from '../components/ItemsTable';
import type { MasterListItem, MasterListFooterState } from '../components/ItemsTable/types';
import { buildMasterListItems } from '../utils/masterListItems';
import { useSyncToArda } from '../hooks/useSyncToArda';
import { IntegrationsStep } from './IntegrationsStep';
import { UrlScrapedItem } from '../services/api';
import { OnboardingWelcomeStep } from './OnboardingWelcomeStep';

// Simple email item for onboarding (before full InventoryItem processing)
interface EmailItem {
  id: string;
  name: string;
  supplier: string;
  asin?: string;
  imageUrl?: string;
  productUrl?: string;
  lastPrice?: number;
  quantity?: number;
  location?: string;
  recommendedMin?: number;
  recommendedOrderQty?: number;
}

// Onboarding step definitions
export type OnboardingStep = 'welcome' | 'email' | 'integrations' | 'url' | 'barcode' | 'photo' | 'csv' | 'masterlist';

interface StepConfig {
  id: OnboardingStep;
  number: number;
  title: string;
  description: string;
  tipsTitle: string;
  tips: string[];
  icon: keyof typeof Icons;
}

const ONBOARDING_STEPS: StepConfig[] = [
  {
    id: 'welcome',
    number: 1,
    title: 'Welcome',
    description: 'Overview the onboarding path and start your sync',
    tipsTitle: 'What you will do',
    tips: [
      'Start email sync to import orders automatically.',
      'Add items via URLs, barcodes, photos, or CSV.',
      'Review and sync items to Arda.',
    ],
    icon: 'Sparkles',
  },
  {
    id: 'email',
    number: 2,
    title: 'Email',
    description: 'Import orders from your inbox',
    tipsTitle: 'What to do',
    tips: [
      'Connect Gmail to start scanning.',
      'Wait for Amazon + priority suppliers to finish.',
      'Select any extra suppliers to import.',
    ],
    icon: 'Mail',
  },
  {
    id: 'integrations',
    number: 3,
    title: 'Integrations',
    description: 'Connect your systems and data sources',
    tipsTitle: 'What to do',
    tips: [
      'Connect QuickBooks or Xero if you want PO data.',
      'Start a sync to pull history.',
      'Continue when ready.',
    ],
    icon: 'Building2',
  },
  {
    id: 'url',
    number: 4,
    title: 'URLs',
    description: 'Import products from links',
    tipsTitle: 'What to do',
    tips: [
      'Paste up to 50 product links.',
      'Click “Scrape URLs.”',
      'Review, edit, approve, or delete rows.',
      'Import approved rows to the master list.',
    ],
    icon: 'Link',
  },
  {
    id: 'barcode',
    number: 5,
    title: 'UPCs',
    description: 'Scan UPC/EAN codes in your shop',
    tipsTitle: 'What to do',
    tips: [
      'Scan with a USB/Bluetooth scanner or phone camera.',
      'Edit any detected fields as needed.',
      'Confirm items appear below.',
    ],
    icon: 'Barcode',
  },
  {
    id: 'photo',
    number: 6,
    title: 'Images',
    description: 'Photograph items with labels',
    tipsTitle: 'What to do',
    tips: [
      'Upload photos or use the phone camera.',
      'Wait for AI extraction, then edit any field as needed.',
      'Confirm details before continuing.',
    ],
    icon: 'Camera',
  },
  {
    id: 'csv',
    number: 7,
    title: 'CSV',
    description: 'Import from spreadsheet',
    tipsTitle: 'What to do',
    tips: [
      'Upload a CSV.',
      'Map columns to fields.',
      'Approve items to import.',
    ],
    icon: 'FileSpreadsheet',
  },
  {
    id: 'masterlist',
    number: 8,
    title: 'Review',
    description: 'Review and sync items',
    tipsTitle: 'What to do',
    tips: [
      'Review and edit item details in the grid below.',
      'Select items and sync to Arda.',
      'Complete setup when ready.',
    ],
    icon: 'ListChecks',
  },
];

const buildEmailItemsFromOrders = (orders: ExtractedOrder[]): EmailItem[] => {
  if (orders.length === 0) return [];

  const velocityProfiles = buildVelocityProfiles(orders);
  const uniqueItems = new Map<string, EmailItem>();

  orders.forEach(order => {
    order.items.forEach(item => {
      const normalizedKey = item.normalizedName ?? normalizeItemName(item.name);
      const profile = velocityProfiles.get(normalizedKey);

      const displayName = profile?.displayName
        ?? item.amazonEnriched?.humanizedName
        ?? item.amazonEnriched?.itemName
        ?? item.name;

      // Two-bin system: min qty = order qty (refill one bin when empty)
      // Use velocity profile if available, otherwise default to 1.5x last order quantity
      const minQty = profile?.recommendedMin || Math.ceil((item.quantity || 1) * 1.5);

      const emailItem: EmailItem = {
        id: `email-${order.id}-${item.name}`,
        name: displayName,
        supplier: order.supplier,
        asin: item.asin,
        imageUrl: item.amazonEnriched?.imageUrl,
        productUrl: item.amazonEnriched?.amazonUrl,
        lastPrice: item.unitPrice,
        quantity: item.quantity,
        recommendedMin: minQty,
        recommendedOrderQty: minQty, // Two-bin: order qty = min qty
      };

      const existing = uniqueItems.get(normalizedKey);
      if (!existing || (emailItem.imageUrl && !existing.imageUrl)) {
        uniqueItems.set(normalizedKey, emailItem);
      }
    });
  });

  return Array.from(uniqueItems.values());
};

// Scanned barcode item
export interface ScannedBarcode {
  id: string;
  barcode: string;
  barcodeType: 'UPC' | 'EAN' | 'UPC-A' | 'EAN-13' | 'EAN-8' | 'GTIN-14' | 'unknown';
  scannedAt: string;
  source: 'desktop' | 'mobile';
  // Enriched data from lookup
  productName?: string;
  brand?: string;
  imageUrl?: string;
  category?: string;
  // Match status
  matchedToEmailItem?: string;
}

// Captured item photo
export interface CapturedPhoto {
  id: string;
  imageData: string;
  capturedAt: string;
  source: 'desktop' | 'mobile';
  // Extracted data from image analysis
  extractedText?: string[];
  detectedBarcodes?: string[];
  suggestedName?: string;
  suggestedSupplier?: string;
  isInternalItem?: boolean;
}

// Unified item for reconciliation (kept for backwards compatibility)
export interface ReconciliationItem {
  id: string;
  source: 'email' | 'url' | 'barcode' | 'photo' | 'csv';
  name: string;
  normalizedName?: string;
  supplier?: string;
  location?: string;
  barcode?: string;
  sku?: string;
  asin?: string;
  quantity?: number;
  minQty?: number;
  orderQty?: number;
  unitPrice?: number;
  imageUrl?: string;
  productUrl?: string;
  duplicateOf?: string;
  isDuplicate?: boolean;
  matchConfidence?: number;
  isApproved?: boolean;
  isExcluded?: boolean;
  needsReview?: boolean;
}

interface OnboardingFlowProps {
  onComplete: (items: MasterListItem[]) => void;
  onSkip: () => void;
  userProfile?: { name?: string; email?: string };
}

const noop = () => {};

export const OnboardingFlow: React.FC<OnboardingFlowProps> = ({
  onComplete,
  onSkip,
  userProfile,
}) => {
  const hasIntegrationCallback = (() => {
    const params = new URLSearchParams(window.location.search);
    return Boolean(params.get('integration_provider') && params.get('integration_status'));
  })();

  const [currentStep, setCurrentStep] = useState<OnboardingStep>(() => {
    return hasIntegrationCallback ? 'integrations' : 'welcome';
  });
  const [completedSteps, setCompletedSteps] = useState<Set<OnboardingStep>>(() => (
    hasIntegrationCallback ? new Set<OnboardingStep>(['welcome', 'email']) : new Set()
  ));
  const [hasStartedEmailSync, setHasStartedEmailSync] = useState(false);
  const [tipsOpenForStep, setTipsOpenForStep] = useState<OnboardingStep | null>(null);
  const tipsWrapperRef = useRef<HTMLDivElement | null>(null);
  
  // Data from each step
  const [emailOrders, setEmailOrders] = useState<ExtractedOrder[]>([]);
  const emailItems = useMemo(() => buildEmailItemsFromOrders(emailOrders), [emailOrders]);
  const [urlItems, setUrlItems] = useState<UrlScrapedItem[]>([]);
  const [scannedBarcodes, setScannedBarcodes] = useState<ScannedBarcode[]>([]);
  const [capturedPhotos, setCapturedPhotos] = useState<CapturedPhoto[]>([]);
  const [csvItems, setCsvItems] = useState<CSVItem[]>([]);
  const [csvFooterState, setCsvFooterState] = useState<CSVFooterState>({
    approvedCount: 0,
    canContinue: false,
    onSkip: noop,
    onContinue: noop,
  });
  const [masterListFooterState, setMasterListFooterState] = useState<MasterListFooterState>({
    selectedCount: 0,
    syncedCount: 0,
    canSyncSelected: false,
    canComplete: false,
    isSyncing: false,
    onSyncSelected: noop,
    onComplete: noop,
  });
  
  // Track when user can proceed from email step (Amazon + priority done)
  const [canProceedFromEmail, setCanProceedFromEmail] = useState(false);
  const [canProceedFromUrl, setCanProceedFromUrl] = useState(true);
  const [urlReviewBlockMessage, setUrlReviewBlockMessage] = useState<string | null>(null);
  
  // Preserve email scan state for navigation
  const [emailScanState, setEmailScanState] = useState<EmailScanState | undefined>(undefined);
  
  // Mobile session ID for syncing
  const [mobileSessionId] = useState(() => 
    `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  );

  const [masterItemEditsById, setMasterItemEditsById] = useState<Record<string, Partial<MasterListItem>>>({});
  const [removedMasterItemIds, setRemovedMasterItemIds] = useState<Record<string, true>>({});

  const baseMasterItems = useMemo(
    () => buildMasterListItems(emailItems, urlItems, scannedBarcodes, capturedPhotos, csvItems),
    [emailItems, urlItems, scannedBarcodes, capturedPhotos, csvItems],
  );

  const masterItems = useMemo(
    () => baseMasterItems
      .filter(item => !removedMasterItemIds[item.id])
      .map(item => {
        const override = masterItemEditsById[item.id];
        if (!override) return item;
        return { ...item, ...override };
      }),
    [baseMasterItems, masterItemEditsById, removedMasterItemIds],
  );

  const { syncStateById, setSyncStateById, syncSingleItem, syncSelectedItems, isBulkSyncing } = useSyncToArda(masterItems);

  const isPanelVisible = masterItems.length > 0;

  const updateItem = useCallback((id: string, field: keyof MasterListItem, value: unknown) => {
    setMasterItemEditsById(prev => {
      const existing = prev[id] ?? {};
      const nextOverride = { ...existing, [field]: value } as Partial<MasterListItem>;
      if (field === 'name' && value && !String(value).includes('Unknown')) {
        nextOverride.needsAttention = false;
      }
      return { ...prev, [id]: nextOverride };
    });
    setSyncStateById(prev => {
      const existing = prev[id];
      if (!existing || existing.status === 'idle') return prev;
      return { ...prev, [id]: { status: 'idle' } };
    });
  }, [setSyncStateById]);

  const removeItem = useCallback((id: string) => {
    setRemovedMasterItemIds(prev => (prev[id] ? prev : { ...prev, [id]: true }));
    setMasterItemEditsById(prev => {
      if (!prev[id]) return prev;
      const next = { ...prev };
      delete next[id];
      return next;
    });
    setSyncStateById(prev => {
      if (!prev[id]) return prev;
      const next = { ...prev };
      delete next[id];
      return next;
    });
  }, [setSyncStateById]);

  const { currentStepIndex, currentStepConfig } = useMemo(() => {
    const index = ONBOARDING_STEPS.findIndex(step => step.id === currentStep);
    const safeIndex = index === -1 ? 0 : index;
    return {
      currentStepIndex: safeIndex,
      currentStepConfig: ONBOARDING_STEPS[safeIndex],
    };
  }, [currentStep]);
  const tipsOpen = tipsOpenForStep === currentStep;

  useEffect(() => {
    if (!tipsOpen) return;

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') setTipsOpenForStep(null);
    };

    const handlePointerDown = (event: PointerEvent) => {
      const target = event.target as Node | null;
      if (!target) return;
      if (!tipsWrapperRef.current?.contains(target)) {
        setTipsOpenForStep(null);
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('pointerdown', handlePointerDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('pointerdown', handlePointerDown);
    };
  }, [tipsOpen]);
  
  // Check if can go back
  const canGoBack = currentStepIndex > 0;
  
  const canGoForward = currentStep === 'email'
    ? canProceedFromEmail
    : currentStep === 'url'
      ? canProceedFromUrl
      : true;

  // Handle step completion
  const handleStepComplete = useCallback((step: OnboardingStep) => {
    setCompletedSteps(prev => new Set([...prev, step]));
    
    // Auto-advance to next step
    const currentIndex = ONBOARDING_STEPS.findIndex(s => s.id === step);
    if (currentIndex < ONBOARDING_STEPS.length - 1) {
      setTipsOpenForStep(null);
      setCurrentStep(ONBOARDING_STEPS[currentIndex + 1].id);
    }
  }, []);

  // Handle email orders update (does NOT auto-advance - user clicks Continue)
  const handleEmailOrdersUpdate = useCallback((orders: ExtractedOrder[]) => {
    setEmailOrders(orders);
    // Don't auto-advance - user will click Continue when ready
  }, []);

  // Handle barcode scan
  const handleBarcodeScanned = useCallback((barcode: ScannedBarcode) => {
    setScannedBarcodes(prev => {
      const byIdIndex = prev.findIndex(item => item.id === barcode.id);
      if (byIdIndex >= 0) {
        const existing = prev[byIdIndex];
        const merged = { ...existing, ...barcode, id: existing.id };
        const hasChanged = JSON.stringify(existing) !== JSON.stringify(merged);
        if (!hasChanged) return prev;
        const next = [...prev];
        next[byIdIndex] = merged;
        return next;
      }

      const byBarcodeIndex = prev.findIndex(item => item.barcode === barcode.barcode);
      if (byBarcodeIndex >= 0) {
        const existing = prev[byBarcodeIndex];
        const merged = { ...existing, ...barcode, id: barcode.id };
        const hasChanged = JSON.stringify(existing) !== JSON.stringify(merged);
        if (!hasChanged) return prev;
        const next = [...prev];
        next[byBarcodeIndex] = merged;
        return next;
      }

      return [...prev, barcode];
    });
  }, []);

  // Handle photo capture
  const handlePhotoCaptured = useCallback((photo: CapturedPhoto) => {
    setCapturedPhotos(prev => {
      // Update existing photo or add new
      const existingIndex = prev.findIndex(p => p.id === photo.id);
      if (existingIndex >= 0) {
        const updated = [...prev];
        updated[existingIndex] = photo;
        return updated;
      }
      return [...prev, photo];
    });
  }, []);

  // Handle CSV upload completion
  const handleCSVComplete = useCallback((approvedItems: CSVItem[]) => {
    setCsvItems(approvedItems);
    handleStepComplete('csv');
  }, [handleStepComplete]);

  // Handle master list completion
  const handleMasterListComplete = useCallback(() => {
    handleStepComplete('masterlist');
    const syncedItems = masterItems.filter(item => syncStateById[item.id]?.status === 'success');
    onComplete(syncedItems);
  }, [handleStepComplete, masterItems, onComplete, syncStateById]);

  // Handle when user can proceed from email step (key suppliers done)
  const handleCanProceedFromEmail = useCallback((canProceed: boolean) => {
    setCanProceedFromEmail(canProceed);
  }, []);

  const handleUrlReviewStateChange = useCallback((state: {
    pendingReviewCount: number;
    unimportedApprovedCount: number;
    totalRows: number;
    canContinue: boolean;
  }) => {
    setCanProceedFromUrl(state.canContinue);
    if (state.canContinue || state.totalRows === 0) {
      setUrlReviewBlockMessage(null);
      return;
    }
    if (state.pendingReviewCount > 0) {
      setUrlReviewBlockMessage(
        `Review every scraped row before continuing (${state.pendingReviewCount} still pending).`,
      );
      return;
    }
    if (state.unimportedApprovedCount > 0) {
      setUrlReviewBlockMessage(
        `Import approved rows before continuing (${state.unimportedApprovedCount} still not imported).`,
      );
      return;
    }
    setUrlReviewBlockMessage('Review and import URL rows before continuing.');
  }, []);

  // Preserve email scan state for navigation
  const handleEmailScanStateChange = useCallback((state: EmailScanState) => {
    setEmailScanState(state);
  }, []);

  const handleStartEmailSync = useCallback(() => {
    setHasStartedEmailSync(true);
    handleStepComplete('welcome');
  }, [handleStepComplete]);

  const handleSkipEmailSync = useCallback(() => {
    setHasStartedEmailSync(false);
    setCompletedSteps(prev => {
      const next = new Set(prev);
      next.add('welcome');
      next.add('email');
      return next;
    });
    setTipsOpenForStep(null);
    setCurrentStep('integrations');
  }, []);

  // Go to previous step
  const goBack = useCallback(() => {
    if (currentStepIndex > 0) {
      setTipsOpenForStep(null);
      setCurrentStep(ONBOARDING_STEPS[currentStepIndex - 1].id);
    }
  }, [currentStepIndex]);

  // Go to next step
  const goForward = useCallback(() => {
    if (currentStepIndex < ONBOARDING_STEPS.length - 1) {
      handleStepComplete(currentStep);
    }
  }, [currentStepIndex, currentStep, handleStepComplete]);

  // Get step status
  const getStepStatus = (stepId: OnboardingStep): 'completed' | 'current' | 'upcoming' => {
    if (completedSteps.has(stepId)) return 'completed';
    if (currentStep === stepId) return 'current';
    return 'upcoming';
  };

  const renderFooterNavigation = () => {
    const handleSkip = () => {
      if (currentStep === 'welcome') {
        handleSkipEmailSync();
        return;
      }

      if (currentStep === 'csv') {
        const skip = csvFooterState.onSkip === noop
          ? () => handleCSVComplete([])
          : csvFooterState.onSkip;
        skip();
        return;
      }

      if (currentStep === 'masterlist') {
        setTipsOpenForStep(null);
        onSkip();
        return;
      }

      handleStepComplete(currentStep);
    };

    const handleContinue = () => {
      if (currentStep === 'welcome') {
        handleStartEmailSync();
        return;
      }

      if (currentStep === 'csv') {
        csvFooterState.onContinue();
        return;
      }

      if (currentStep === 'masterlist') {
        masterListFooterState.onComplete();
        return;
      }

      goForward();
    };

    const continueDisabled = currentStep === 'welcome'
      ? false
      : currentStep === 'csv'
        ? !csvFooterState.canContinue
        : currentStep === 'masterlist'
          ? !masterListFooterState.canComplete
          : !canGoForward;

    return (
      <div
        className="fixed bottom-0 inset-x-0 z-40 border-t border-arda-border/70 bg-white/75 backdrop-blur"
        role="navigation"
        aria-label="Onboarding navigation"
      >
        <div className="max-w-6xl mx-auto px-4 sm:px-6 h-14 flex items-center justify-between gap-3">
          <button
            type="button"
            onClick={goBack}
            disabled={!canGoBack}
            className="btn-arda-outline flex items-center gap-2 disabled:opacity-50"
          >
            <Icons.ChevronLeft className="w-4 h-4" />
            Back
          </button>

          <div className="flex items-center gap-2">
            <button
              type="button"
              onClick={handleSkip}
              className="btn-arda-outline"
            >
              Skip
            </button>

            {currentStep === 'masterlist' && (
              <button
                type="button"
                onClick={masterListFooterState.onSyncSelected}
                disabled={!masterListFooterState.canSyncSelected}
                className="btn-arda-outline text-sm py-1.5 flex items-center gap-2 disabled:opacity-50"
              >
                {masterListFooterState.isSyncing ? (
                  <Icons.Loader2 className="w-4 h-4 animate-spin" />
                ) : (
                  <Icons.Upload className="w-4 h-4" />
                )}
                Sync Selected ({masterListFooterState.selectedCount})
              </button>
            )}

            <button
              type="button"
              onClick={handleContinue}
              disabled={continueDisabled}
              title={currentStep === 'email'
                ? 'Continuing won’t stop email scanning. Import keeps running in the background.'
                : undefined}
              className={[
                'flex items-center gap-2 px-4 py-2 rounded-arda font-semibold text-sm transition-colors',
                !continueDisabled
                  ? 'bg-arda-accent text-white hover:bg-arda-accent-hover'
                  : 'bg-arda-border text-arda-text-muted cursor-not-allowed',
              ].join(' ')}
            >
              Continue
              <Icons.ChevronRight className="w-4 h-4" />
            </button>

            {currentStep === 'email' && (
              <span className="sr-only">
                Continuing won’t stop email scanning. Import keeps running in the background.
              </span>
            )}
          </div>
        </div>
      </div>
    );
  };

  const renderStepIndicator = () => (
    <div className="sticky top-0 z-40 border-b border-arda-border/70 bg-white/75 backdrop-blur relative">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 h-14 flex items-center justify-between gap-3">
        <div className="flex items-center gap-3 min-w-0">
          <div className="w-8 h-8 rounded-xl bg-gradient-to-br from-orange-500 to-orange-600 shadow-arda flex items-center justify-center flex-shrink-0">
            <Icons.Package className="w-4 h-4 text-white" />
          </div>
          <span className="text-sm font-semibold text-arda-text-primary flex-shrink-0">Arda</span>
          <div className="min-w-0 flex items-center gap-2">
            <span className="text-[11px] text-arda-text-muted flex-shrink-0">
              Step {currentStepIndex + 1} of {ONBOARDING_STEPS.length}
            </span>
            <span className="text-sm font-semibold text-arda-text-primary truncate">
              {currentStepConfig.title}
            </span>
            <span className="hidden md:block text-xs text-arda-text-secondary truncate">
              {currentStepConfig.description}
            </span>
          </div>
        </div>

        <div className="hidden lg:flex items-center gap-1.5 flex-1 justify-center px-4">
          {ONBOARDING_STEPS.map((step, index) => {
            const status = getStepStatus(step.id);
            const Icon = Icons[step.icon] || Icons.Circle;
            const isInteractive = status === 'completed' || status === 'current';
            const isCompleted = status === 'completed';
            const isCurrent = status === 'current';

            return (
              <div key={step.id} className="flex items-center">
                  <button
                    type="button"
                    onClick={() => {
                      if (isInteractive) {
                        setTipsOpenForStep(null);
                        setCurrentStep(step.id);
                      }
                    }}
                    disabled={!isInteractive}
                  className={[
                    'w-7 h-7 rounded-full border flex items-center justify-center transition-colors',
                    isCompleted ? 'bg-arda-accent border-orange-600 text-white' : '',
                    isCurrent ? 'bg-orange-500 border-orange-600 text-white' : '',
                    status === 'upcoming' ? 'bg-white/80 border-arda-border text-arda-text-muted' : '',
                    isInteractive ? 'hover:bg-orange-50' : 'opacity-50 cursor-not-allowed',
                  ].join(' ')}
                  aria-current={isCurrent ? 'step' : undefined}
                  title={step.title}
                >
                  {isCompleted ? <Icons.Check className="w-3 h-3" /> : <Icon className="w-3 h-3" />}
                </button>
                {index < ONBOARDING_STEPS.length - 1 && (
                  <div
                    className={[
                      'w-6 h-[2px] mx-1 rounded-full',
                      completedSteps.has(step.id) ? 'bg-orange-400' : 'bg-arda-border',
                    ].join(' ')}
                  />
                )}
              </div>
            );
          })}
        </div>

        <div className="flex items-center gap-2 flex-shrink-0">
          <div ref={tipsWrapperRef} className="relative">
	            <button
	              type="button"
	              onClick={() => setTipsOpenForStep(open => (open === currentStep ? null : currentStep))}
	              className="btn-arda-outline text-sm py-1.5 flex items-center gap-2"
	              aria-expanded={tipsOpen}
	              aria-controls={`onboarding-tips-${currentStep}`}
	              aria-haspopup="dialog"
	            >
	              <Icons.Lightbulb className="w-4 h-4" />
	              <span className="sr-only sm:not-sr-only">Tips</span>
	            </button>

            {tipsOpen && (
              <div
	                id={`onboarding-tips-${currentStep}`}
	                role="dialog"
	                aria-label={currentStepConfig.tipsTitle}
	                className="absolute right-0 top-full mt-2 w-80 max-w-[calc(100vw-2rem)] rounded-xl border border-arda-border bg-white/95 backdrop-blur shadow-lg p-3 z-50"
	              >
                <div className="text-[11px] font-semibold text-arda-text-muted uppercase tracking-wide">
                  {currentStepConfig.tipsTitle}
                </div>
                <ul className="mt-2 text-xs text-arda-text-secondary space-y-1 list-disc list-inside">
                  {currentStepConfig.tips.map((tip, index) => (
                    <li key={`${currentStep}-${index}`}>{tip}</li>
                  ))}
                </ul>
              </div>
            )}
          </div>

          {userProfile?.email && (
            <div className="hidden sm:flex items-center gap-2 text-xs text-arda-text-secondary bg-white/70 border border-arda-border rounded-xl px-2.5 py-1.5">
              <Icons.Mail className="w-3.5 h-3.5 text-arda-text-muted" />
              <span className="max-w-[14rem] truncate">{userProfile.email}</span>
            </div>
          )}

          <button
            type="button"
            onClick={onSkip}
            className="text-xs font-medium text-arda-text-muted hover:text-arda-text-primary hover:bg-white/70 border border-transparent hover:border-arda-border rounded-xl px-2.5 py-1.5 transition-colors"
          >
            Exit
          </button>
        </div>
      </div>

      <div className="absolute inset-x-0 bottom-0 h-1 bg-arda-bg-tertiary overflow-hidden">
        <div
          className="h-full bg-gradient-to-r from-orange-400 to-orange-500 transition-all duration-300"
          style={{ width: `${((currentStepIndex + 1) / ONBOARDING_STEPS.length) * 100}%` }}
          role="progressbar"
          aria-label="Onboarding progress"
          aria-valuenow={currentStepIndex + 1}
          aria-valuemin={1}
          aria-valuemax={ONBOARDING_STEPS.length}
        />
      </div>
    </div>
  );

  // Render current step content (keep SupplierSetup mounted so background imports continue)
  const renderStepContent = () => (
    <>
      {currentStep === 'welcome' && (
        <OnboardingWelcomeStep
          steps={ONBOARDING_STEPS.filter(step => step.id !== 'welcome')}
          userProfile={userProfile}
          onStartEmailSync={handleStartEmailSync}
          onSkipEmail={handleSkipEmailSync}
        />
      )}

      <div className={currentStep === 'email' ? '' : 'hidden'}>
        {hasStartedEmailSync ? (
          <SupplierSetup
            onScanComplete={handleEmailOrdersUpdate}
            onSkip={() => handleStepComplete('email')}
            onCanProceed={handleCanProceedFromEmail}
            onStateChange={handleEmailScanStateChange}
            initialState={emailScanState}
            embedded
          />
        ) : (
          <div className="space-y-4">
            <div className="card-arda p-6 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
              <div>
                <h3 className="text-lg font-semibold text-arda-text-primary">Start email sync</h3>
                <p className="text-sm text-arda-text-secondary mt-1">
                  Email scanning will run in the background while you continue.
                </p>
              </div>
              <button
                type="button"
                onClick={() => setHasStartedEmailSync(true)}
                className="btn-arda-primary"
              >
                Start email sync
              </button>
            </div>
          </div>
        )}
      </div>

      {currentStep === 'integrations' && (
        <IntegrationsStep />
      )}

      {currentStep === 'url' && (
        <div className="space-y-3">
          {urlReviewBlockMessage && (
            <div className="rounded-xl border border-orange-200 bg-orange-50 text-orange-900 text-xs px-3 py-2">
              {urlReviewBlockMessage}
            </div>
          )}
          <UrlScrapeStep
            importedItems={urlItems}
            onImportItems={(items) => {
              setUrlItems(previousItems => {
                const merged = new Map(previousItems.map(item => [item.sourceUrl, item]));
                items.forEach(item => {
                  merged.set(item.sourceUrl, item);
                });
                return Array.from(merged.values());
              });
            }}
            onDeleteImportedItem={(sourceUrl) => {
              setUrlItems(previousItems => previousItems.filter(item => item.sourceUrl !== sourceUrl));
            }}
            onReviewStateChange={handleUrlReviewStateChange}
          />
        </div>
      )}
      
      {currentStep === 'barcode' && (
        <BarcodeScanStep
          sessionId={mobileSessionId}
          scannedBarcodes={scannedBarcodes}
          onBarcodeScanned={handleBarcodeScanned}
          onComplete={() => handleStepComplete('barcode')}
          onBack={() => {
            setTipsOpenForStep(null);
            setCurrentStep('url');
          }}
        />
      )}
      
      {currentStep === 'photo' && (
        <PhotoCaptureStep
          sessionId={mobileSessionId}
          capturedPhotos={capturedPhotos}
          onPhotoCaptured={handlePhotoCaptured}
          onComplete={() => handleStepComplete('photo')}
          onBack={() => {
            setTipsOpenForStep(null);
            setCurrentStep('barcode');
          }}
        />
      )}

      {currentStep === 'csv' && (
        <CSVUploadStep
          onComplete={handleCSVComplete}
          onBack={() => {
            setTipsOpenForStep(null);
            setCurrentStep('photo');
          }}
          onFooterStateChange={setCsvFooterState}
        />
      )}

      {currentStep === 'masterlist' && (
        <MasterListStep
          items={masterItems}
          syncStateById={syncStateById}
          isBulkSyncing={isBulkSyncing}
          onSyncSingle={syncSingleItem}
          onSyncSelected={syncSelectedItems}
          onUpdateItem={updateItem}
          onRemoveItem={removeItem}
          onComplete={handleMasterListComplete}
          onBack={() => {
            setTipsOpenForStep(null);
            setCurrentStep('csv');
          }}
          onFooterStateChange={setMasterListFooterState}
        />
      )}
    </>
  );

  return (
    <div className="relative min-h-screen arda-mesh flex flex-col">
      <div className="absolute inset-0 pointer-events-none overflow-hidden">
        <div className="absolute -top-10 left-10 w-56 h-56 rounded-full bg-orange-400/15 blur-3xl animate-float" />
        <div className="absolute top-32 right-12 w-72 h-72 rounded-full bg-blue-500/10 blur-3xl animate-float" />
      </div>
      {/* Step indicator */}
      {renderStepIndicator()}

      {/* Main content */}
      <div className="relative z-10 flex-1 px-4 sm:px-6 py-4 pb-20">
        <div className={
          currentStep === 'masterlist'
            ? 'max-w-none w-full'
            : isPanelVisible
              ? 'flex flex-col lg:flex-row gap-6 max-w-none'
              : 'max-w-6xl mx-auto'
        }>
          {/* Step content — left side */}
          <div className={
            isPanelVisible && currentStep !== 'masterlist'
              ? 'w-full lg:w-[40%] lg:min-w-[380px] lg:flex-shrink-0'
              : 'w-full'
          }>
            {renderStepContent()}
          </div>

          {/* AG Grid — right side panel (visible on non-masterlist steps) */}
          {isPanelVisible && currentStep !== 'masterlist' && (
            <div className="flex-1 min-w-0 lg:sticky lg:top-14 lg:self-start lg:max-h-[calc(100vh-10rem)] overflow-hidden rounded-xl border border-arda-border bg-white shadow-sm">
              <ItemsGrid
                items={masterItems}
                onUpdateItem={updateItem}
                onRemoveItem={removeItem}
                syncStateById={syncStateById}
                onSyncSingle={syncSingleItem}
                mode="panel"
              />
            </div>
          )}

          {/* Review step — grid is full-width (rendered by MasterListStep) */}
          {currentStep === 'masterlist' && (
            <div className="w-full rounded-xl border border-arda-border bg-white shadow-sm overflow-hidden mt-4">
              <ItemsGrid
                items={masterItems}
                onUpdateItem={updateItem}
                onRemoveItem={removeItem}
                syncStateById={syncStateById}
                onSyncSingle={syncSingleItem}
                mode="fullpage"
              />
            </div>
          )}
        </div>
      </div>

      {renderFooterNavigation()}
    </div>
  );
};

```

### `src/views/OnboardingWelcomeStep.tsx`

```tsx
import { Icons } from '../components/Icons';

interface WelcomeStepItem {
  id: string;
  title: string;
  description: string;
  icon: keyof typeof Icons;
}

interface OnboardingWelcomeStepProps {
  steps: WelcomeStepItem[];
  userProfile?: { name?: string; email?: string };
  onStartEmailSync: () => void;
  onSkipEmail: () => void;
}

export const OnboardingWelcomeStep: React.FC<OnboardingWelcomeStepProps> = ({
  steps,
  userProfile,
  onStartEmailSync,
  onSkipEmail,
}) => {
  const firstName = userProfile?.name?.split(' ')[0];

  return (
    <div className="space-y-5">
      <div className="card-arda p-6">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-2xl bg-orange-50 border border-orange-100 flex items-center justify-center">
            <Icons.Sparkles className="w-6 h-6 text-arda-accent" />
          </div>
          <div>
            <h2 className="text-2xl font-bold text-arda-text-primary">
              {firstName ? `Thanks for signing up, ${firstName}.` : 'Thanks for signing up for Arda.'}
            </h2>
            <p className="text-sm text-arda-text-secondary mt-1">
              Here is the onboarding path. You can skip any step and return later.
            </p>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {steps.map((step, index) => {
          const Icon = Icons[step.icon] || Icons.Circle;
          return (
            <div key={step.id} className="card-arda p-4">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-xl bg-arda-bg-tertiary border border-arda-border flex items-center justify-center">
                  <Icon className="w-5 h-5 text-arda-text-secondary" />
                </div>
                <div>
                  <p className="text-xs text-arda-text-muted">Step {index + 1}</p>
                  <h3 className="text-base font-semibold text-arda-text-primary">{step.title}</h3>
                </div>
              </div>
              <p className="mt-2 text-sm text-arda-text-secondary">
                {step.description}
              </p>
            </div>
          );
        })}
      </div>

      <div className="flex flex-col sm:flex-row gap-3">
        <button
          type="button"
          onClick={onStartEmailSync}
          className="btn-arda-primary flex items-center justify-center gap-2 px-6 py-3"
        >
          <Icons.Mail className="w-4 h-4" />
          Start email sync
        </button>
        <button
          type="button"
          onClick={onSkipEmail}
          className="btn-arda-outline flex items-center justify-center gap-2 px-6 py-3"
        >
          <Icons.ArrowRight className="w-4 h-4" />
          Skip email for now
        </button>
      </div>
    </div>
  );
};

```

### `src/views/PhotoCaptureStep.tsx`

```tsx
import { useState, useEffect, useRef, useCallback } from 'react';
import { Icons } from '../components/Icons';
import { CapturedPhoto } from './OnboardingFlow';
import { API_BASE_URL } from '../services/api';

interface PhotoCaptureStepProps {
  sessionId: string;
  capturedPhotos: CapturedPhoto[];
  onPhotoCaptured: (photo: CapturedPhoto) => void;
  onComplete?: () => void;
  onBack?: () => void;
}

interface SessionPhotoMetadata {
  id: string;
  source: 'desktop' | 'mobile';
  capturedAt: string;
  suggestedName?: string;
  suggestedSupplier?: string;
  extractedText?: string[];
  detectedBarcodes?: string[];
  isInternalItem?: boolean;
  analyzed?: boolean;
}

type EditablePhotoMetadataField = 'suggestedName' | 'suggestedSupplier' | 'isInternalItem' | 'detectedBarcodes' | 'extractedText';

// Generate QR code URL for mobile photo capture page
const getMobilePhotoUrl = (sessionId: string): string => {
  const baseUrl = window.location.origin;
  return `${baseUrl}/photo/${sessionId}`;
};

export const PhotoCaptureStep: React.FC<PhotoCaptureStepProps> = ({
  sessionId,
  capturedPhotos,
  onPhotoCaptured,
}) => {
  const [dragOver, setDragOver] = useState(false);
  const [analyzingIds, setAnalyzingIds] = useState<Set<string>>(new Set());
  const [savingPhotoId, setSavingPhotoId] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const photoIdCounterRef = useRef(0);
  const capturedPhotosRef = useRef<CapturedPhoto[]>(capturedPhotos);
  const dirtyFieldsByPhotoIdRef = useRef<Map<string, Set<EditablePhotoMetadataField>>>(new Map());
  const savingPhotoIdRef = useRef<string | null>(null);

  useEffect(() => {
    capturedPhotosRef.current = capturedPhotos;
  }, [capturedPhotos]);

  useEffect(() => {
    savingPhotoIdRef.current = savingPhotoId;
  }, [savingPhotoId]);

  const markPhotoDirty = useCallback((photoId: string, field: EditablePhotoMetadataField) => {
    const current = dirtyFieldsByPhotoIdRef.current.get(photoId);
    if (current) {
      current.add(field);
      return;
    }
    dirtyFieldsByPhotoIdRef.current.set(photoId, new Set([field]));
  }, []);

  const clearPhotoDirty = useCallback((photoId: string) => {
    dirtyFieldsByPhotoIdRef.current.delete(photoId);
  }, []);

  const nextPhotoId = useCallback(() => {
    photoIdCounterRef.current += 1;
    return `photo-${photoIdCounterRef.current}`;
  }, []);

  const markAnalyzing = useCallback((photoId: string, isAnalyzing: boolean) => {
    setAnalyzingIds((prev) => {
      const next = new Set(prev);
      if (isAnalyzing) next.add(photoId);
      else next.delete(photoId);
      return next;
    });
  }, []);

  const persistPhotoToSession = useCallback(async (photo: CapturedPhoto): Promise<void> => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/photo/session/${sessionId}/photo`, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: photo.id,
          data: photo.imageData,
          timestamp: photo.capturedAt,
          source: photo.source,
        }),
      });
      if (!response.ok) {
        markAnalyzing(photo.id, false);
      }
    } catch {
      markAnalyzing(photo.id, false);
    }
  }, [markAnalyzing, sessionId]);

  const persistPhotoMetadata = useCallback(async (photoId: string, override?: CapturedPhoto): Promise<void> => {
    const photo = override || capturedPhotosRef.current.find((item) => item.id === photoId);
    if (!photo) return;

    const dirtyFields = dirtyFieldsByPhotoIdRef.current.get(photo.id);
    if (!dirtyFields || dirtyFields.size === 0) return;

    setSavingPhotoId(photo.id);
    try {
      const payload: Record<string, unknown> = {};

      if (dirtyFields.has('suggestedName')) payload.suggestedName = photo.suggestedName ?? '';
      if (dirtyFields.has('suggestedSupplier')) payload.suggestedSupplier = photo.suggestedSupplier ?? '';
      if (dirtyFields.has('isInternalItem')) payload.isInternalItem = photo.isInternalItem ?? null;
      if (dirtyFields.has('detectedBarcodes')) payload.detectedBarcodes = photo.detectedBarcodes ?? [];
      if (dirtyFields.has('extractedText')) payload.extractedText = photo.extractedText ?? [];

      const response = await fetch(`${API_BASE_URL}/api/photo/session/${sessionId}/photo/${encodeURIComponent(photo.id)}`, {
        method: 'PUT',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!response.ok) return;
      const data = await response.json();
      if (data?.photo) {
        clearPhotoDirty(photo.id);
        onPhotoCaptured({
          ...photo,
          ...data.photo,
        });
      }
    } catch {
      // Keep local edits even if save fails.
    } finally {
      setSavingPhotoId((current) => (current === photo.id ? null : current));
    }
  }, [clearPhotoDirty, onPhotoCaptured, sessionId]);

  // Process uploaded file
  const processFile = useCallback(async (file: File) => {
    const reader = new FileReader();

    reader.onload = async (event) => {
      const imageData = event.target?.result as string;
      const photoId = nextPhotoId();

      const photo: CapturedPhoto = {
        id: photoId,
        imageData,
        capturedAt: new Date().toISOString(),
        source: 'desktop',
      };

      onPhotoCaptured(photo);
      markAnalyzing(photoId, true);
      await persistPhotoToSession(photo);
    };

    reader.readAsDataURL(file);
  }, [markAnalyzing, nextPhotoId, onPhotoCaptured, persistPhotoToSession]);

  // Poll session photos and merge metadata updates.
  useEffect(() => {
    const syncPhotos = async () => {
      try {
        const response = await fetch(`${API_BASE_URL}/api/photo/session/${sessionId}/photos`, {
          credentials: 'include',
        });
        if (!response.ok) return;
        const data = await response.json();
        if (!data.photos || !Array.isArray(data.photos)) return;

        const localPhotos = capturedPhotosRef.current;
        const currentlySavingId = savingPhotoIdRef.current;

        for (const photoMeta of data.photos as SessionPhotoMetadata[]) {
          markAnalyzing(photoMeta.id, !photoMeta.analyzed);
          const existing = localPhotos.find((photo) => photo.id === photoMeta.id);

          if (existing) {
            const dirtyFields = dirtyFieldsByPhotoIdRef.current.get(photoMeta.id);
            if ((dirtyFields && dirtyFields.size > 0) || currentlySavingId === photoMeta.id) {
              continue;
            }

            const merged: CapturedPhoto = {
              ...existing,
              source: photoMeta.source ?? existing.source,
              capturedAt: photoMeta.capturedAt ?? existing.capturedAt,
              suggestedName: photoMeta.suggestedName ?? existing.suggestedName,
              suggestedSupplier: photoMeta.suggestedSupplier ?? existing.suggestedSupplier,
              extractedText: photoMeta.extractedText ?? existing.extractedText,
              detectedBarcodes: photoMeta.detectedBarcodes ?? existing.detectedBarcodes,
              isInternalItem: photoMeta.isInternalItem ?? existing.isInternalItem,
            };

            const changed = JSON.stringify(existing) !== JSON.stringify(merged);
            if (changed) {
              onPhotoCaptured(merged);
            }
            continue;
          }

          try {
            const imageResponse = await fetch(
              `${API_BASE_URL}/api/photo/session/${sessionId}/photo/${photoMeta.id}`,
              { credentials: 'include' },
            );
            if (!imageResponse.ok) continue;

            const { photo: fullPhoto } = await imageResponse.json();
            onPhotoCaptured({
              id: fullPhoto.id,
              imageData: fullPhoto.imageData,
              source: fullPhoto.source || 'mobile',
              capturedAt: fullPhoto.capturedAt,
              suggestedName: fullPhoto.suggestedName,
              suggestedSupplier: fullPhoto.suggestedSupplier,
              extractedText: fullPhoto.extractedText,
              detectedBarcodes: fullPhoto.detectedBarcodes,
              isInternalItem: fullPhoto.isInternalItem,
            });
          } catch {
            // Ignore individual photo fetch errors
          }
        }
      } catch {
        // Ignore polling errors
      }
    };

    void syncPhotos();
    const pollInterval = setInterval(() => {
      void syncPhotos();
    }, 2000);

    return () => clearInterval(pollInterval);
  }, [markAnalyzing, onPhotoCaptured, sessionId]);

  // Handle file drop
  const handleDrop = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    setDragOver(false);

    const files = Array.from(event.dataTransfer.files).filter((file) =>
      file.type.startsWith('image/'),
    );

    files.forEach((file) => void processFile(file));
  }, [processFile]);

  // Handle file selection
  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || []);
    files.forEach((file) => void processFile(file));
    event.target.value = '';
  };

  const updatePhotoLocal = useCallback((photo: CapturedPhoto, updates: Partial<CapturedPhoto>) => {
    onPhotoCaptured({
      ...photo,
      ...updates,
    });
  }, [onPhotoCaptured]);

  // Generate QR code URL
  const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(getMobilePhotoUrl(sessionId))}`;

  return (
    <div className="space-y-4">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div
          className={`
            card-arda p-6 space-y-4 transition-colors cursor-pointer
            ${dragOver ? 'border-orange-300 bg-orange-50' : 'hover:border-arda-border-hover'}
          `}
          onDragOver={(event) => { event.preventDefault(); setDragOver(true); }}
          onDragLeave={() => setDragOver(false)}
          onDrop={handleDrop}
          onClick={() => fileInputRef.current?.click()}
        >
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 bg-orange-50 rounded-2xl flex items-center justify-center border border-orange-100">
              <Icons.Upload className="w-6 h-6 text-arda-accent" />
            </div>
            <div>
              <h3 className="font-semibold text-arda-text-primary">Upload photos</h3>
              <p className="text-sm text-arda-text-secondary">Drag & drop or click to select</p>
            </div>
          </div>

          <div className="border-2 border-dashed border-arda-border rounded-2xl p-8 text-center bg-white/60">
            <Icons.Camera className="w-10 h-10 text-arda-text-muted mx-auto mb-3 opacity-60" />
            <p className="text-arda-text-secondary">
              Drop images here or <span className="text-arda-accent font-medium">browse</span>
            </p>
            <p className="text-xs text-arda-text-muted mt-1">Supports JPG, PNG, HEIC</p>
          </div>

          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            multiple
            onChange={handleFileSelect}
            className="hidden"
          />
        </div>

        <div className="card-arda p-6 space-y-4">
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 bg-arda-bg-tertiary rounded-2xl flex items-center justify-center border border-arda-border">
              <Icons.Smartphone className="w-6 h-6 text-arda-text-secondary" />
            </div>
            <div>
              <h3 className="font-semibold text-arda-text-primary">Phone camera</h3>
              <p className="text-sm text-arda-text-secondary">Capture photos and sync them here</p>
            </div>
          </div>

          <div className="flex flex-col items-center gap-3">
            <div className="bg-white p-3 rounded-xl border border-arda-border shadow-arda">
              <img
                src={qrCodeUrl}
                alt="Scan to open mobile camera"
                className="w-40 h-40"
              />
            </div>
            <p className="text-sm text-arda-text-secondary text-center">
              Scan to open the mobile camera.<br />
              Photos will sync to this screen in real-time.
            </p>
          </div>

          <div className="flex items-center gap-2 text-xs text-arda-text-muted bg-white/70 border border-arda-border rounded-xl px-3 py-2">
            <Icons.Link className="w-3 h-3" />
            <span className="font-mono truncate">{getMobilePhotoUrl(sessionId)}</span>
          </div>
        </div>
      </div>

      <div className="card-arda overflow-hidden">
        <div className="px-6 py-4 border-b border-arda-border bg-arda-bg-secondary flex items-center justify-between">
          <h3 className="font-semibold text-arda-text-primary">
            Captured Items ({capturedPhotos.length})
          </h3>
          {capturedPhotos.length > 0 && (
            <span className="text-sm text-arda-text-secondary">
              {capturedPhotos.filter((photo) => photo.suggestedName).length} analyzed
            </span>
          )}
        </div>

        {capturedPhotos.length === 0 ? (
          <div className="px-6 py-12 text-center text-arda-text-muted">
            <Icons.Camera className="w-12 h-12 mx-auto mb-3 opacity-40" />
            <p>No photos captured yet</p>
            <p className="text-sm mt-1 text-arda-text-secondary">Upload or capture photos of items with labels</p>
          </div>
        ) : (
          <div className="grid grid-cols-1 xl:grid-cols-2 gap-4 p-4">
            {capturedPhotos.map((photo) => (
              <div
                key={photo.id}
                className="relative bg-arda-bg-secondary rounded-2xl overflow-hidden border border-arda-border"
              >
                <div className="aspect-square relative">
                  <img
                    src={photo.imageData}
                    alt={photo.suggestedName || 'Captured item'}
                    className="w-full h-full object-cover"
                  />

                  {analyzingIds.has(photo.id) && (
                    <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
                      <div className="text-white text-center">
                        <Icons.Loader2 className="w-8 h-8 animate-spin mx-auto mb-2" />
                        <p className="text-sm">Analyzing...</p>
                      </div>
                    </div>
                  )}

                  <div className="absolute top-2 left-2 px-2 py-1 rounded-lg text-xs font-medium bg-white/85 backdrop-blur border border-white/60 text-arda-text-secondary">
                    {photo.source === 'mobile' ? 'Mobile' : 'Desktop'}
                  </div>
                  <div className="absolute top-2 right-2 px-2 py-1 rounded-lg text-xs font-medium bg-white/85 backdrop-blur border border-white/60 text-arda-text-secondary">
                    {new Date(photo.capturedAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                  </div>
                </div>

                <div className="p-3 space-y-2">
                  <label className="text-xs text-arda-text-secondary block">
                    Item name
                    <input
                      type="text"
                      value={photo.suggestedName || ''}
                      onChange={(event) => {
                        markPhotoDirty(photo.id, 'suggestedName');
                        updatePhotoLocal(photo, { suggestedName: event.target.value || undefined });
                      }}
                      onBlur={() => void persistPhotoMetadata(photo.id)}
                      className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white"
                      placeholder="Item name"
                    />
                  </label>

                  <label className="text-xs text-arda-text-secondary block">
                    Supplier / brand
                    <input
                      type="text"
                      value={photo.suggestedSupplier || ''}
                      onChange={(event) => {
                        markPhotoDirty(photo.id, 'suggestedSupplier');
                        updatePhotoLocal(photo, { suggestedSupplier: event.target.value || undefined });
                      }}
                      onBlur={() => void persistPhotoMetadata(photo.id)}
                      className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white"
                      placeholder="Supplier"
                    />
                  </label>

                  <label className="text-xs text-arda-text-secondary block">
                    Classification
                    <select
                      value={
                        photo.isInternalItem === true
                          ? 'internal'
                          : photo.isInternalItem === false
                            ? 'purchased'
                            : 'unknown'
                      }
                      onChange={(event) => {
                        markPhotoDirty(photo.id, 'isInternalItem');
                        const nextValue = event.target.value === 'unknown'
                          ? undefined
                          : event.target.value === 'internal';
                        const updated = { ...photo, isInternalItem: nextValue };
                        updatePhotoLocal(photo, { isInternalItem: nextValue });
                        void persistPhotoMetadata(photo.id, updated);
                      }}
                      className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white"
                    >
                      <option value="unknown">Unknown</option>
                      <option value="internal">Internal</option>
                      <option value="purchased">Purchased</option>
                    </select>
                  </label>

                  <label className="text-xs text-arda-text-secondary block">
                    Detected barcodes (comma separated)
                    <input
                      type="text"
                      value={photo.detectedBarcodes?.join(', ') || ''}
                      onChange={(event) => {
                        markPhotoDirty(photo.id, 'detectedBarcodes');
                        const next = event.target.value
                          .split(',')
                          .map((entry) => entry.trim())
                          .filter(Boolean);
                        updatePhotoLocal(photo, { detectedBarcodes: next.length > 0 ? next : undefined });
                      }}
                      onBlur={() => void persistPhotoMetadata(photo.id)}
                      className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white font-mono"
                      placeholder="0123456789012, 998877665544"
                    />
                  </label>

                  <label className="text-xs text-arda-text-secondary block">
                    Extracted text (one line per item)
                    <textarea
                      value={photo.extractedText?.join('\n') || ''}
                      onChange={(event) => {
                        markPhotoDirty(photo.id, 'extractedText');
                        const lines = event.target.value
                          .split('\n')
                          .map((entry) => entry.trim())
                          .filter(Boolean);
                        updatePhotoLocal(photo, { extractedText: lines.length > 0 ? lines : undefined });
                      }}
                      onBlur={() => void persistPhotoMetadata(photo.id)}
                      rows={3}
                      className="mt-1 w-full px-2 py-1 text-sm border border-arda-border rounded bg-white"
                      placeholder={'Line 1\nLine 2'}
                    />
                  </label>

                  {savingPhotoId === photo.id && (
                    <div className="inline-flex items-center gap-1 text-xs text-arda-accent">
                      <Icons.Loader2 className="w-3 h-3 animate-spin" />
                      <span>Saving edits</span>
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      <div className="bg-white/70 border border-arda-border rounded-arda-lg px-4 py-3">
        <div className="flex items-start gap-3">
          <Icons.Lightbulb className="w-5 h-5 text-arda-accent flex-shrink-0 mt-0.5" />
          <div className="text-sm text-arda-text-secondary">
            <p className="font-medium text-arda-text-primary mb-1">Photo tips for best results</p>
            <ul className="list-disc list-inside space-y-0.5 text-arda-text-secondary">
              <li>Capture labels, packaging, or product markings clearly</li>
              <li>For internally-produced items, photo any part numbers or SKUs</li>
              <li>Good lighting helps with text extraction</li>
              <li>Multiple angles can help identify products</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
};

```

### `src/views/SupplierSetup.tsx`

```tsx
import { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { Icons } from '../components/Icons';
import { ExtractedOrder } from '../types';
import {
  discoverApi,
  jobsApi,
  JobStatus,
  DiscoveredSupplier,
  isSessionExpiredError,
  gmailApi,
  ApiRequestError,
  API_BASE_URL,
} from '../services/api';
import { mergeSuppliers } from '../utils/supplierUtils';
import {
  buildSupplierGridItems,
  canonicalizePrioritySupplierDomain,
  calculateProgressPercent,
  getPrioritySummaryText,
  getMilestoneMessage,
  isPrioritySupplierDomain,
  MILESTONES,
  OTHER_PRIORITY_SUPPLIERS,
  PRIORITY_SUPPLIER_SCAN_DOMAINS,
} from './supplierSetupUtils';

// Lean manufacturing wisdom - displayed while we ironically batch-process emails
const LEAN_WISDOM = [
  {
    quote: "The irony of batch-processing your emails to teach you about single-piece flow is not lost on us.",
    attribution: "— Arda Engineering, probably",
  },
  {
    quote: "Batch processing: Because nothing says 'efficiency' like making 49 emails wait for the 50th.",
    attribution: "— Every ERP System Ever",
  },
  {
    quote: "In the time it takes to batch 100 orders, you could have flowed 100 orders. But here we are.",
    attribution: "— Taiichi Ohno, if he saw this loading screen",
  },
  {
    quote: "A batch in process is inventory in disguise. Speaking of which, we're currently 'inventorying' your inbox.",
    attribution: "— The Toyota Production System",
  },
  {
    quote: "Single-piece flow means doing one thing at a time. We're doing all your emails at once. Do as we say, not as we code.",
    attribution: "— Software Engineering Proverb",
  },
  {
    quote: "The best time to stop batching was 20 years ago. The second best time is after this loading screen finishes.",
    attribution: "— Ancient Lean Proverb",
  },
  {
    quote: "Every email we batch-process right now is a little lesson in why you shouldn't batch-process.",
    attribution: "— The Arda Paradox",
  },
  {
    quote: "If Ohno saw this loading spinner, he'd probably suggest we process one email, deliver the insight, then get the next one.",
    attribution: "— Things We Know But Don't Do",
  },
  {
    quote: "WIP limits are great! We're currently ignoring ours. Don't be like us.",
    attribution: "— Kanban's Disappointed Dad Voice",
  },
  {
    quote: "Small batches reduce lead time. Anyway, here's 500 emails at once.",
    attribution: "— Arda's Growth Team",
  },
  {
    quote: "The goal of lean is to eliminate waste. This loading screen is technically waste. We're working on it.",
    attribution: "— Our Product Roadmap, Probably",
  },
  {
    quote: "Flow efficiency > resource efficiency. Unless you're an email parser. Then it's complicated.",
    attribution: "— DevOps Philosophy",
  },
  {
    quote: "Muda, Mura, Muri: Waste, Unevenness, Overburden. This scan has all three. Your shop floor shouldn't.",
    attribution: "— TPS for Hypocrites",
  },
  {
    quote: "The seven wastes include 'waiting.' You're welcome.",
    attribution: "— This Loading Screen",
  },
  {
    quote: "The seven wastes also include 'wasted human potential.' So. Yeah. There's a lot of other stuff we could be doing here.",
    attribution: "— This Loading Screen",
  },
  {
    quote: "One-piece flow would be: scan email → show insight → repeat. But our PM wanted a 'wow moment.' So here we batch.",
    attribution: "— Honest Engineering Notes",
  },
];

// Module-level cache for discovery results to handle StrictMode remounts
// When the first mount's API call completes, results are cached here
// so the second mount can use them instead of making another call
let moduleDiscoveryPromise: Promise<{ suppliers: DiscoveredSupplier[] }> | null = null;
let moduleDiscoveryResult: DiscoveredSupplier[] | null = null;
const SESSION_EXPIRED_MESSAGE = 'Session expired. Please sign in again.';
const GMAIL_REQUIRED_MESSAGE = 'Connect Gmail to start email analysis.';

// Background progress type for parent components
interface BackgroundEmailProgress {
  isActive: boolean;
  supplier: string;
  processed: number;
  total: number;
  currentTask?: string;
}

// State that can be preserved when navigating away
export interface EmailScanState {
  amazonOrders: ExtractedOrder[];
  priorityOrders: ExtractedOrder[];
  otherOrders: ExtractedOrder[];
  isAmazonComplete: boolean;
  isPriorityComplete: boolean;
  discoveredSuppliers: DiscoveredSupplier[];
  hasDiscovered: boolean;
  hasStartedOtherImport?: boolean;
  selectedOtherSuppliers?: string[];
}

interface SupplierSetupProps {
  onScanComplete: (orders: ExtractedOrder[]) => void;
  onSkip: () => void;
  onProgressUpdate?: (progress: BackgroundEmailProgress | null) => void;
  onCanProceed?: (canProceed: boolean) => void;
  onStateChange?: (state: EmailScanState) => void;
  initialState?: EmailScanState;
  embedded?: boolean;
}

export const SupplierSetup: React.FC<SupplierSetupProps> = ({
  onScanComplete,
  onProgressUpdate,
  onCanProceed,
  onStateChange,
  initialState,
  embedded = false,
}) => {
  // Track if we already have restored state (don't restart scans)
  const hasRestoredState = Boolean(initialState && (initialState.amazonOrders.length > 0 || initialState.priorityOrders.length > 0 || initialState.otherOrders.length > 0));
  
  // Onboarding phase states
  const [showWelcome, setShowWelcome] = useState(!hasRestoredState);
  const [celebratingMilestone, setCelebratingMilestone] = useState<string | null>(null);
  const [achievedMilestones, setAchievedMilestones] = useState<Set<string>>(new Set());
  
  // Lean wisdom rotation
  const [wisdomIndex, setWisdomIndex] = useState(() => Math.floor(Math.random() * LEAN_WISDOM.length));
  
  // Discovery progress messages for better feedback
  const [discoveryMessageIndex, setDiscoveryMessageIndex] = useState(0);
  const DISCOVERY_MESSAGES = useMemo(() => [
    'Scanning your inbox for suppliers...',
    'Looking for order confirmations...',
    'Identifying supplier domains...',
    'Analyzing email patterns...',
    'Finding shipping notifications...',
    'Detecting invoice emails...',
  ], []);

  // Amazon processing state (starts immediately if no initial state)
  const [amazonJobId, setAmazonJobId] = useState<string | null>(null);
  const [amazonStatus, setAmazonStatus] = useState<JobStatus | null>(null);
  const [amazonOrders, setAmazonOrders] = useState<ExtractedOrder[]>(initialState?.amazonOrders || []);
  const [amazonError, setAmazonError] = useState<string | null>(null);
  const [isAmazonComplete, setIsAmazonComplete] = useState(initialState?.isAmazonComplete || false);
  const amazonPollAbortRef = useRef<{ cancelled: boolean }>({ cancelled: false });

  // Priority suppliers (McMaster-Carr, Uline) processing state (starts immediately if no initial state)
  const [priorityJobId, setPriorityJobId] = useState<string | null>(null);
  const [priorityStatus, setPriorityStatus] = useState<JobStatus | null>(null);
  const [priorityOrders, setPriorityOrders] = useState<ExtractedOrder[]>(initialState?.priorityOrders || []);
  const [priorityError, setPriorityError] = useState<string | null>(null);
  const [isPriorityComplete, setIsPriorityComplete] = useState(initialState?.isPriorityComplete || false);
  const priorityPollAbortRef = useRef<{ cancelled: boolean }>({ cancelled: false });

  const [gmailStatus, setGmailStatus] = useState<{ connected: boolean; gmailEmail?: string | null } | null>(null);
  const [gmailStatusError, setGmailStatusError] = useState<string | null>(null);

  // Discovery state (runs in parallel)
  const [isDiscovering, setIsDiscovering] = useState(false);
  const [discoveredSuppliers, setDiscoveredSuppliers] = useState<DiscoveredSupplier[]>(initialState?.discoveredSuppliers || []);
  const [enabledSuppliers, setEnabledSuppliers] = useState<Set<string>>(() => {
    const base = new Set<string>();
    if (initialState?.selectedOtherSuppliers) {
      initialState.selectedOtherSuppliers.forEach(domain => {
        const normalizedDomain = canonicalizePrioritySupplierDomain(domain);
        if (!isPrioritySupplierDomain(normalizedDomain) && !normalizedDomain.includes('amazon')) {
          base.add(normalizedDomain);
        }
      });
    }
    return base;
  });
  const [discoverError, setDiscoverError] = useState<string | null>(null);
  const [hasDiscovered, setHasDiscovered] = useState(initialState?.hasDiscovered || false);
  // Ref to prevent re-triggering discovery after an error (avoids infinite loop)
  // Initialize based on whether we already have discovered state (handles StrictMode remounts)
  const hasInitiatedDiscovery = useRef(initialState?.hasDiscovered || false);

  // Other suppliers scanning state
  const [isScanning, setIsScanning] = useState(false);
  const [currentJobId, setCurrentJobId] = useState<string | null>(null);
  const [jobStatus, setJobStatus] = useState<JobStatus | null>(null);
  const [otherOrders, setOtherOrders] = useState<ExtractedOrder[]>(initialState?.otherOrders || []);
  const [otherScanError, setOtherScanError] = useState<string | null>(null);
  const otherPollAbortRef = useRef<{ cancelled: boolean }>({ cancelled: false });
  const [hasStartedOtherImport, setHasStartedOtherImport] = useState<boolean>(
    initialState?.hasStartedOtherImport || false,
  );
  const [showContinueAnytimePopup, setShowContinueAnytimePopup] = useState(false);
  const [hasShownContinueAnytimePopup, setHasShownContinueAnytimePopup] = useState(false);

  const getErrorMessage = useCallback((error: unknown, fallback: string): string => {
    if (isSessionExpiredError(error)) {
      return SESSION_EXPIRED_MESSAGE;
    }
    if (error instanceof ApiRequestError && error.code === 'GMAIL_AUTH_REQUIRED') {
      return GMAIL_REQUIRED_MESSAGE;
    }
    return error instanceof Error && error.message ? error.message : fallback;
  }, []);

  const isGmailConnected = Boolean(gmailStatus?.connected);

  useEffect(() => {
    let isMounted = true;

    const loadGmailStatus = async () => {
      try {
        const status = await gmailApi.getStatus();
        if (isMounted) {
          setGmailStatus(status);
          setGmailStatusError(null);
        }
      } catch (error: unknown) {
        const message = getErrorMessage(error, 'Unable to check Gmail connection.');
        if (isMounted) {
          setGmailStatusError(message);
          setGmailStatus({ connected: false, gmailEmail: null });
        }
      }
    };

    void loadGmailStatus();

    return () => {
      isMounted = false;
    };
  }, [getErrorMessage]);

  // Computed values for the experience
  const allItems = useMemo(() => {
    const items: Array<{ name: string; price: number; supplier: string; image?: string; date: string }> = [];
    
    amazonOrders.forEach(order => {
      order.items.forEach(item => {
        items.push({
          name: item.amazonEnriched?.itemName || item.name,
          price: item.unitPrice || 0,
          supplier: 'Amazon',
          image: item.amazonEnriched?.imageUrl,
          date: order.orderDate,
        });
      });
    });
    
    priorityOrders.forEach(order => {
      order.items.forEach(item => {
        items.push({
          name: item.name,
          price: item.unitPrice || 0,
          supplier: order.supplier,
          date: order.orderDate,
        });
      });
    });
    
    otherOrders.forEach(order => {
      order.items.forEach(item => {
        items.push({
          name: item.name,
          price: item.unitPrice || 0,
          supplier: order.supplier,
          date: order.orderDate,
        });
      });
    });
    
    return items;
  }, [amazonOrders, priorityOrders, otherOrders]);

  const totalSpend = useMemo(() => {
    return allItems.reduce((sum, item) => sum + (item.price || 0), 0);
  }, [allItems]);

  const combinedOrders = useMemo(() => {
    return [...amazonOrders, ...priorityOrders, ...otherOrders];
  }, [amazonOrders, priorityOrders, otherOrders]);

  const totalOrders = combinedOrders.length;
  const uniqueSuppliers = useMemo(() => {
    const suppliers = new Set<string>();
    allItems.forEach(item => suppliers.add(item.supplier));
    return suppliers.size;
  }, [allItems]);

  // Merge priority suppliers with discovered ones (excluding Amazon)
  const allSuppliers = useMemo(
    () =>
      mergeSuppliers(OTHER_PRIORITY_SUPPLIERS, discoveredSuppliers, {
        canonicalizeDomain: canonicalizePrioritySupplierDomain,
      }),
    [discoveredSuppliers],
  );

  // Filter out priority suppliers for the selectable list
  const selectableOtherSuppliers = useMemo(
    () =>
      allSuppliers.filter(
        s => !isPrioritySupplierDomain(s.domain) && !s.domain.includes('amazon'),
      ),
    [allSuppliers],
  );

  // Suppliers that actually require an explicit import (non-priority, non-Amazon)
  const otherSuppliersToScan = useMemo(() => selectableOtherSuppliers.map(s => s.domain), [selectableOtherSuppliers]);

  const selectedOtherSuppliers = useMemo(
    () => Array.from(enabledSuppliers).filter(domain => otherSuppliersToScan.includes(domain)),
    [enabledSuppliers, otherSuppliersToScan],
  );

  const selectedOtherCount = selectedOtherSuppliers.length;
  const hasSelectableOtherSuppliers = otherSuppliersToScan.length > 0;

  // Check for milestone achievements
  useEffect(() => {
    const newMilestones = new Set(achievedMilestones);
    
    if (allItems.length >= MILESTONES.firstItem && !achievedMilestones.has('firstItem')) {
      newMilestones.add('firstItem');
      setCelebratingMilestone('firstItem');
      setTimeout(() => setCelebratingMilestone(null), 2000);
    }
    
    if (allItems.length >= MILESTONES.tenItems && !achievedMilestones.has('tenItems')) {
      newMilestones.add('tenItems');
      setCelebratingMilestone('tenItems');
      setTimeout(() => setCelebratingMilestone(null), 2000);
    }
    
    if (allItems.length >= MILESTONES.fiftyItems && !achievedMilestones.has('fiftyItems')) {
      newMilestones.add('fiftyItems');
      setCelebratingMilestone('fiftyItems');
      setTimeout(() => setCelebratingMilestone(null), 2500);
    }
    
    if (newMilestones.size !== achievedMilestones.size) {
      setAchievedMilestones(newMilestones);
    }
  }, [allItems.length, achievedMilestones]);

  // Hide welcome after processing starts
  useEffect(() => {
    if (amazonJobId || priorityJobId) {
      const timer = setTimeout(() => setShowWelcome(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [amazonJobId, priorityJobId]);

  // Rotate lean wisdom (every 10 seconds, always running)
  useEffect(() => {
    const interval = setInterval(() => {
      setWisdomIndex(prev => (prev + 1) % LEAN_WISDOM.length);
    }, 10000);
    
    return () => clearInterval(interval);
  }, [hasRestoredState]);
  
  // Rotate discovery messages while scanning (every 2.5 seconds)
  useEffect(() => {
    if (!isDiscovering) return;
    
    const interval = setInterval(() => {
      setDiscoveryMessageIndex(prev => (prev + 1) % DISCOVERY_MESSAGES.length);
    }, 2500);
    
    return () => clearInterval(interval);
  }, [isDiscovering, DISCOVERY_MESSAGES.length]);

  // 1. START PRIORITY SUPPLIERS - start immediately (light jitter handled server-side)
  // Skip if we have restored state (user navigated back)
  useEffect(() => {
    // Skip initialization if we restored from saved state
    if (hasRestoredState) {
      console.log('📦 Restored email scan state - skipping initialization');
      return;
    }

    if (!isGmailConnected) {
      return;
    }
    
    let amazonRetryTimeout: ReturnType<typeof setTimeout> | null = null;
    
    // Start Amazon with retry logic
    const startAmazon = async (retryCount = 0) => {
      try {
        console.log(`🛒 Starting Amazon processing${retryCount > 0 ? ` (retry ${retryCount})` : ''}...`);
        const response = await jobsApi.startAmazon();
        setAmazonJobId(response.jobId);
        setAmazonError(null);
      } catch (error: unknown) {
        const errorMessage = getErrorMessage(error, 'Failed to start Amazon processing');
        console.error('Amazon processing error:', errorMessage);
        
        // Retry on rate limit or temporary errors (up to 3 times)
        if (retryCount < 3 && (errorMessage.includes('rate') || errorMessage.includes('429') || errorMessage.includes('Too many'))) {
          const retryDelay = (retryCount + 1) * 3000; // 3s, 6s, 9s
          console.log(`⏳ Rate limited, retrying Amazon in ${retryDelay / 1000}s...`);
          amazonRetryTimeout = setTimeout(() => startAmazon(retryCount + 1), retryDelay);
        } else {
          setAmazonError(errorMessage);
        }
      }
    };
    
    // Start McMaster-Carr and Uline
    const startPrioritySuppliers = async (retryCount = 0) => {
      try {
        console.log(`🏭 Starting McMaster-Carr & Uline${retryCount > 0 ? ` (retry ${retryCount})` : ''}...`);
        const response = await jobsApi.startJob(PRIORITY_SUPPLIER_SCAN_DOMAINS, 'priority');
        setPriorityJobId(response.jobId);
        setPriorityError(null);
      } catch (error: unknown) {
        const errorMessage = getErrorMessage(error, 'Failed to start McMaster-Carr & Uline');
        console.error('Priority suppliers error:', errorMessage);
        
        // Retry on rate limit (up to 3 times)
        if (retryCount < 3 && (errorMessage.includes('rate') || errorMessage.includes('429') || errorMessage.includes('Too many'))) {
          const retryDelay = (retryCount + 1) * 4000; // 4s, 8s, 12s
          console.log(`⏳ Rate limited, retrying priority suppliers in ${retryDelay / 1000}s...`);
          setTimeout(() => startPrioritySuppliers(retryCount + 1), retryDelay);
        } else {
          setPriorityError(errorMessage);
        }
      }
    };
    
    // Start Amazon immediately
    startAmazon();
    
    // Start priority suppliers immediately (server manages rate limiting)
    startPrioritySuppliers();
    
    // Cleanup on unmount
    return () => {
      if (amazonRetryTimeout) clearTimeout(amazonRetryTimeout);
    };
  }, [hasRestoredState, isGmailConnected]);

  // Discover suppliers - memoized to allow proper dependency tracking
  // Uses module-level caching to handle StrictMode remounts
  const handleDiscoverSuppliers = useCallback(async () => {
    if (!isGmailConnected) {
      setDiscoverError(GMAIL_REQUIRED_MESSAGE);
      setHasDiscovered(true);
      return;
    }
    // Check if we already have cached results (from previous mount in StrictMode)
    if (moduleDiscoveryResult) {
      setDiscoveredSuppliers(moduleDiscoveryResult);
      setHasDiscovered(true);
      return;
    }
    
    setIsDiscovering(true);
    setDiscoverError(null);
    
    try {
      // Reuse in-flight promise if one exists (prevents duplicate API calls)
      if (!moduleDiscoveryPromise) {
        moduleDiscoveryPromise = discoverApi.discoverSuppliers();
      }
      
      const result = await moduleDiscoveryPromise;
      // Filter out Amazon since we handle it separately
      const nonAmazonSuppliers = result.suppliers.filter((s: DiscoveredSupplier) => !s.domain.includes('amazon'));
      
      // Cache the result for potential StrictMode remount
      moduleDiscoveryResult = nonAmazonSuppliers;
      
      setDiscoveredSuppliers(nonAmazonSuppliers);
      setHasDiscovered(true);
    } catch (err: unknown) {
      console.error('Discovery error:', err);
      const message = getErrorMessage(err, 'Failed to discover suppliers');
      setDiscoverError(message);
      // Still mark as discovered so the grid shows (with priority suppliers at minimum)
      setHasDiscovered(true);
      // Clear the failed promise so next attempt can retry
      moduleDiscoveryPromise = null;
    } finally {
      setIsDiscovering(false);
    }
  }, [getErrorMessage, isGmailConnected]);

  // 2. START SUPPLIER DISCOVERY (start immediately for faster supplier identification)
  // Uses ref to prevent infinite loop and module-level caching for StrictMode
  useEffect(() => {
    if (!isGmailConnected) return;
    if (!hasDiscovered && !isDiscovering && !hasInitiatedDiscovery.current) {
      hasInitiatedDiscovery.current = true;
      handleDiscoverSuppliers();
    }
  }, [hasDiscovered, isDiscovering, handleDiscoverSuppliers, isGmailConnected]);

  useEffect(() => {
    if (!isGmailConnected) return;
    if (discoverError === GMAIL_REQUIRED_MESSAGE) {
      setDiscoverError(null);
      setHasDiscovered(false);
      hasInitiatedDiscovery.current = false;
    }
  }, [discoverError, isGmailConnected]);

  // Poll Amazon job status with adaptive backoff
  const pollAmazonStatus = useCallback(async () => {
    if (!amazonJobId) return;
    
    try {
      const status = await jobsApi.getStatus(amazonJobId);
      console.log(`🛒 Amazon poll: ${status.progress?.processed}/${status.progress?.total}, status=${status.status}`);
      setAmazonStatus(status);
      
      if (status.orders && status.orders.length > 0) {
        const convertedOrders: ExtractedOrder[] = status.orders.map(o => ({
          id: o.id,
          originalEmailId: o.id,
          supplier: o.supplier,
          orderDate: o.orderDate,
          totalAmount: o.totalAmount,
          items: o.items,
          confidence: o.confidence,
        }));
        setAmazonOrders(convertedOrders);
      }
      
      if (status.status === 'completed' || status.status === 'failed') {
        setIsAmazonComplete(true);
        amazonPollAbortRef.current.cancelled = true;
      }
    } catch (error) {
      console.error('Amazon polling error:', error);
    }
  }, [amazonJobId]);

  useEffect(() => {
    if (amazonJobId && !isAmazonComplete) {
      amazonPollAbortRef.current.cancelled = false;
      const pollWithBackoff = async (delayMs: number) => {
        if (amazonPollAbortRef.current.cancelled) return;
        await pollAmazonStatus();
        if (!amazonPollAbortRef.current.cancelled) {
          const nextDelay = Math.min(Math.floor(delayMs * 1.35), 1800);
          setTimeout(() => pollWithBackoff(nextDelay), nextDelay);
        }
      };
      pollWithBackoff(700);
      return () => {
        amazonPollAbortRef.current.cancelled = true;
      };
    }
  }, [amazonJobId, isAmazonComplete, pollAmazonStatus]);

  // Poll Priority Suppliers (McMaster-Carr, Uline) job status with adaptive backoff
  const pollPriorityStatus = useCallback(async () => {
    if (!priorityJobId) return;
    
    try {
      const status = await jobsApi.getStatus(priorityJobId);
      setPriorityStatus(status);
      
      if (Array.isArray(status.orders)) {
        const convertedOrders: ExtractedOrder[] = status.orders.map(o => ({
          id: o.id,
          originalEmailId: o.id,
          supplier: o.supplier,
          orderDate: o.orderDate,
          totalAmount: o.totalAmount,
          items: o.items,
          confidence: o.confidence,
        }));
        setPriorityOrders(convertedOrders);
      }
      
      if (status.status === 'failed') {
        setPriorityError(status.error || 'Failed to process McMaster-Carr & Uline emails');
        setIsPriorityComplete(true);
        priorityPollAbortRef.current.cancelled = true;
      } else if (status.status === 'completed') {
        setIsPriorityComplete(true);
        priorityPollAbortRef.current.cancelled = true;
      }
    } catch (error) {
      console.error('Priority polling error:', error);
    }
  }, [priorityJobId]);

  useEffect(() => {
    if (priorityJobId && !isPriorityComplete) {
      priorityPollAbortRef.current.cancelled = false;
      const pollWithBackoff = async (delayMs: number) => {
        if (priorityPollAbortRef.current.cancelled) return;
        await pollPriorityStatus();
        if (!priorityPollAbortRef.current.cancelled) {
          const nextDelay = Math.min(Math.floor(delayMs * 1.35), 1800);
          setTimeout(() => pollWithBackoff(nextDelay), nextDelay);
        }
      };
      pollWithBackoff(700);
      return () => {
        priorityPollAbortRef.current.cancelled = true;
      };
    }
  }, [priorityJobId, isPriorityComplete, pollPriorityStatus]);

  // Notify parent when user can leave email step.
  // If additional suppliers exist, require explicit import start before proceeding.
  useEffect(() => {
    const canProceed = hasDiscovered && (!hasSelectableOtherSuppliers || hasStartedOtherImport);

    onCanProceed?.(canProceed);
  }, [
    hasSelectableOtherSuppliers,
    hasDiscovered,
    hasStartedOtherImport,
    onCanProceed,
  ]);

  // Preserve state for parent (so navigation back doesn't lose progress)
  useEffect(() => {
    onStateChange?.({
      amazonOrders,
      priorityOrders,
      otherOrders,
      isAmazonComplete,
      isPriorityComplete,
      discoveredSuppliers,
      hasDiscovered,
      hasStartedOtherImport,
      selectedOtherSuppliers,
    });
  }, [
    amazonOrders,
    priorityOrders,
    otherOrders,
    isAmazonComplete,
    isPriorityComplete,
    discoveredSuppliers,
    hasDiscovered,
    hasStartedOtherImport,
    selectedOtherSuppliers,
    onStateChange,
  ]);


  // Poll job status for other suppliers with adaptive backoff
  const pollJobStatus = useCallback(async () => {
    if (!currentJobId) return;
    
    try {
      const status = await jobsApi.getStatus(currentJobId);
      setJobStatus(status);
      
      if (status.orders && status.orders.length > 0) {
        const convertedOrders: ExtractedOrder[] = status.orders.map(o => ({
          id: o.id,
          originalEmailId: o.id,
          supplier: o.supplier,
          orderDate: o.orderDate,
          totalAmount: o.totalAmount,
          items: o.items,
          confidence: o.confidence,
        }));
        setOtherOrders(convertedOrders);
      }
      
      if (status.status === 'completed' || status.status === 'failed') {
        setIsScanning(false);
        otherPollAbortRef.current.cancelled = true;
      }
    } catch (error) {
      console.error('Job polling error:', error);
    }
  }, [currentJobId]);

  useEffect(() => {
    if (currentJobId && isScanning) {
      otherPollAbortRef.current.cancelled = false;
      const pollWithBackoff = async (delayMs: number) => {
        if (otherPollAbortRef.current.cancelled) return;
        await pollJobStatus();
        if (!otherPollAbortRef.current.cancelled) {
          const nextDelay = Math.min(Math.floor(delayMs * 1.35), 2000);
          setTimeout(() => pollWithBackoff(nextDelay), nextDelay);
        }
      };
      pollWithBackoff(650);
      return () => {
        otherPollAbortRef.current.cancelled = true;
      };
    }
  }, [currentJobId, isScanning, pollJobStatus]);

  // Mark that other import was initiated if we resumed an in-flight job or already have data
  useEffect(() => {
    if (!hasStartedOtherImport && (currentJobId || otherOrders.length > 0)) {
      setHasStartedOtherImport(true);
    }
  }, [currentJobId, otherOrders.length, hasStartedOtherImport]);

  // Scan selected suppliers
  const handleScanSuppliers = useCallback(async () => {
    if (isScanning || currentJobId || hasStartedOtherImport) {
      return;
    }

    if (!isGmailConnected) {
      setOtherScanError(GMAIL_REQUIRED_MESSAGE);
      return;
    }

    // Filter to only non-Amazon, non-priority enabled suppliers
    const domainsToScan = Array.from(
      new Set(Array.from(enabledSuppliers).map((domain) => canonicalizePrioritySupplierDomain(domain))),
    ).filter((domain) => !domain.includes('amazon') && !isPrioritySupplierDomain(domain));
    
    if (domainsToScan.length === 0) {
      return; // Nothing additional to scan
    }

    if (!hasShownContinueAnytimePopup) {
      setShowContinueAnytimePopup(true);
      setHasShownContinueAnytimePopup(true);
    }
    
    setIsScanning(true);
    setJobStatus(null);
    setOtherScanError(null);
    
    try {
      const response = await jobsApi.startJob(domainsToScan, 'other');
      setCurrentJobId(response.jobId);
      setHasStartedOtherImport(true);
    } catch (error) {
      console.error('Scan error:', error);
      setOtherScanError(getErrorMessage(error, 'Failed to start selected supplier import.'));
      setIsScanning(false);
    }
  }, [
    enabledSuppliers,
    getErrorMessage,
    hasShownContinueAnytimePopup,
    hasStartedOtherImport,
    currentJobId,
    isScanning,
    isGmailConnected,
  ]);

  const handleToggleSupplier = useCallback((domain: string) => {
    const normalizedDomain = canonicalizePrioritySupplierDomain(domain);
    setEnabledSuppliers(prev => {
      const next = new Set(prev);
      if (next.has(normalizedDomain)) {
        next.delete(normalizedDomain);
      } else {
        next.add(normalizedDomain);
      }
      return next;
    });
    setOtherScanError(null);
  }, []);

  // Keep parent updated with collected orders as they come in
  useEffect(() => {
    if (combinedOrders.length > 0) {
      onScanComplete(combinedOrders);
    }
  }, [combinedOrders, onScanComplete]);

  const supplierCount = selectableOtherSuppliers.length;
  const isPriorityProcessing = useMemo(
    () => Boolean(!isPriorityComplete && priorityJobId),
    [isPriorityComplete, priorityJobId],
  );
  const isAnyProcessing = useMemo(
    () => Boolean((!isAmazonComplete && amazonJobId) || isPriorityProcessing || isScanning),
    [isAmazonComplete, amazonJobId, isPriorityProcessing, isScanning],
  );
  // Report progress to parent component for background display
  useEffect(() => {
    if (!onProgressUpdate) return;
    
    // Determine active scanning progress
    if (isScanning && jobStatus?.progress) {
      onProgressUpdate({
        isActive: true,
        supplier: 'Other Suppliers',
        processed: jobStatus.progress.processed || 0,
        total: jobStatus.progress.total || 0,
        currentTask: jobStatus.progress.currentTask,
      });
    } else if (isPriorityProcessing && priorityStatus?.progress) {
      onProgressUpdate({
        isActive: true,
        supplier: 'McMaster-Carr & Uline',
        processed: priorityStatus.progress.processed || 0,
        total: priorityStatus.progress.total || 0,
        currentTask: priorityStatus.progress.currentTask,
      });
    } else if (!isAmazonComplete && amazonStatus?.progress) {
      onProgressUpdate({
        isActive: true,
        supplier: 'Amazon',
        processed: amazonStatus.progress.processed || 0,
        total: amazonStatus.progress.total || 0,
        currentTask: amazonStatus.progress.currentTask,
      });
    } else if (!isAnyProcessing) {
      onProgressUpdate(null);
    }
  }, [
    onProgressUpdate, 
    isScanning, 
    jobStatus, 
    isPriorityProcessing, 
    priorityStatus, 
    isAmazonComplete, 
    amazonStatus, 
    isAnyProcessing
  ]);

  const milestoneMessage = useMemo(
    () => (celebratingMilestone ? getMilestoneMessage(celebratingMilestone) : null),
    [celebratingMilestone],
  );
  
  // Priority suppliers progress
  const priorityProgress = priorityStatus?.progress;
  const priorityProgressPercent = useMemo(
    () => calculateProgressPercent(priorityProgress),
    [priorityProgress],
  );
  const priorityOrderCount = priorityOrders.length;
  const priorityItemCount = useMemo(
    () => priorityOrders.reduce((sum, order) => sum + order.items.length, 0),
    [priorityOrders],
  );
  const priorityProcessedEmails = priorityProgress?.processed ?? 0;
  const priorityTotalEmails = priorityProgress?.total ?? 0;
  const prioritySummaryText = getPrioritySummaryText({
    error: priorityError,
    isComplete: isPriorityComplete,
    processedEmails: priorityProcessedEmails,
    totalEmails: priorityTotalEmails,
    orderCount: priorityOrderCount,
    itemCount: priorityItemCount,
  });

  // Amazon progress
  const amazonProgress = amazonStatus?.progress;
  const amazonProgressPercent = useMemo(
    () => calculateProgressPercent(amazonProgress),
    [amazonProgress],
  );

  const supplierGridItems = useMemo(
    () => buildSupplierGridItems(selectableOtherSuppliers, enabledSuppliers),
    [selectableOtherSuppliers, enabledSuppliers],
  );

  return (
    <div className={embedded ? 'max-w-5xl mx-auto pb-32 space-y-5 relative' : 'max-w-5xl mx-auto p-6 pb-32 space-y-5 relative'}>
      
      {/* Milestone Celebration Overlay */}
      {milestoneMessage && (
        <div className="fixed inset-0 z-50 flex items-center justify-center pointer-events-none">
          <div className="bg-white rounded-2xl shadow-2xl p-8 text-center animate-bounce-in border-4 border-arda-accent">
            <div className="text-6xl mb-4">{milestoneMessage.emoji}</div>
            <h2 className="text-2xl font-bold text-arda-text-primary mb-2">
              {milestoneMessage.title}
            </h2>
            <p className="text-arda-text-secondary">
              {milestoneMessage.subtitle}
            </p>
          </div>
          {/* Confetti effect */}
          <div className="absolute inset-0 overflow-hidden">
            {[...Array(20)].map((_, i) => (
              <div
                key={i}
                className="absolute animate-confetti"
                style={{
                  left: `${Math.random() * 100}%`,
                  animationDelay: `${Math.random() * 0.5}s`,
                  backgroundColor: ['#10B981', '#3B82F6', '#F59E0B', '#EF4444', '#8B5CF6'][i % 5],
                  width: '10px',
                  height: '10px',
                  borderRadius: '2px',
                }}
              />
            ))}
          </div>
        </div>
      )}

      {/* Welcome Header - Animated intro */}
      {showWelcome && (
        <div className="text-center py-8 animate-fade-in">
          <div className="inline-flex items-center gap-2 bg-arda-accent/10 text-arda-accent px-4 py-2 rounded-full text-sm font-medium mb-4">
            <Icons.Sparkles className="w-4 h-4" />
            Email sync started
          </div>
          <h1 className="text-3xl font-bold text-arda-text-primary mb-3">
            We’re scanning your inbox
          </h1>
          <p className="text-arda-text-secondary max-w-lg mx-auto">
            We’re finding orders, tracking spend, and identifying replenishment patterns.
            This usually takes about 30 seconds.
          </p>
        </div>
      )}

      {/* Live Stats Bar - The "wow" moment */}
      {(allItems.length > 0 || totalOrders > 0) && (
        <div className={`bg-gradient-to-r from-arda-accent to-blue-600 rounded-2xl p-6 text-white shadow-lg ${isGmailConnected ? '' : 'opacity-60'}`}>
          <div className="grid grid-cols-4 gap-6 text-center">
            <div>
              <div className="text-4xl font-bold">{allItems.length}</div>
              <div className="text-white/80 text-sm">Items Found</div>
            </div>
            <div>
              <div className="text-4xl font-bold">{totalOrders}</div>
              <div className="text-white/80 text-sm">Orders</div>
            </div>
            <div>
              <div className="text-4xl font-bold">{uniqueSuppliers}</div>
              <div className="text-white/80 text-sm">Suppliers</div>
            </div>
            <div>
              <div className="text-4xl font-bold">
                ${totalSpend >= 1000 ? `${(totalSpend / 1000).toFixed(1)}k` : totalSpend.toFixed(0)}
              </div>
              <div className="text-white/80 text-sm">Tracked</div>
            </div>
          </div>
          
          {/* Value teaser */}
          {allItems.length >= 5 && (
            <div className="mt-4 pt-4 border-t border-white/20 text-center">
              <p className="text-white/90 text-sm">
                💡 <span className="font-medium">Insight preview:</span> We're already seeing patterns in your ordering. 
                Set up Kanban cards to automate replenishment.
              </p>
            </div>
          )}
        </div>
      )}

      {/* Header when not showing welcome */}
      {!showWelcome && (
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold text-arda-text-primary">Importing Your Orders</h1>
            <p className="text-arda-text-secondary mt-1">
              {isAnyProcessing 
                ? 'Discovering items from your suppliers...'
                : 'Ready to set up your inventory'}
            </p>
          </div>
        </div>
      )}

      {!isGmailConnected && (
        <div className="border border-arda-border rounded-2xl p-6 bg-arda-bg-secondary">
          <div className="flex items-start gap-4">
            <div className="w-12 h-12 rounded-xl bg-orange-500 text-white flex items-center justify-center">
              <Icons.Mail className="w-6 h-6" />
            </div>
            <div className="flex-1">
              <h3 className="text-lg font-semibold text-arda-text-primary">Connect Gmail to continue</h3>
              <p className="text-sm text-arda-text-secondary mt-1">
                {gmailStatusError || 'Link Gmail to scan your inbox for purchase orders and receipts.'}
              </p>
              <button
                type="button"
                onClick={() => {
                  window.location.href = `${API_BASE_URL}/auth/google?returnTo=email`;
                }}
                className="mt-4 inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-arda-accent text-white font-semibold hover:bg-arda-accent/90 transition-colors"
              >
                <Icons.Link className="w-4 h-4" />
                Connect Gmail
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Amazon Processing Card - Premium look */}
      <div className={`border-2 rounded-2xl p-6 transition-all ${
        amazonError
          ? 'bg-red-50 border-red-200'
          : isAmazonComplete 
            ? amazonOrders.length > 0
              ? 'bg-green-50 border-green-300 shadow-md' 
              : 'bg-gray-50 border-gray-200'
            : 'bg-orange-50 border-orange-200 shadow-sm'
      }`}>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-4">
            <div className={`w-12 h-12 rounded-xl flex items-center justify-center ${
              isAmazonComplete ? 'bg-green-500' : 'bg-orange-500'
            }`}>
              {amazonError ? (
                <Icons.AlertCircle className="w-6 h-6 text-white" />
              ) : !isAmazonComplete ? (
                <Icons.Loader2 className="w-6 h-6 text-white animate-spin" />
              ) : (
                <Icons.CheckCircle2 className="w-6 h-6 text-white" />
              )}
            </div>
            <div>
              <h3 className="text-xl font-bold text-arda-text-primary">Amazon</h3>
              <p className={`text-sm ${amazonError ? 'text-red-600' : 'text-arda-text-secondary'}`}>
                {amazonError 
                  ? amazonError
                  : !isAmazonComplete 
                    ? 'Extracting products from your orders...'
                    : amazonOrders.length > 0 
                      ? `${amazonOrders.reduce((sum, o) => sum + o.items.length, 0)} items from ${amazonOrders.length} orders`
                      : 'No Amazon orders found'
                }
              </p>
            </div>
          </div>
          
          {amazonProgress && !isAmazonComplete && !amazonError && (
            <div className="text-right">
              <div className="text-2xl font-bold text-orange-600">
                {Math.round(amazonProgressPercent)}%
              </div>
              <div className="text-xs text-arda-text-muted">
                {amazonProgress.processed} / {amazonProgress.total} emails
              </div>
            </div>
          )}
        </div>

        {/* Amazon Progress Bar */}
        {!isAmazonComplete && amazonProgress && !amazonError && (
          <div className="mb-4">
            <div className="h-3 bg-orange-100 rounded-full overflow-hidden">
              <div 
                className="h-full bg-gradient-to-r from-orange-500 to-orange-400 transition-all duration-300 rounded-full"
                style={{ width: `${amazonProgressPercent}%` }}
              />
            </div>
          </div>
        )}

        {/* Amazon Items Grid - Show all items beautifully */}
        {amazonOrders.length > 0 && (
          <div className="max-h-64 overflow-y-auto">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
              {amazonOrders.flatMap((order, orderIdx) => 
                order.items.map((item, itemIdx) => (
                  <div 
                    key={`${orderIdx}-${itemIdx}`} 
                    className="bg-white border border-gray-200 rounded-xl p-3 flex items-center gap-3 hover:shadow-md transition-shadow"
                  >
                    {item.amazonEnriched?.imageUrl ? (
                      <img 
                        src={item.amazonEnriched.imageUrl} 
                        alt="" 
                        className="w-14 h-14 object-contain flex-shrink-0 rounded-lg bg-gray-50"
                      />
                    ) : (
                      <div className="w-14 h-14 bg-orange-50 rounded-lg flex items-center justify-center flex-shrink-0">
                        <Icons.Package className="w-7 h-7 text-orange-400" />
                      </div>
                    )}
                    <div className="min-w-0 flex-1">
                      <div className="text-sm font-medium text-arda-text-primary line-clamp-2">
                        {item.amazonEnriched?.itemName || item.name}
                      </div>
                      <div className="flex items-center gap-2 mt-1">
                        {(item.unitPrice ?? 0) > 0 && (
                          <span className="text-sm text-green-600 font-bold">
                            ${(item.unitPrice ?? 0).toFixed(2)}
                          </span>
                        )}
                        <span className="text-xs text-arda-text-muted">
                          {order.orderDate}
                        </span>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>
        )}
      </div>

      {/* McMaster-Carr & Uline Card */}
      <div className={`border-2 rounded-2xl p-6 transition-all ${
        priorityError
          ? 'bg-red-50 border-red-200'
          : isPriorityComplete 
            ? 'bg-green-50 border-green-300 shadow-md'
            : 'bg-blue-50 border-blue-200 shadow-sm'
      }`}>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-4">
            <div className={`w-12 h-12 rounded-xl flex items-center justify-center ${
              isPriorityComplete ? 'bg-green-500' : 'bg-blue-500'
            }`}>
              {priorityError ? (
                <Icons.AlertCircle className="w-6 h-6 text-white" />
              ) : !isPriorityComplete ? (
                <Icons.Loader2 className="w-6 h-6 text-white animate-spin" />
              ) : (
                <Icons.CheckCircle2 className="w-6 h-6 text-white" />
              )}
            </div>
            <div>
              <h3 className="text-xl font-bold text-arda-text-primary">Industrial Suppliers</h3>
              <p className={`text-sm ${priorityError ? 'text-red-600' : 'text-arda-text-secondary'}`}>
                {prioritySummaryText}
              </p>
            </div>
          </div>
          
          {priorityProgress && !isPriorityComplete && !priorityError && (
            <div className="text-right">
              <div className="text-2xl font-bold text-blue-600">
                {Math.round(priorityProgressPercent)}%
              </div>
              <div className="text-xs text-arda-text-muted">
                {priorityProgress.processed} / {priorityProgress.total} emails
              </div>
            </div>
          )}
        </div>

        {/* Progress Bar */}
        {!isPriorityComplete && priorityProgress && !priorityError && (
          <div className="mb-4">
            <div className="h-3 bg-blue-100 rounded-full overflow-hidden">
              <div 
                className="h-full bg-gradient-to-r from-blue-500 to-blue-400 transition-all duration-300 rounded-full"
                style={{ width: `${priorityProgressPercent}%` }}
              />
            </div>
          </div>
        )}

        {/* Priority Items List */}
        {priorityOrders.length > 0 && (
          <div className="max-h-48 overflow-y-auto">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              {priorityOrders.flatMap((order, orderIdx) => 
                order.items.map((item, itemIdx) => (
                  <div 
                    key={`${orderIdx}-${itemIdx}`} 
                    className="bg-white border border-gray-200 rounded-xl p-3 flex items-center gap-3"
                  >
                    <div className="w-10 h-10 bg-blue-50 rounded-lg flex items-center justify-center flex-shrink-0">
                      <Icons.Package className="w-5 h-5 text-blue-500" />
                    </div>
                    <div className="min-w-0 flex-1">
                      <div className="text-sm font-medium text-arda-text-primary line-clamp-1">
                        {item.name}
                      </div>
                      <div className="flex items-center gap-2 mt-0.5">
                        {(item.unitPrice ?? 0) > 0 && (
                          <span className="text-sm text-blue-600 font-bold">
                            ${(item.unitPrice ?? 0).toFixed(2)}
                          </span>
                        )}
                        {item.quantity > 1 && (
                          <span className="text-xs text-arda-text-muted bg-gray-100 px-1.5 py-0.5 rounded">
                            x{item.quantity}
                          </span>
                        )}
                        <span className="text-xs text-arda-text-muted">
                          {order.supplier}
                        </span>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>
        )}
      </div>

      {/* Lean Wisdom - Always visible */}
      <div>
        <div className="bg-gradient-to-r from-amber-50 to-orange-50 border border-amber-200 rounded-xl p-5">
          <div className="flex items-start gap-4">
            <div className="flex-shrink-0 w-10 h-10 bg-amber-100 rounded-full flex items-center justify-center">
              <Icons.Lightbulb className="w-5 h-5 text-amber-600" />
            </div>
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium text-amber-900 mb-1">
                {isAnyProcessing ? 'While you wait, a word about batching...' : 'A word about batching...'}
              </p>
              <blockquote className="text-amber-800 italic text-sm leading-relaxed">
                "{LEAN_WISDOM[wisdomIndex].quote}"
              </blockquote>
              <p className="text-xs text-amber-600 mt-2 font-medium">
                {LEAN_WISDOM[wisdomIndex].attribution}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Additional Suppliers Section */}
      <div className="border-2 border-gray-200 rounded-2xl p-6">
        <div className="flex items-center justify-between mb-4">
          <div>
            <h3 className="text-xl font-bold text-arda-text-primary">Other Suppliers</h3>
            <p className="text-sm text-arda-text-secondary">
              {isDiscovering 
                ? 'Discovering...' 
                : hasStartedOtherImport
                  ? 'Import started. Continue when ready.'
                  : `${supplierCount} additional suppliers found`}
            </p>
          </div>
          
          {hasDiscovered && !isScanning && hasSelectableOtherSuppliers && (
            <button
              onClick={handleScanSuppliers}
              disabled={selectedOtherCount === 0 || hasStartedOtherImport}
              className={[
                "px-5 py-2.5 rounded-xl font-medium transition-all flex items-center gap-2",
                selectedOtherCount > 0 && !hasStartedOtherImport
                  ? "bg-arda-accent hover:bg-arda-accent-hover text-white"
                  : "bg-arda-border text-arda-text-muted cursor-not-allowed"
              ].join(" ")}
            >
              <Icons.Download className="w-4 h-4" />
              {hasStartedOtherImport
                ? 'Import started'
                : selectedOtherCount > 0
                ? `Import ${selectedOtherCount} Supplier${selectedOtherCount === 1 ? '' : 's'}`
                : 'Select suppliers to import'}
            </button>
          )}
        </div>

        {otherScanError && !isScanning && (
          <div className="mb-4 bg-red-50 border border-red-200 rounded-xl p-4">
            <div className="flex items-center gap-3">
              <Icons.AlertCircle className="w-5 h-5 text-red-500 flex-shrink-0" />
              <div>
                <span className="font-medium text-red-700">
                  {otherScanError}
                </span>
                <p className="text-sm text-red-600 mt-1">
                  Continue stays disabled until supplier import starts. Select suppliers and try again.
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Scanning Progress */}
        {isScanning && jobStatus && (
          <div className="mb-4 bg-blue-50 border border-blue-200 rounded-xl p-4">
            <div className="flex items-center gap-3 mb-2">
              <Icons.Loader2 className="w-5 h-5 text-blue-500 animate-spin" />
              <span className="font-medium text-blue-700">
                {jobStatus.progress?.currentTask || 'Processing...'}
              </span>
            </div>
            <div className="h-2 bg-blue-100 rounded-full overflow-hidden">
              <div 
                className="h-full bg-blue-500 transition-all duration-300"
                style={{ 
                  width: `${(jobStatus.progress?.processed || 0) / Math.max(jobStatus.progress?.total || 1, 1) * 100}%` 
                }}
              />
            </div>
            
            {/* Other Orders Items */}
            {otherOrders.length > 0 && (
              <div className="mt-4 max-h-32 overflow-y-auto">
                <div className="grid grid-cols-2 gap-2">
                  {otherOrders.flatMap((order, orderIdx) => 
                    order.items.slice(0, 4).map((item, itemIdx) => (
                      <div 
                        key={`${orderIdx}-${itemIdx}`} 
                        className="bg-white rounded-lg px-3 py-2 text-sm flex items-center gap-2"
                      >
                        <Icons.Package className="w-4 h-4 text-green-500 flex-shrink-0" />
                        <span className="truncate text-arda-text-primary">{item.name}</span>
                      </div>
                    ))
                  )}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Discovery Error Message */}
        {discoverError && !isDiscovering && (
          <div className="mb-4 bg-amber-50 border border-amber-200 rounded-xl p-4">
            <div className="flex items-center gap-3">
              <Icons.AlertCircle className="w-5 h-5 text-amber-500 flex-shrink-0" />
              <div>
                <span className="font-medium text-amber-700">
                  {discoverError === SESSION_EXPIRED_MESSAGE ? SESSION_EXPIRED_MESSAGE : 'Could not fully discover suppliers'}
                </span>
                <p className="text-sm text-amber-600 mt-1">
                  {discoverError === SESSION_EXPIRED_MESSAGE
                    ? 'Please sign in again to continue importing suppliers.'
                    : 'Showing available suppliers. You can still select and import from the list below.'}
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Supplier Grid */}
        {!isScanning && hasDiscovered && supplierCount > 0 && (
          <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-3">
            {supplierGridItems.map(({ supplier, colors, isEnabled }) => (
              <div
                key={supplier.domain}
                onClick={() => handleToggleSupplier(supplier.domain)}
                className={`
                  relative aspect-square p-3 rounded-xl border-2 cursor-pointer transition-all
                  flex flex-col items-center justify-center text-center
                  ${isEnabled 
                    ? 'bg-white border-arda-accent shadow-md scale-105' 
                    : 'bg-gray-50 border-gray-200 hover:border-gray-300 opacity-60 hover:opacity-100'
                  }
                `}
              >
                {isEnabled && (
                  <div className="absolute top-2 right-2">
                    <Icons.CheckCircle2 className="w-5 h-5 text-arda-accent" />
                  </div>
                )}
                <div className="text-2xl mb-1">{colors.icon}</div>
                <div className="text-sm font-medium text-arda-text-primary truncate w-full">
                  {supplier.displayName}
                </div>
                {supplier.emailCount > 0 && (
                  <div className="text-xs text-arda-text-muted">
                    {supplier.emailCount} emails
                  </div>
                )}
              </div>
            ))}
          </div>
        )}

        {/* Discovering state - Enhanced feedback */}
        {isDiscovering && (
          <div className="py-6 space-y-6">
            {/* Animated progress message */}
            <div className="flex items-center justify-center gap-3">
              <div className="relative">
                <Icons.Loader2 className="w-6 h-6 text-blue-500 animate-spin" />
                <div className="absolute inset-0 animate-ping opacity-30">
                  <Icons.Loader2 className="w-6 h-6 text-blue-500" />
                </div>
              </div>
              <span className="text-arda-text-secondary font-medium transition-opacity duration-300">
                {DISCOVERY_MESSAGES[discoveryMessageIndex]}
              </span>
            </div>
            
            {/* Scanning animation - shows activity */}
            <div className="bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-100 rounded-xl p-4">
              <div className="flex items-center gap-2 mb-3">
                <Icons.Search className="w-4 h-4 text-blue-500 animate-pulse" />
                <span className="text-sm font-medium text-blue-700">
                  {DISCOVERY_MESSAGES[discoveryMessageIndex]}
                </span>
              </div>
              
              {/* Animated scanning bars */}
              <div className="space-y-2">
                {[0, 1, 2, 3].map((i) => (
                  <div key={i} className="flex items-center gap-3">
                    <div 
                      className="h-2 rounded-full animate-shimmer"
                      style={{ 
                        width: `${65 + i * 8}%`,
                        animationDelay: `${i * 150}ms`,
                      }}
                    />
                    <div className="w-2 h-2 rounded-full bg-blue-400 animate-pulse" style={{ animationDelay: `${i * 200}ms` }} />
                  </div>
                ))}
              </div>
            </div>
            
            {/* Skeleton placeholder grid for suppliers being discovered */}
            <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-3">
              {[0, 1, 2, 3, 4, 5].map((i) => (
                <div
                  key={i}
                  className="aspect-square p-3 rounded-xl border-2 border-gray-100 bg-gray-50 flex flex-col items-center justify-center animate-pulse"
                  style={{ animationDelay: `${i * 100}ms` }}
                >
                  <div className="w-8 h-8 rounded-lg bg-gray-200 mb-2" />
                  <div className="w-16 h-3 rounded bg-gray-200" />
                </div>
              ))}
            </div>
          </div>
        )}

      </div>

      {/* Insights Preview Card - Tease value */}
      {allItems.length >= 10 && (
        <div className="bg-gradient-to-br from-purple-50 to-blue-50 border-2 border-purple-200 rounded-2xl p-6">
          <div className="flex items-start gap-4">
            <div className="w-12 h-12 bg-purple-500 rounded-xl flex items-center justify-center flex-shrink-0">
              <Icons.BarChart3 className="w-6 h-6 text-white" />
            </div>
            <div className="flex-1">
              <h3 className="text-xl font-bold text-arda-text-primary mb-2">
                Insights Coming Soon...
              </h3>
              <p className="text-arda-text-secondary mb-4">
                Based on your {allItems.length} items, Arda will help you:
              </p>
              <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                <div className="bg-white/70 rounded-lg p-3">
                  <div className="text-lg font-bold text-purple-600">🔄</div>
                  <div className="text-sm font-medium text-arda-text-primary">Auto-Reorder</div>
                  <div className="text-xs text-arda-text-muted">Set up Kanban cards</div>
                </div>
                <div className="bg-white/70 rounded-lg p-3">
                  <div className="text-lg font-bold text-blue-600">📈</div>
                  <div className="text-sm font-medium text-arda-text-primary">Track Velocity</div>
                  <div className="text-xs text-arda-text-muted">See consumption patterns</div>
                </div>
                <div className="bg-white/70 rounded-lg p-3">
                  <div className="text-lg font-bold text-green-600">💰</div>
                  <div className="text-sm font-medium text-arda-text-primary">Optimize Spend</div>
                  <div className="text-xs text-arda-text-muted">Find savings opportunities</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {showContinueAnytimePopup && (
        <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4">
          <div
            role="dialog"
            aria-modal="true"
            aria-labelledby="continue-anytime-title"
            className="bg-white rounded-2xl shadow-xl border border-blue-100 w-full max-w-md p-6"
          >
            <div className="flex items-start justify-between gap-4">
              <div className="flex items-start gap-3">
                <div className="w-9 h-9 rounded-lg bg-blue-100 flex items-center justify-center flex-shrink-0">
                  <Icons.Clock className="w-4 h-4 text-blue-700" />
                </div>
                <div>
                  <h2 id="continue-anytime-title" className="text-base font-semibold text-blue-900">
                    Continue anytime
                  </h2>
                  <p className="text-sm text-blue-800 mt-1">
                    Email import keeps running in the background after you move to the next step. We’ll keep adding
                    items as scans finish.
                  </p>
                </div>
              </div>
              <button
                type="button"
                aria-label="Close continue anytime popup"
                onClick={() => setShowContinueAnytimePopup(false)}
                className="text-arda-text-muted hover:text-arda-text-primary transition-colors"
              >
                <Icons.X className="w-4 h-4" />
              </button>
            </div>
            <div className="mt-5 flex justify-end">
              <button
                type="button"
                onClick={() => setShowContinueAnytimePopup(false)}
                className="px-4 py-2 rounded-lg bg-arda-accent hover:bg-arda-accent-hover text-white font-medium transition-colors"
              >
                Got it
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Note: Navigation handled by OnboardingFlow footer */}
    </div>
  );
};

```

### `src/views/UrlScrapeStep.tsx`

```tsx
import { useEffect, useMemo, useState } from 'react';
import { Icons } from '../components/Icons';
import { urlIngestionApi, UrlScrapeResult, UrlScrapedItem } from '../services/api';

interface UrlScrapeStepProps {
  importedItems: UrlScrapedItem[];
  onImportItems: (items: UrlScrapedItem[]) => void;
  onDeleteImportedItem?: (sourceUrl: string) => void;
  onReviewStateChange?: (state: UrlReviewState) => void;
}

interface UrlReviewState {
  pendingReviewCount: number;
  unimportedApprovedCount: number;
  totalRows: number;
  canContinue: boolean;
}

interface EditableScrapeRow {
  sourceUrl: string;
  status: UrlScrapeResult['status'];
  message?: string;
  item: UrlScrapedItem;
  approved: boolean;
}

const MAX_URLS = 50;

function parseUrls(raw: string): string[] {
  const tokens = raw
    .split(/[\n,]/g)
    .map(token => token.trim())
    .filter(Boolean);

  return Array.from(new Set(tokens));
}

function isImportedRowSynced(row: EditableScrapeRow, imported?: UrlScrapedItem): boolean {
  if (!imported) return false;
  const item = row.item;
  return (
    (item.itemName ?? '') === (imported.itemName ?? '')
    && (item.supplier ?? '') === (imported.supplier ?? '')
    && (item.vendorSku ?? '') === (imported.vendorSku ?? '')
    && (item.asin ?? '') === (imported.asin ?? '')
    && (item.productUrl ?? '') === (imported.productUrl ?? '')
    && (item.price ?? null) === (imported.price ?? null)
  );
}

export const UrlScrapeStep: React.FC<UrlScrapeStepProps> = ({
  importedItems,
  onImportItems,
  onDeleteImportedItem,
  onReviewStateChange,
}) => {
  const [urlInput, setUrlInput] = useState('');
  const [isScraping, setIsScraping] = useState(false);
  const [rows, setRows] = useState<EditableScrapeRow[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [importMessage, setImportMessage] = useState<string | null>(null);

  const parsedUrls = useMemo(() => parseUrls(urlInput), [urlInput]);
  const overLimit = parsedUrls.length > MAX_URLS;

  const importedBySource = useMemo(
    () => new Map(importedItems.map(item => [item.sourceUrl, item])),
    [importedItems],
  );

  const successCount = rows.filter(result => result.status === 'success').length;
  const partialCount = rows.filter(result => result.status === 'partial').length;
  const failedCount = rows.filter(result => result.status === 'failed').length;
  const approvedCount = rows.filter(row => row.approved).length;
  const pendingCount = rows.length - approvedCount;
  const unimportedApprovedCount = rows.filter(row => (
    row.approved && !isImportedRowSynced(row, importedBySource.get(row.sourceUrl))
  )).length;
  const canContinue = rows.length === 0 || (pendingCount === 0 && unimportedApprovedCount === 0);

  useEffect(() => {
    onReviewStateChange?.({
      pendingReviewCount: pendingCount,
      unimportedApprovedCount,
      totalRows: rows.length,
      canContinue,
    });
  }, [canContinue, onReviewStateChange, pendingCount, rows.length, unimportedApprovedCount]);

  const handleScrape = async () => {
    if (parsedUrls.length === 0 || overLimit || isScraping) {
      return;
    }

    setIsScraping(true);
    setError(null);

    try {
      const response = await urlIngestionApi.scrapeUrls(parsedUrls);
      setRows(previousRows => {
        const merged = new Map<string, EditableScrapeRow>();

        previousRows.forEach(row => {
          merged.set(row.sourceUrl, row);
        });

        response.results.forEach(result => {
          const existing = merged.get(result.sourceUrl);
          merged.set(result.sourceUrl, {
            sourceUrl: result.sourceUrl,
            status: result.status,
            message: result.message,
            item: {
              ...existing?.item,
              ...result.item,
              sourceUrl: result.item.sourceUrl || result.sourceUrl,
              productUrl: result.item.productUrl || result.sourceUrl,
            },
            approved: existing?.approved ?? false,
          });
        });

        return Array.from(merged.values());
      });
      setImportMessage(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to scrape URLs');
    } finally {
      setIsScraping(false);
    }
  };

  const handleImport = () => {
    const approvedRows = rows.filter(row => row.approved);
    if (approvedRows.length === 0) {
      setImportMessage('Approve at least one row before importing.');
      return;
    }

    onImportItems(approvedRows.map(row => row.item));
    setImportMessage(`Imported ${approvedRows.length} approved row${approvedRows.length === 1 ? '' : 's'}.`);
  };

  const handleToggleApproval = (sourceUrl: string, approved: boolean) => {
    setRows(previousRows => previousRows.map(row => (
      row.sourceUrl === sourceUrl ? { ...row, approved } : row
    )));
  };

  const handleDeleteRow = (sourceUrl: string) => {
    setRows(previousRows => previousRows.filter(row => row.sourceUrl !== sourceUrl));
    onDeleteImportedItem?.(sourceUrl);
  };

  const handleFieldChange = (
    sourceUrl: string,
    field: 'itemName' | 'supplier' | 'vendorSku' | 'asin' | 'productUrl',
    value: string,
  ) => {
    setRows(previousRows => previousRows.map(row => {
      if (row.sourceUrl !== sourceUrl) return row;
      return {
        ...row,
        item: {
          ...row.item,
          [field]: value.trim() ? value : undefined,
        },
      };
    }));
  };

  const handlePriceChange = (sourceUrl: string, value: string) => {
    setRows(previousRows => previousRows.map(row => {
      if (row.sourceUrl !== sourceUrl) return row;

      if (!value.trim()) {
        return {
          ...row,
          item: {
            ...row.item,
            price: undefined,
          },
        };
      }

      const parsedPrice = Number(value);
      if (!Number.isFinite(parsedPrice)) {
        return row;
      }

      return {
        ...row,
        item: {
          ...row.item,
          price: parsedPrice,
        },
      };
    }));
  };

  return (
    <div className="space-y-4">
      <div className="bg-white rounded-2xl border border-arda-border p-6 shadow-sm">
        <div className="flex items-start justify-between gap-4">
          <div>
            <h2 className="text-lg font-semibold text-arda-text-primary">Paste Product URLs</h2>
            <p className="text-sm text-arda-text-secondary mt-1">
              Add up to 50 links. Amazon URLs use ASIN enrichment, other URLs use metadata + AI fallback. McMaster-Carr
              sometimes blocks automated requests, so you may get partial details (supplier + SKU) to review. New
              scrapes append to the table below so you can build one running list.
            </p>
          </div>
        </div>

        <textarea
          value={urlInput}
          onChange={(event) => setUrlInput(event.target.value)}
          placeholder="https://www.amazon.com/dp/B08...
https://supplier.com/products/part-123"
          className="mt-4 w-full min-h-[150px] rounded-xl border border-arda-border p-3 text-sm focus:outline-none focus:ring-2 focus:ring-arda-accent/30"
        />

        <div className="mt-3 flex items-center justify-between text-xs">
          <span className={overLimit ? 'text-red-600 font-medium' : 'text-arda-text-muted'}>
            {parsedUrls.length} unique URL{parsedUrls.length === 1 ? '' : 's'}
            {overLimit ? ` (max ${MAX_URLS})` : ''}
          </span>
          <button
            type="button"
            onClick={() => void handleScrape()}
            disabled={parsedUrls.length === 0 || overLimit || isScraping}
            className="btn-arda-primary text-sm py-2 px-4 disabled:opacity-50 inline-flex items-center gap-2"
          >
            {isScraping ? <Icons.Loader2 className="w-4 h-4 animate-spin" /> : <Icons.Search className="w-4 h-4" />}
            Scrape URLs
          </button>
        </div>

        {error && (
          <p className="mt-3 text-sm text-red-600">{error}</p>
        )}
      </div>

      {(rows.length > 0 || importedItems.length > 0) && (
        <div className="bg-white rounded-2xl border border-arda-border p-6 shadow-sm">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-4">
            <div className="flex flex-wrap items-center gap-3 text-sm">
              <span className="font-semibold text-arda-text-primary">Scrape Results</span>
              <span className="text-green-600">{successCount} success</span>
              <span className="text-orange-600">{partialCount} partial</span>
              <span className="text-red-600">{failedCount} failed</span>
              <span className="text-arda-text-secondary">{approvedCount} approved</span>
              <span className="text-arda-text-muted">{pendingCount} pending review</span>
            </div>
            <button
              type="button"
              onClick={handleImport}
              disabled={rows.length === 0}
              className="btn-arda-outline text-sm py-1.5 inline-flex items-center gap-2 disabled:opacity-50"
            >
              <Icons.Download className="w-4 h-4" />
              Import Approved To Master List
            </button>
          </div>

          <div className="max-h-[420px] overflow-auto rounded-xl border border-arda-border">
            <table className="w-full min-w-[1080px] text-xs">
              <thead className="bg-arda-bg-tertiary text-arda-text-secondary sticky top-0">
                <tr>
                  <th className="px-2 py-2 text-left font-medium w-20">Approve</th>
                  <th className="px-2 py-2 text-left font-medium min-w-[220px]">Source URL</th>
                  <th className="px-2 py-2 text-left font-medium min-w-[180px]">Item Name</th>
                  <th className="px-2 py-2 text-left font-medium min-w-[150px]">Supplier</th>
                  <th className="px-2 py-2 text-left font-medium min-w-[130px]">SKU</th>
                  <th className="px-2 py-2 text-left font-medium min-w-[120px]">Price</th>
                  <th className="px-2 py-2 text-left font-medium min-w-[130px]">ASIN</th>
                  <th className="px-2 py-2 text-left font-medium min-w-[220px]">Product URL</th>
                  <th className="px-2 py-2 text-left font-medium w-24">Status</th>
                  <th className="px-2 py-2 text-left font-medium min-w-[180px]">Message</th>
                  <th className="px-2 py-2 text-left font-medium w-20">Action</th>
                </tr>
              </thead>
              <tbody>
                {rows.map(row => {
                  const statusColor = row.status === 'success'
                    ? 'text-green-600 bg-green-50 border-green-100'
                    : row.status === 'partial'
                      ? 'text-orange-600 bg-orange-50 border-orange-100'
                      : 'text-red-600 bg-red-50 border-red-100';

                  return (
                    <tr key={row.sourceUrl} className="border-t border-arda-border align-top">
                      <td className="px-2 py-2">
                        <label className="inline-flex items-center gap-2 text-arda-text-secondary">
                          <input
                            type="checkbox"
                            checked={row.approved}
                            onChange={(event) => handleToggleApproval(row.sourceUrl, event.target.checked)}
                            aria-label={`Approve ${row.sourceUrl}`}
                          />
                          <span>Approve</span>
                        </label>
                      </td>
                      <td className="px-2 py-2">
                        <a
                          href={row.sourceUrl}
                          target="_blank"
                          rel="noreferrer"
                          className="text-arda-accent underline break-all"
                        >
                          {row.sourceUrl}
                        </a>
                      </td>
                      <td className="px-2 py-2">
                        <input
                          value={row.item.itemName ?? ''}
                          onChange={(event) => handleFieldChange(row.sourceUrl, 'itemName', event.target.value)}
                          placeholder="Item name"
                          aria-label={`Item name for ${row.sourceUrl}`}
                          className="w-full rounded-lg border border-arda-border px-2 py-1 text-xs"
                        />
                      </td>
                      <td className="px-2 py-2">
                        <input
                          value={row.item.supplier ?? ''}
                          onChange={(event) => handleFieldChange(row.sourceUrl, 'supplier', event.target.value)}
                          placeholder="Supplier"
                          aria-label={`Supplier for ${row.sourceUrl}`}
                          className="w-full rounded-lg border border-arda-border px-2 py-1 text-xs"
                        />
                      </td>
                      <td className="px-2 py-2">
                        <input
                          value={row.item.vendorSku ?? ''}
                          onChange={(event) => handleFieldChange(row.sourceUrl, 'vendorSku', event.target.value)}
                          placeholder="SKU"
                          aria-label={`SKU for ${row.sourceUrl}`}
                          className="w-full rounded-lg border border-arda-border px-2 py-1 text-xs"
                        />
                      </td>
                      <td className="px-2 py-2">
                        <input
                          type="number"
                          step="0.01"
                          value={row.item.price ?? ''}
                          onChange={(event) => handlePriceChange(row.sourceUrl, event.target.value)}
                          placeholder="0.00"
                          aria-label={`Price for ${row.sourceUrl}`}
                          className="w-full rounded-lg border border-arda-border px-2 py-1 text-xs"
                        />
                      </td>
                      <td className="px-2 py-2">
                        <input
                          value={row.item.asin ?? ''}
                          onChange={(event) => handleFieldChange(row.sourceUrl, 'asin', event.target.value)}
                          placeholder="ASIN"
                          aria-label={`ASIN for ${row.sourceUrl}`}
                          className="w-full rounded-lg border border-arda-border px-2 py-1 text-xs"
                        />
                      </td>
                      <td className="px-2 py-2">
                        <input
                          value={row.item.productUrl ?? ''}
                          onChange={(event) => handleFieldChange(row.sourceUrl, 'productUrl', event.target.value)}
                          placeholder="Product URL"
                          aria-label={`Product URL for ${row.sourceUrl}`}
                          className="w-full rounded-lg border border-arda-border px-2 py-1 text-xs"
                        />
                      </td>
                      <td className="px-2 py-2">
                        <span className={`text-[11px] px-2 py-0.5 rounded-full border ${statusColor}`}>
                          {row.status}
                        </span>
                      </td>
                      <td className="px-2 py-2 text-arda-text-muted">
                        {row.message || '—'}
                      </td>
                      <td className="px-2 py-2">
                        <button
                          type="button"
                          onClick={() => handleDeleteRow(row.sourceUrl)}
                          className="text-red-600 hover:text-red-700 inline-flex items-center gap-1"
                          aria-label={`Delete ${row.sourceUrl}`}
                        >
                          <Icons.Trash2 className="w-3.5 h-3.5" />
                          Delete
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>

          {importMessage && (
            <p className="mt-3 text-xs text-arda-text-secondary">{importMessage}</p>
          )}

          <p className="mt-4 text-xs text-arda-text-muted">
            Imported rows: {importedItems.length}. You can still edit everything in the Review step.
          </p>
        </div>
      )}
    </div>
  );
};

```

### `src/views/__tests__/IntegrationsStep.test.tsx`

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const mocks = vi.hoisted(() => ({
  listConnections: vi.fn(),
  getConnectionRuns: vi.fn(),
  connectProvider: vi.fn(),
  disconnectConnection: vi.fn(),
  syncConnection: vi.fn(),
  isSessionExpiredError: vi.fn(),
}));

vi.mock('../../services/api', () => ({
  integrationsApi: {
    listConnections: mocks.listConnections,
    getConnectionRuns: mocks.getConnectionRuns,
    connectProvider: mocks.connectProvider,
    disconnectConnection: mocks.disconnectConnection,
    syncConnection: mocks.syncConnection,
  },
  isSessionExpiredError: mocks.isSessionExpiredError,
}));

vi.mock('../../components/Icons', () => ({
  Icons: new Proxy(
    {},
    {
      get: () => () => null,
    },
  ),
}));

import { IntegrationsStep } from '../IntegrationsStep';

describe('IntegrationsStep accounting connectors', () => {
  beforeEach(() => {
    mocks.listConnections.mockReset();
    mocks.getConnectionRuns.mockReset();
    mocks.connectProvider.mockReset();
    mocks.disconnectConnection.mockReset();
    mocks.syncConnection.mockReset();
    mocks.isSessionExpiredError.mockReset();

    mocks.isSessionExpiredError.mockReturnValue(false);
    mocks.listConnections.mockResolvedValue({ connections: [] });
    mocks.getConnectionRuns.mockResolvedValue({ runs: [] });
    mocks.connectProvider.mockResolvedValue({ authUrl: 'https://example.com/connect' });
    mocks.disconnectConnection.mockResolvedValue({ success: true });
    mocks.syncConnection.mockResolvedValue({ success: true, runId: 'run-1' });
  });

  afterEach(() => {
    window.history.replaceState({}, '', '/');
  });

  it('renders accounting controls on integrations step', async () => {
    render(<IntegrationsStep />);
    expect(await screen.findByRole('button', { name: 'Connect QuickBooks' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Connect Xero' })).toBeInTheDocument();
  });

  it('shows connected status and latest run metrics', async () => {
    mocks.listConnections.mockResolvedValueOnce({
      connections: [
        {
          id: 'conn-qb',
          provider: 'quickbooks',
          tenantId: 'realm-1',
          tenantName: 'Acme Books',
          status: 'connected',
          tokenExpiresAt: '2026-12-01T00:00:00.000Z',
          createdAt: '2026-01-01T00:00:00.000Z',
          updatedAt: '2026-01-01T00:00:00.000Z',
        },
      ],
    });
    mocks.getConnectionRuns.mockResolvedValueOnce({
      runs: [
        {
          id: 'run-123',
          connectionId: 'conn-qb',
          trigger: 'manual',
          status: 'success',
          ordersUpserted: 3,
          ordersDeleted: 0,
          itemsUpserted: 12,
          apiCalls: 2,
          startedAt: '2026-01-01T00:00:00.000Z',
          finishedAt: '2026-01-01T00:01:00.000Z',
        },
      ],
    });

    render(<IntegrationsStep />);
    expect(await screen.findByText(/Connected.*Acme Books/)).toBeInTheDocument();
    expect(await screen.findByText('Last sync: 3 orders, 12 items')).toBeInTheDocument();
  });

  it('surfaces connect errors', async () => {
    const user = userEvent.setup();
    mocks.connectProvider.mockRejectedValueOnce(new Error('Connect failed'));

    render(<IntegrationsStep />);
    await user.click(await screen.findByRole('button', { name: 'Connect QuickBooks' }));

    expect(mocks.connectProvider).toHaveBeenCalledWith('quickbooks');
    expect(await screen.findByText('Connect failed')).toBeInTheDocument();
  });

  it('triggers manual sync and shows notice', async () => {
    const user = userEvent.setup();
    mocks.listConnections.mockResolvedValueOnce({
      connections: [
        {
          id: 'conn-qb',
          provider: 'quickbooks',
          tenantId: 'realm-1',
          status: 'connected',
          tokenExpiresAt: '2026-12-01T00:00:00.000Z',
          createdAt: '2026-01-01T00:00:00.000Z',
          updatedAt: '2026-01-01T00:00:00.000Z',
        },
      ],
    });
    mocks.getConnectionRuns.mockResolvedValueOnce({ runs: [] });

    render(<IntegrationsStep />);
    await user.click(await screen.findByRole('button', { name: 'Sync now' }));

    expect(mocks.syncConnection).toHaveBeenCalledWith('conn-qb');
    expect(await screen.findByText('Sync started. Refreshing status shortly...')).toBeInTheDocument();
  });

  it('disconnects provider and reloads state', async () => {
    const user = userEvent.setup();
    mocks.listConnections
      .mockResolvedValueOnce({
        connections: [
          {
            id: 'conn-qb',
            provider: 'quickbooks',
            tenantId: 'realm-1',
            status: 'connected',
            tokenExpiresAt: '2026-12-01T00:00:00.000Z',
            createdAt: '2026-01-01T00:00:00.000Z',
            updatedAt: '2026-01-01T00:00:00.000Z',
          },
        ],
      })
      .mockResolvedValueOnce({ connections: [] });
    mocks.getConnectionRuns.mockResolvedValueOnce({ runs: [] });

    render(<IntegrationsStep />);
    await user.click(await screen.findByRole('button', { name: 'Disconnect' }));

    expect(mocks.disconnectConnection).toHaveBeenCalledWith('conn-qb');
    await waitFor(() => expect(mocks.listConnections).toHaveBeenCalledTimes(2));
    expect(await screen.findByText('Integration disconnected.')).toBeInTheDocument();
  });

  it('shows callback success message and clears query params', async () => {
    window.history.pushState({}, '', '/?integration_provider=quickbooks&integration_status=connected');

    render(<IntegrationsStep />);

    expect(await screen.findByText('QuickBooks connected. Initial backfill started.')).toBeInTheDocument();
    expect(window.location.search).toBe('');
  });
});

```

### `src/views/__tests__/InventoryView.test.tsx`

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { InventoryView } from '../InventoryView';
import type { InventoryItem } from '../../types';

const exportItemsToCSV = vi.fn();

vi.mock('../../utils/exportUtils', () => ({
  exportItemsToCSV: (...args: unknown[]) => exportItemsToCSV(...args),
}));

const buildItem = (overrides: Partial<InventoryItem> = {}): InventoryItem => ({
  id: 'inv-1',
  name: 'Shop Towels',
  supplier: 'Warehouse Supply',
  totalQuantityOrdered: 20,
  orderCount: 3,
  firstOrderDate: '2025-01-01T00:00:00.000Z',
  lastOrderDate: '2025-02-01T00:00:00.000Z',
  averageCadenceDays: 10,
  dailyBurnRate: 2,
  recommendedMin: 12,
  recommendedOrderQty: 24,
  lastPrice: 20,
  history: [{ date: '2025-02-01T00:00:00.000Z', quantity: 10 }],
  ...overrides,
});

describe('InventoryView tenant resolution', () => {
  beforeEach(() => {
    vi.restoreAllMocks();
    exportItemsToCSV.mockReset();
    globalThis.fetch = vi.fn() as unknown as typeof fetch;
  });

  it('auto-attempts create_new and retries bulk sync on TENANT_REQUIRED', async () => {
    const user = userEvent.setup();
    const fetchMock = globalThis.fetch as unknown as ReturnType<typeof vi.fn>;
    const confirmSpy = vi.spyOn(window, 'confirm');

    fetchMock
      .mockResolvedValueOnce(
        new Response(
          JSON.stringify({
            success: false,
            code: 'TENANT_REQUIRED',
            details: {
              canCreateTenant: true,
              message: 'No tenant mapping found.',
            },
          }),
          { status: 200, headers: { 'Content-Type': 'application/json' } },
        ),
      )
      .mockResolvedValueOnce(
        new Response(
          JSON.stringify({
            success: true,
            tenantId: 'tenant-new',
            author: 'author-new',
          }),
          { status: 200, headers: { 'Content-Type': 'application/json' } },
        ),
      )
      .mockResolvedValueOnce(
        new Response(
          JSON.stringify({
            success: true,
            summary: { total: 1, successful: 1, failed: 0 },
            results: [{ item: 'Shop Towels', status: 'fulfilled' }],
          }),
          { status: 200, headers: { 'Content-Type': 'application/json' } },
        ),
      );

    render(<InventoryView inventory={[buildItem()]} />);

    await user.click(screen.getByRole('button', { name: 'Sync All to Arda' }));

    await waitFor(() => expect(fetchMock).toHaveBeenCalledTimes(3));
    const resolveCall = fetchMock.mock.calls[1];
    expect(String(resolveCall?.[0])).toContain('/api/arda/tenant/resolve');
    const resolveBody = JSON.parse(((resolveCall?.[1] as RequestInit)?.body as string) || '{}') as { action?: string };
    expect(resolveBody.action).toBe('create_new');
    expect(confirmSpy).not.toHaveBeenCalled();
  });

  it('falls back to CSV when tenant cannot be auto-provisioned', async () => {
    const user = userEvent.setup();
    const fetchMock = globalThis.fetch as unknown as ReturnType<typeof vi.fn>;

    fetchMock.mockResolvedValueOnce(
      new Response(
        JSON.stringify({
          success: false,
          code: 'TENANT_REQUIRED',
          error: 'Tenant required for Arda sync',
          details: {
            canCreateTenant: false,
            autoProvisionAttempted: true,
            autoProvisionSucceeded: false,
            autoProvisionError: 'Automatic tenant provisioning failed.',
          },
        }),
        { status: 200, headers: { 'Content-Type': 'application/json' } },
      ),
    );

    render(<InventoryView inventory={[buildItem()]} />);

    await user.click(screen.getByRole('button', { name: 'Sync All to Arda' }));

    await screen.findByText(/Exported items to CSV/i);
    expect(exportItemsToCSV).toHaveBeenCalledTimes(1);
    expect(exportItemsToCSV).toHaveBeenCalledWith(
      expect.any(Array),
      'inventory-tenant-unresolved',
    );
  });
});

```

### `src/views/__tests__/MasterListStep.test.tsx`

```tsx
import { render, screen } from '@testing-library/react';
import { describe, expect, it, vi } from 'vitest';
import { MasterListStep } from '../MasterListStep';
import type { MasterListItem, RowSyncState } from '../../components/ItemsTable/types';

function makeItem(overrides: Partial<MasterListItem> = {}): MasterListItem {
  return {
    id: 'item-1',
    source: 'email',
    orderMethod: 'online',
    name: 'Test Item',
    needsAttention: false,
    ...overrides,
  };
}

describe('MasterListStep', () => {
  const defaultProps = {
    items: [makeItem()],
    syncStateById: {} as Record<string, RowSyncState>,
    isBulkSyncing: false,
    onSyncSingle: vi.fn().mockResolvedValue(true),
    onSyncSelected: vi.fn().mockResolvedValue(undefined),
    onUpdateItem: vi.fn(),
    onRemoveItem: vi.fn(),
    onComplete: vi.fn(),
    onBack: vi.fn(),
    onFooterStateChange: vi.fn(),
  };

  it('does not render instruction card (tips are in header)', () => {
    render(<MasterListStep {...defaultProps} />);
    expect(screen.queryByText('What to do')).not.toBeInTheDocument();
  });

  it('shows item count', () => {
    render(<MasterListStep {...defaultProps} />);
    expect(screen.getByText('1 items')).toBeInTheDocument();
  });

  it('shows synced count', () => {
    render(
      <MasterListStep
        {...defaultProps}
        syncStateById={{ 'item-1': { status: 'success' } }}
      />,
    );
    expect(screen.getByText('1 synced')).toBeInTheDocument();
  });

  it('shows error count when items have sync errors', () => {
    render(
      <MasterListStep
        {...defaultProps}
        syncStateById={{ 'item-1': { status: 'error', error: 'Failed' } }}
      />,
    );
    expect(screen.getByText('1 failed')).toBeInTheDocument();
  });

  it('shows needs attention count', () => {
    render(
      <MasterListStep
        {...defaultProps}
        items={[makeItem({ needsAttention: true })]}
      />,
    );
    expect(screen.getByText('1 need attention')).toBeInTheDocument();
  });

  it('reports footer state via callback', () => {
    const onFooterStateChange = vi.fn();
    render(
      <MasterListStep
        {...defaultProps}
        onFooterStateChange={onFooterStateChange}
      />,
    );
    expect(onFooterStateChange).toHaveBeenCalledWith(
      expect.objectContaining({
        selectedCount: 1,
        syncedCount: 0,
        canSyncSelected: true,
        canComplete: true,
        isSyncing: false,
      }),
    );
  });

  it('reports syncing state when bulk syncing', () => {
    const onFooterStateChange = vi.fn();
    render(
      <MasterListStep
        {...defaultProps}
        isBulkSyncing={true}
        onFooterStateChange={onFooterStateChange}
      />,
    );
    expect(onFooterStateChange).toHaveBeenCalledWith(
      expect.objectContaining({
        canSyncSelected: false,
        isSyncing: true,
      }),
    );
  });
});

```

### `src/views/__tests__/OnboardingFlow.test.tsx`

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { afterEach, describe, expect, it, vi } from 'vitest';

vi.mock('../SupplierSetup', () => ({
  SupplierSetup: ({ onCanProceed }: { onCanProceed?: (canProceed: boolean) => void }) => (
    <div>
      <div>supplier-setup</div>
      <button type="button" onClick={() => onCanProceed?.(true)}>
        enable-email-continue
      </button>
    </div>
  ),
}));

vi.mock('../OnboardingWelcomeStep', () => ({
  OnboardingWelcomeStep: ({
    onStartEmailSync,
    onSkipEmail,
  }: {
    onStartEmailSync: () => void;
    onSkipEmail: () => void;
  }) => (
    <div>
      <div>welcome-step</div>
      <button type="button" onClick={onStartEmailSync}>
        start-email-sync
      </button>
      <button type="button" onClick={onSkipEmail}>
        skip-email-sync
      </button>
    </div>
  ),
}));

vi.mock('../BarcodeScanStep', () => ({
  BarcodeScanStep: () => <div>barcode-step</div>,
}));

vi.mock('../IntegrationsStep', () => ({
  IntegrationsStep: () => <div>integrations-step</div>,
}));

vi.mock('../UrlScrapeStep', () => ({
  UrlScrapeStep: ({
    onReviewStateChange,
  }: {
    onReviewStateChange?: (state: {
      pendingReviewCount: number;
      unimportedApprovedCount: number;
      totalRows: number;
      canContinue: boolean;
    }) => void;
  }) => (
    <div>
      <div>url-scrape-step</div>
      <button
        type="button"
        onClick={() => onReviewStateChange?.({
          pendingReviewCount: 1,
          unimportedApprovedCount: 0,
          totalRows: 1,
          canContinue: false,
        })}
      >
        block-url-continue
      </button>
      <button
        type="button"
        onClick={() => onReviewStateChange?.({
          pendingReviewCount: 0,
          unimportedApprovedCount: 0,
          totalRows: 1,
          canContinue: true,
        })}
      >
        allow-url-continue
      </button>
    </div>
  ),
}));

vi.mock('../PhotoCaptureStep', () => ({
  PhotoCaptureStep: () => <div>photo-step</div>,
}));

vi.mock('../CSVUploadStep', () => ({
  CSVUploadStep: () => <div>csv-step</div>,
}));

vi.mock('../MasterListStep', () => ({
  MasterListStep: () => <div>masterlist-step</div>,
}));

import { OnboardingFlow } from '../OnboardingFlow';

describe('OnboardingFlow email continuation reminder', () => {
  afterEach(() => {
    window.history.replaceState({}, '', '/');
  });

  it('shows the reminder on the email step', async () => {
    const user = userEvent.setup();

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    expect(screen.getAllByText('Step 1 of 8').length).toBeGreaterThan(0);
    expect(screen.getByText('welcome-step')).toBeInTheDocument();
    await user.click(screen.getByRole('button', { name: 'start-email-sync' }));

    expect(screen.getAllByText('Step 2 of 8').length).toBeGreaterThan(0);
    expect(
      screen.getByText('Continuing won’t stop email scanning. Import keeps running in the background.'),
    ).toBeInTheDocument();
  });

  it('hides the reminder after advancing to Integrations step', async () => {
    const user = userEvent.setup();

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    await user.click(screen.getByRole('button', { name: 'start-email-sync' }));
    await user.click(screen.getByRole('button', { name: 'enable-email-continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));

    expect(screen.getByText('integrations-step')).toBeInTheDocument();
    expect(screen.getAllByText('Step 3 of 8').length).toBeGreaterThan(0);
    expect(
      screen.queryByText('Continuing won’t stop email scanning. Import keeps running in the background.'),
    ).not.toBeInTheDocument();
  });

  it('renders URL scrape as step 3 after integrations', async () => {
    const user = userEvent.setup();

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    await user.click(screen.getByRole('button', { name: 'start-email-sync' }));
    await user.click(screen.getByRole('button', { name: 'enable-email-continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));

    expect(screen.getByText('url-scrape-step')).toBeInTheDocument();
    expect(screen.getAllByText('Step 4 of 8').length).toBeGreaterThan(0);
  });

  it('blocks continue on URL step until review state allows it', async () => {
    const user = userEvent.setup();

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    await user.click(screen.getByRole('button', { name: 'start-email-sync' }));
    await user.click(screen.getByRole('button', { name: 'enable-email-continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));

    expect(screen.getByText('url-scrape-step')).toBeInTheDocument();
    await user.click(screen.getByRole('button', { name: 'block-url-continue' }));

    expect(screen.getByRole('button', { name: 'Continue' })).toBeDisabled();
    expect(screen.getByText(/review every scraped row before continuing/i)).toBeInTheDocument();

    await user.click(screen.getByRole('button', { name: 'allow-url-continue' }));
    expect(screen.getByRole('button', { name: 'Continue' })).toBeEnabled();
  });

  it('starts on integrations step when OAuth callback params are present', () => {
    window.history.pushState({}, '', '/?integration_provider=quickbooks&integration_status=connected');

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    expect(screen.getByText('integrations-step')).toBeInTheDocument();
    expect(screen.getAllByText('Step 3 of 8').length).toBeGreaterThan(0);
  });

  it('shows step tips in the header popover', async () => {
    const user = userEvent.setup();

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    await user.click(screen.getByRole('button', { name: 'start-email-sync' }));
    await user.click(screen.getByRole('button', { name: 'enable-email-continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));

    expect(screen.getByText('integrations-step')).toBeInTheDocument();
    await user.click(screen.getByRole('button', { name: /tips/i }));

    expect(
      screen.getByText('Connect QuickBooks or Xero if you want PO data.'),
    ).toBeInTheDocument();
  });

  it('closes the tips popover when advancing steps', async () => {
    const user = userEvent.setup();

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    await user.click(screen.getByRole('button', { name: 'start-email-sync' }));
    await user.click(screen.getByRole('button', { name: 'enable-email-continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));

    expect(screen.getByText('integrations-step')).toBeInTheDocument();
    await user.click(screen.getByRole('button', { name: /tips/i }));
    expect(screen.getByText('Connect QuickBooks or Xero if you want PO data.')).toBeInTheDocument();

    await user.click(screen.getByRole('button', { name: 'Continue' }));
    expect(screen.getByText('url-scrape-step')).toBeInTheDocument();
    expect(screen.queryByText('Connect QuickBooks or Xero if you want PO data.')).not.toBeInTheDocument();
  });

  it('renders footer navigation buttons on non-welcome steps', async () => {
    const user = userEvent.setup();

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    await user.click(screen.getByRole('button', { name: 'start-email-sync' }));
    await user.click(screen.getByRole('button', { name: 'enable-email-continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));

    expect(screen.getByText('integrations-step')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Back' })).toBeEnabled();
    expect(screen.getByRole('button', { name: 'Skip' })).toBeEnabled();
    expect(screen.getByRole('button', { name: 'Continue' })).toBeEnabled();
  });

  it('allows skipping a step even when Continue is disabled', async () => {
    const user = userEvent.setup();

    render(<OnboardingFlow onComplete={vi.fn()} onSkip={vi.fn()} />);

    await user.click(screen.getByRole('button', { name: 'start-email-sync' }));
    await user.click(screen.getByRole('button', { name: 'enable-email-continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));
    await user.click(screen.getByRole('button', { name: 'Continue' }));

    expect(screen.getByText('url-scrape-step')).toBeInTheDocument();
    await user.click(screen.getByRole('button', { name: 'block-url-continue' }));

    expect(screen.getByRole('button', { name: 'Continue' })).toBeDisabled();
    await user.click(screen.getByRole('button', { name: 'Skip' }));

    expect(screen.getByText('barcode-step')).toBeInTheDocument();
  });
});

```

### `src/views/__tests__/SupplierSetup.test.tsx`

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const mocks = vi.hoisted(() => ({
  discoverSuppliers: vi.fn(),
  startAmazon: vi.fn(),
  startJob: vi.fn(),
  getStatus: vi.fn(),
  getGmailStatus: vi.fn(),
  isSessionExpiredError: vi.fn(),
  listConnections: vi.fn(),
  getConnectionRuns: vi.fn(),
  connectProvider: vi.fn(),
  disconnectConnection: vi.fn(),
  syncConnection: vi.fn(),
}));

vi.mock('../../services/api', () => ({
  ApiRequestError: class ApiRequestError extends Error {
    code?: string;

    constructor(message: string, status = 400, code?: string, details?: unknown) {
      super(message);
      this.name = 'ApiRequestError';
      this.code = code;
      void status;
      void details;
    }
  },
  discoverApi: {
    discoverSuppliers: mocks.discoverSuppliers,
  },
  jobsApi: {
    startAmazon: mocks.startAmazon,
    startJob: mocks.startJob,
    getStatus: mocks.getStatus,
  },
  gmailApi: {
    getStatus: mocks.getGmailStatus,
  },
  integrationsApi: {
    listConnections: mocks.listConnections,
    getConnectionRuns: mocks.getConnectionRuns,
    connectProvider: mocks.connectProvider,
    disconnectConnection: mocks.disconnectConnection,
    syncConnection: mocks.syncConnection,
  },
  isSessionExpiredError: mocks.isSessionExpiredError,
}));

vi.mock('../../components/Icons', () => ({
  Icons: new Proxy(
    {},
    {
      get: () => () => null,
    },
  ),
}));

import { EmailScanState, SupplierSetup } from '../SupplierSetup';

const buildInitialState = (overrides: Partial<EmailScanState> = {}): EmailScanState => ({
  amazonOrders: [
    {
      id: 'amazon-order-1',
      originalEmailId: 'email-1',
      supplier: 'Amazon',
      orderDate: '2026-01-01',
      items: [],
      confidence: 1,
    },
  ],
  priorityOrders: [],
  otherOrders: [],
  isAmazonComplete: true,
  isPriorityComplete: true,
  discoveredSuppliers: [
    {
      domain: 'fastenal.com',
      displayName: 'Fastenal',
      emailCount: 4,
      score: 80,
      category: 'industrial',
      sampleSubjects: ['Order 1'],
      isRecommended: false,
    },
    {
      domain: 'grainger.com',
      displayName: 'Grainger',
      emailCount: 2,
      score: 70,
      category: 'industrial',
      sampleSubjects: ['Order 2'],
      isRecommended: false,
    },
  ],
  hasDiscovered: true,
  hasStartedOtherImport: false,
  selectedOtherSuppliers: [],
  ...overrides,
});

const getLastCanProceedValue = (onCanProceed: ReturnType<typeof vi.fn>) =>
  onCanProceed.mock.calls[onCanProceed.mock.calls.length - 1]?.[0];

describe('SupplierSetup supplier import behavior', () => {
  beforeEach(() => {
    vi.spyOn(console, 'error').mockImplementation(() => {});
    mocks.discoverSuppliers.mockReset();
    mocks.startAmazon.mockReset();
    mocks.startJob.mockReset();
    mocks.getStatus.mockReset();
    mocks.getGmailStatus.mockReset();
    mocks.isSessionExpiredError.mockReset();
    mocks.listConnections.mockReset();
    mocks.getConnectionRuns.mockReset();
    mocks.connectProvider.mockReset();
    mocks.disconnectConnection.mockReset();
    mocks.syncConnection.mockReset();
    mocks.isSessionExpiredError.mockReturnValue(false);
    mocks.startJob.mockResolvedValue({ jobId: 'other-job-1' });
    mocks.getGmailStatus.mockResolvedValue({ connected: true, gmailEmail: 'test@example.com' });
    mocks.getStatus.mockResolvedValue({
      hasJob: true,
      status: 'running',
      progress: {
        processed: 0,
        total: 1,
        success: 0,
        failed: 0,
        currentTask: 'Scanning...',
      },
      orders: [],
    });
    mocks.listConnections.mockResolvedValue({ connections: [] });
    mocks.getConnectionRuns.mockResolvedValue({ runs: [] });
    mocks.connectProvider.mockResolvedValue({ authUrl: 'https://example.com' });
    mocks.disconnectConnection.mockResolvedValue({ success: true });
    mocks.syncConnection.mockResolvedValue({ success: true, runId: 'run-1' });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('does not start other-supplier scan when only selecting a supplier tile', async () => {
    const user = userEvent.setup();
    const onCanProceed = vi.fn();

    render(
      <SupplierSetup
        onScanComplete={vi.fn()}
        onSkip={vi.fn()}
        onCanProceed={onCanProceed}
        initialState={buildInitialState()}
      />,
    );

    await waitFor(() => expect(getLastCanProceedValue(onCanProceed)).toBe(false));

    await user.click(screen.getByText('Fastenal'));

    expect(mocks.startJob).not.toHaveBeenCalled();
    await waitFor(() => expect(getLastCanProceedValue(onCanProceed)).toBe(false));
  });

  it('does not show the continue anytime popup by default', () => {
    render(
      <SupplierSetup
        onScanComplete={vi.fn()}
        onSkip={vi.fn()}
        onCanProceed={vi.fn()}
        initialState={buildInitialState()}
      />,
    );

    expect(screen.queryByRole('dialog', { name: 'Continue anytime' })).not.toBeInTheDocument();
  });

  it('starts other-supplier scan only when Import is clicked', async () => {
    const user = userEvent.setup();

    render(
      <SupplierSetup
        onScanComplete={vi.fn()}
        onSkip={vi.fn()}
        onCanProceed={vi.fn()}
        initialState={buildInitialState()}
      />,
    );

    await user.click(screen.getByText('Fastenal'));
    await user.click(screen.getByText('Grainger'));
    await user.click(screen.getByRole('button', { name: 'Import 2 Suppliers' }));

    expect(await screen.findByRole('dialog', { name: 'Continue anytime' })).toBeInTheDocument();
    await waitFor(() => expect(mocks.startJob).toHaveBeenCalledTimes(1));
    expect(mocks.startJob).toHaveBeenCalledWith(['fastenal.com', 'grainger.com'], 'other');
  });

  it('shows the continue anytime popup only once per page visit', async () => {
    const user = userEvent.setup();
    mocks.startJob.mockRejectedValueOnce(new Error('Failed to start selected supplier import.'));

    render(
      <SupplierSetup
        onScanComplete={vi.fn()}
        onSkip={vi.fn()}
        onCanProceed={vi.fn()}
        initialState={buildInitialState()}
      />,
    );

    await user.click(screen.getByText('Fastenal'));
    await user.click(screen.getByRole('button', { name: 'Import 1 Supplier' }));
    expect(await screen.findByRole('dialog', { name: 'Continue anytime' })).toBeInTheDocument();

    await user.click(screen.getByRole('button', { name: 'Got it' }));
    expect(screen.queryByRole('dialog', { name: 'Continue anytime' })).not.toBeInTheDocument();

    await user.click(screen.getByRole('button', { name: 'Import 1 Supplier' }));
    await waitFor(() => expect(mocks.startJob).toHaveBeenCalledTimes(2));
    expect(screen.queryByRole('dialog', { name: 'Continue anytime' })).not.toBeInTheDocument();
  });

  it('renders batching callout between Industrial Suppliers and Other Suppliers', () => {
    render(
      <SupplierSetup
        onScanComplete={vi.fn()}
        onSkip={vi.fn()}
        onCanProceed={vi.fn()}
        initialState={buildInitialState()}
      />,
    );

    const industrialHeading = screen.getByRole('heading', { name: 'Industrial Suppliers' });
    const batchingCallout = screen.getByText('A word about batching...');
    const otherHeading = screen.getByRole('heading', { name: 'Other Suppliers' });

    expect(industrialHeading.compareDocumentPosition(batchingCallout) & Node.DOCUMENT_POSITION_FOLLOWING).toBeTruthy();
    expect(batchingCallout.compareDocumentPosition(otherHeading) & Node.DOCUMENT_POSITION_FOLLOWING).toBeTruthy();
  });

  it('keeps proceed disabled until other import is explicitly started', async () => {
    const user = userEvent.setup();
    const onCanProceed = vi.fn();

    render(
      <SupplierSetup
        onScanComplete={vi.fn()}
        onSkip={vi.fn()}
        onCanProceed={onCanProceed}
        initialState={buildInitialState()}
      />,
    );

    await waitFor(() => expect(getLastCanProceedValue(onCanProceed)).toBe(false));

    await user.click(screen.getByText('Fastenal'));
    await waitFor(() => expect(getLastCanProceedValue(onCanProceed)).toBe(false));

    await user.click(screen.getByRole('button', { name: 'Import 1 Supplier' }));
    await waitFor(() => expect(getLastCanProceedValue(onCanProceed)).toBe(true));
  });

  it('allows proceed when there are no additional suppliers to import', async () => {
    const onCanProceed = vi.fn();

    render(
      <SupplierSetup
        onScanComplete={vi.fn()}
        onSkip={vi.fn()}
        onCanProceed={onCanProceed}
        initialState={buildInitialState({ discoveredSuppliers: [] })}
      />,
    );

    await waitFor(() => expect(getLastCanProceedValue(onCanProceed)).toBe(true));
  });

  it('shows an error and keeps proceed disabled when import start fails', async () => {
    const user = userEvent.setup();
    const onCanProceed = vi.fn();
    mocks.startJob.mockRejectedValueOnce(new Error('Failed to start selected supplier import.'));

    render(
      <SupplierSetup
        onScanComplete={vi.fn()}
        onSkip={vi.fn()}
        onCanProceed={onCanProceed}
        initialState={buildInitialState()}
      />,
    );

    await user.click(screen.getByText('Fastenal'));
    await user.click(screen.getByRole('button', { name: 'Import 1 Supplier' }));

    expect(await screen.findByText('Failed to start selected supplier import.')).toBeInTheDocument();
    await waitFor(() => expect(getLastCanProceedValue(onCanProceed)).toBe(false));
  });

});

```

### `src/views/__tests__/UrlScrapeStep.test.tsx`

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, expect, it, vi, beforeEach } from 'vitest';

const mocks = vi.hoisted(() => ({
  scrapeUrls: vi.fn(),
}));

vi.mock('../../services/api', async () => {
  const actual = await vi.importActual('../../services/api');
  return {
    ...actual,
    urlIngestionApi: {
      scrapeUrls: mocks.scrapeUrls,
    },
  };
});

import { UrlScrapeStep } from '../UrlScrapeStep';

describe('UrlScrapeStep', () => {
  beforeEach(() => {
    mocks.scrapeUrls.mockReset();
  });

  it('parses and deduplicates URLs before scraping', async () => {
    const user = userEvent.setup();
    mocks.scrapeUrls.mockResolvedValue({
      requested: 2,
      processed: 2,
      results: [],
      items: [],
    });

    render(<UrlScrapeStep importedItems={[]} onImportItems={vi.fn()} />);

    await user.type(
      screen.getByPlaceholderText(/https:\/\/www\.amazon\.com/i),
      'https://example.com/a, https://example.com/a\nhttps://example.com/b',
    );

    await user.click(screen.getByRole('button', { name: /Scrape URLs/i }));

    await waitFor(() => {
      expect(mocks.scrapeUrls).toHaveBeenCalledWith([
        'https://example.com/a',
        'https://example.com/b',
      ]);
    });
  });

  it('disables scraping when URL count exceeds the limit', async () => {
    const user = userEvent.setup();

    render(<UrlScrapeStep importedItems={[]} onImportItems={vi.fn()} />);

    const urls = Array.from({ length: 51 }, (_, idx) => `https://example.com/${idx}`).join('\n');
    await user.type(screen.getByPlaceholderText(/https:\/\/www\.amazon\.com/i), urls);

    expect(screen.getByText(/max 50/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /Scrape URLs/i })).toBeDisabled();
  });

  it('imports only approved rows and preserves manual edits', async () => {
    const user = userEvent.setup();
    const onImportItems = vi.fn();

    mocks.scrapeUrls.mockResolvedValue({
      requested: 2,
      processed: 2,
      results: [
        {
          sourceUrl: 'https://example.com/a',
          status: 'success',
          extractionSource: 'html-metadata',
          item: {
            sourceUrl: 'https://example.com/a',
            productUrl: 'https://example.com/a',
            itemName: 'Widget A',
            supplier: 'Acme',
            needsReview: false,
            extractionSource: 'html-metadata',
            confidence: 0.8,
          },
        },
        {
          sourceUrl: 'https://example.com/b',
          status: 'partial',
          extractionSource: 'error',
          message: 'Timeout',
          item: {
            sourceUrl: 'https://example.com/b',
            productUrl: 'https://example.com/b',
            itemName: 'Unknown item',
            needsReview: true,
            extractionSource: 'error',
            confidence: 0,
          },
        },
      ],
      items: [],
    });

    render(<UrlScrapeStep importedItems={[]} onImportItems={onImportItems} />);

    await user.type(screen.getByPlaceholderText(/https:\/\/www\.amazon\.com/i), 'https://example.com/a\nhttps://example.com/b');
    await user.click(screen.getByRole('button', { name: /Scrape URLs/i }));

    expect(await screen.findByLabelText('Item name for https://example.com/a')).toHaveValue('Widget A');
    expect(screen.getByText(/1 success/i)).toBeInTheDocument();
    expect(screen.getByText(/1 partial/i)).toBeInTheDocument();

    await user.click(screen.getByRole('button', { name: /Import Approved To Master List/i }));
    expect(screen.getByText(/approve at least one row/i)).toBeInTheDocument();
    expect(onImportItems).not.toHaveBeenCalled();

    await user.click(screen.getByLabelText('Approve https://example.com/a'));
    const supplierInput = screen.getByLabelText('Supplier for https://example.com/a');
    await user.clear(supplierInput);
    await user.type(supplierInput, 'Acme Updated');
    await user.click(screen.getByRole('button', { name: /Import Approved To Master List/i }));

    expect(onImportItems).toHaveBeenCalledTimes(1);
    expect(onImportItems.mock.calls[0][0]).toHaveLength(1);
    expect(onImportItems.mock.calls[0][0][0]).toMatchObject({
      sourceUrl: 'https://example.com/a',
      supplier: 'Acme Updated',
    });
  });

  it('appends new scraped rows instead of replacing previous results', async () => {
    const user = userEvent.setup();

    mocks.scrapeUrls
      .mockResolvedValueOnce({
        requested: 1,
        processed: 1,
        results: [
          {
            sourceUrl: 'https://example.com/a',
            status: 'success',
            extractionSource: 'html-metadata',
            item: {
              sourceUrl: 'https://example.com/a',
              productUrl: 'https://example.com/a',
              itemName: 'Widget A',
              needsReview: false,
              extractionSource: 'html-metadata',
              confidence: 0.8,
            },
          },
        ],
        items: [],
      })
      .mockResolvedValueOnce({
        requested: 1,
        processed: 1,
        results: [
          {
            sourceUrl: 'https://example.com/b',
            status: 'success',
            extractionSource: 'html-metadata',
            item: {
              sourceUrl: 'https://example.com/b',
              productUrl: 'https://example.com/b',
              itemName: 'Widget B',
              needsReview: false,
              extractionSource: 'html-metadata',
              confidence: 0.8,
            },
          },
        ],
        items: [],
      });

    render(<UrlScrapeStep importedItems={[]} onImportItems={vi.fn()} />);

    const textarea = screen.getByPlaceholderText(/https:\/\/www\.amazon\.com/i);
    await user.type(textarea, 'https://example.com/a');
    await user.click(screen.getByRole('button', { name: /Scrape URLs/i }));
    expect(await screen.findByLabelText('Item name for https://example.com/a')).toHaveValue('Widget A');

    await user.clear(textarea);
    await user.type(textarea, 'https://example.com/b');
    await user.click(screen.getByRole('button', { name: /Scrape URLs/i }));

    expect(await screen.findByLabelText('Item name for https://example.com/a')).toHaveValue('Widget A');
    expect(screen.getByLabelText('Item name for https://example.com/b')).toHaveValue('Widget B');
  });

  it('removes imported URL item when a row is deleted', async () => {
    const user = userEvent.setup();
    const onDeleteImportedItem = vi.fn();

    mocks.scrapeUrls.mockResolvedValue({
      requested: 1,
      processed: 1,
      results: [
        {
          sourceUrl: 'https://example.com/a',
          status: 'success',
          extractionSource: 'html-metadata',
          item: {
            sourceUrl: 'https://example.com/a',
            productUrl: 'https://example.com/a',
            itemName: 'Widget A',
            needsReview: false,
            extractionSource: 'html-metadata',
            confidence: 0.8,
          },
        },
      ],
      items: [],
    });

    render(
      <UrlScrapeStep
        importedItems={[
          {
            sourceUrl: 'https://example.com/a',
            productUrl: 'https://example.com/a',
            itemName: 'Widget A',
            needsReview: false,
            extractionSource: 'html-metadata',
            confidence: 0.8,
          },
        ]}
        onImportItems={vi.fn()}
        onDeleteImportedItem={onDeleteImportedItem}
      />,
    );

    await user.type(screen.getByPlaceholderText(/https:\/\/www\.amazon\.com/i), 'https://example.com/a');
    await user.click(screen.getByRole('button', { name: /Scrape URLs/i }));

    await user.click(await screen.findByRole('button', { name: 'Delete https://example.com/a' }));
    expect(onDeleteImportedItem).toHaveBeenCalledWith('https://example.com/a');
  });
});

```

### `src/views/__tests__/supplierSetupUtils.test.ts`

```typescript
import { describe, expect, it } from 'vitest';
import { DiscoveredSupplier } from '../../services/api';
import {
  buildSupplierGridItems,
  calculateProgressPercent,
  canonicalizePrioritySupplierDomain,
  getPrioritySummaryText,
  getMilestoneMessage,
  isPrioritySupplierDomain,
  PRIORITY_SUPPLIER_SCAN_DOMAINS,
} from '../supplierSetupUtils';

describe('supplierSetupUtils', () => {
  it('marks enabled suppliers correctly', () => {
    const suppliers: DiscoveredSupplier[] = [
      {
        domain: 'foo.com',
        displayName: 'Foo',
        emailCount: 1,
        score: 80,
        category: 'retail',
        sampleSubjects: [],
        isRecommended: false,
      },
      {
        domain: 'bar.com',
        displayName: 'Bar',
        emailCount: 1,
        score: 70,
        category: 'office',
        sampleSubjects: [],
        isRecommended: false,
      },
      {
        domain: 'unknown.com',
        displayName: 'Unknown',
        emailCount: 0,
        score: 10,
        category: 'unknown',
        sampleSubjects: [],
        isRecommended: false,
      },
    ];
    const enabledSuppliers = new Set(['foo.com']);

    const grid = buildSupplierGridItems(suppliers, enabledSuppliers);

    expect(grid).toHaveLength(3);
    expect(grid[0].isEnabled).toBe(true);
    expect(grid[1].isEnabled).toBe(false);
    expect(grid[0].colors).toHaveProperty('bg');
    expect(grid[2].colors.icon).toBe('📦'); // falls back to unknown color set
  });

  it('calculates progress percentage within bounds', () => {
    expect(calculateProgressPercent(undefined)).toBe(0);
    expect(calculateProgressPercent({ total: 0, processed: 0, success: 0, failed: 0, currentTask: '' })).toBe(0);
    expect(calculateProgressPercent({ total: 2, processed: 1, success: 1, failed: 0, currentTask: '' })).toBe(50);
    expect(calculateProgressPercent({ total: 5, processed: 10, success: 0, failed: 0, currentTask: '' })).toBe(100);
    expect(calculateProgressPercent({ total: 4, processed: -2, success: 0, failed: 0, currentTask: '' })).toBe(0);
    expect(calculateProgressPercent({ total: 4, processed: Number.POSITIVE_INFINITY, success: 0, failed: 0, currentTask: '' })).toBe(0);
  });

  it('recognizes and canonicalizes priority supplier aliases', () => {
    expect(canonicalizePrioritySupplierDomain('mcmaster-carr.com')).toBe('mcmaster.com');
    expect(canonicalizePrioritySupplierDomain('Mcmaster.com')).toBe('mcmaster.com');
    expect(canonicalizePrioritySupplierDomain('uline.com')).toBe('uline.com');

    expect(isPrioritySupplierDomain('mcmaster.com')).toBe(true);
    expect(isPrioritySupplierDomain('mcmaster-carr.com')).toBe(true);
    expect(isPrioritySupplierDomain('uline.com')).toBe(true);
    expect(isPrioritySupplierDomain('example.com')).toBe(false);

    expect(PRIORITY_SUPPLIER_SCAN_DOMAINS).toEqual(
      expect.arrayContaining(['mcmaster.com', 'mcmaster-carr.com', 'uline.com']),
    );
  });

  it('returns milestone metadata for known milestones and fallback for unknown', () => {
    const firstItem = getMilestoneMessage('firstItem');
    expect(firstItem.title).toMatch(/First Item/);
    const tenItems = getMilestoneMessage('tenItems');
    expect(tenItems.emoji).toBe('🚀');
    const fiftyItems = getMilestoneMessage('fiftyItems');
    expect(fiftyItems.title).toMatch(/50/);
    const hundredItems = getMilestoneMessage('hundredItems');
    expect(hundredItems.title).toMatch(/100/);

    const unknown = getMilestoneMessage('not-real');
    expect(unknown.title).toMatch(/Milestone/);
  });

  it('builds industrial card status text for running, complete, empty, and error states', () => {
    expect(
      getPrioritySummaryText({
        error: null,
        isComplete: false,
        processedEmails: 3,
        totalEmails: 12,
        orderCount: 2,
        itemCount: 7,
      }),
    ).toContain('Analyzing 3/12 emails');

    expect(
      getPrioritySummaryText({
        error: null,
        isComplete: true,
        processedEmails: 12,
        totalEmails: 12,
        orderCount: 4,
        itemCount: 9,
      }),
    ).toBe('9 items from 4 orders');

    expect(
      getPrioritySummaryText({
        error: null,
        isComplete: true,
        processedEmails: 12,
        totalEmails: 12,
        orderCount: 0,
        itemCount: 0,
      }),
    ).toContain('no line items extracted');

    expect(
      getPrioritySummaryText({
        error: 'Boom',
        isComplete: false,
        processedEmails: 0,
        totalEmails: 0,
        orderCount: 0,
        itemCount: 0,
      }),
    ).toBe('Boom');
  });
});

```

### `src/views/supplierSetupUtils.ts`

```typescript
import { JobProgress, DiscoveredSupplier } from '../services/api';

const PRIORITY_SUPPLIER_CONFIG = [
  {
    canonicalDomain: 'mcmaster.com',
    aliases: ['mcmaster.com', 'mcmaster-carr.com'],
    displayName: 'McMaster-Carr',
  },
  {
    canonicalDomain: 'uline.com',
    aliases: ['uline.com'],
    displayName: 'Uline',
  },
] as const;

const PRIORITY_SUPPLIER_ALIAS_TO_CANONICAL: Record<string, string> = PRIORITY_SUPPLIER_CONFIG
  .flatMap(({ canonicalDomain, aliases }) => aliases.map((alias) => [alias, canonicalDomain] as const))
  .reduce<Record<string, string>>((map, [alias, canonicalDomain]) => {
    map[alias] = canonicalDomain;
    return map;
  }, {});

export const PRIORITY_SUPPLIER_SCAN_DOMAINS = Array.from(
  new Set(PRIORITY_SUPPLIER_CONFIG.flatMap(({ aliases }) => aliases)),
);

// Contains both canonical domains and aliases.
export const PRIORITY_SUPPLIER_DOMAINS = new Set<string>(PRIORITY_SUPPLIER_SCAN_DOMAINS);

export const OTHER_PRIORITY_SUPPLIERS: DiscoveredSupplier[] = PRIORITY_SUPPLIER_CONFIG.map(
  ({ canonicalDomain, displayName }) => ({
    domain: canonicalDomain,
    displayName,
    emailCount: 0,
    score: 100,
    category: 'industrial',
    sampleSubjects: [],
    isRecommended: true,
  }),
);

export function canonicalizePrioritySupplierDomain(domain: string): string {
  const normalized = domain.trim().toLowerCase();
  return PRIORITY_SUPPLIER_ALIAS_TO_CANONICAL[normalized] || normalized;
}

export function isPrioritySupplierDomain(domain: string): boolean {
  const normalized = domain.trim().toLowerCase();
  return PRIORITY_SUPPLIER_DOMAINS.has(normalized);
}

export const CATEGORY_COLORS: Record<string, { bg: string; text: string; icon: string }> = {
  industrial: { bg: 'bg-blue-50', text: 'text-blue-600', icon: '🏭' },
  retail: { bg: 'bg-green-50', text: 'text-green-600', icon: '🛒' },
  electronics: { bg: 'bg-cyan-50', text: 'text-cyan-600', icon: '⚡' },
  office: { bg: 'bg-purple-50', text: 'text-purple-600', icon: '📎' },
  food: { bg: 'bg-orange-50', text: 'text-orange-600', icon: '🍽️' },
  unknown: { bg: 'bg-gray-50', text: 'text-gray-600', icon: '📦' },
};

export const MILESTONES = {
  firstItem: 1,
  tenItems: 10,
  fiftyItems: 50,
  hundredItems: 100,
  firstOrder: 1,
  tenOrders: 10,
} as const;

export interface SupplierGridItem {
  supplier: DiscoveredSupplier;
  colors: { bg: string; text: string; icon: string };
  isEnabled: boolean;
}

export function buildSupplierGridItems(
  suppliers: DiscoveredSupplier[],
  enabledSuppliers: Set<string>,
): SupplierGridItem[] {
  return suppliers.map(supplier => {
    const colors = CATEGORY_COLORS[supplier.category] || CATEGORY_COLORS.unknown;
    return {
      supplier,
      colors,
      isEnabled: enabledSuppliers.has(supplier.domain),
    };
  });
}

export function getMilestoneMessage(milestone: keyof typeof MILESTONES | string) {
  switch (milestone) {
    case 'firstItem':
      return { title: 'First Item Found!', subtitle: 'Your inventory is coming to life', emoji: '🎉' };
    case 'tenItems':
      return { title: '10 Items Discovered!', subtitle: 'Arda is learning your supply chain', emoji: '🚀' };
    case 'fiftyItems':
      return { title: '50 Items!', subtitle: 'Your replenishment patterns are emerging', emoji: '⚡' };
    case 'hundredItems':
      return { title: '100 Items!', subtitle: "You're building a powerful inventory system", emoji: '💪' };
    default:
      return { title: 'Milestone!', subtitle: '', emoji: '🎯' };
  }
}

export function calculateProgressPercent(progress?: JobProgress | null): number {
  if (!progress || progress.total <= 0) {
    return 0;
  }
  const percent = (progress.processed / Math.max(progress.total, 1)) * 100;
  if (!Number.isFinite(percent)) {
    return 0;
  }
  return Math.min(100, Math.max(0, percent));
}

interface PrioritySummaryParams {
  error: string | null;
  isComplete: boolean;
  processedEmails: number;
  totalEmails: number;
  orderCount: number;
  itemCount: number;
}

export function getPrioritySummaryText({
  error,
  isComplete,
  processedEmails,
  totalEmails,
  orderCount,
  itemCount,
}: PrioritySummaryParams): string {
  if (error) {
    return error;
  }
  if (!isComplete) {
    return `Analyzing ${processedEmails}/${totalEmails} emails • found ${itemCount} items across ${orderCount} orders`;
  }
  if (itemCount === 0) {
    return `Analyzed ${processedEmails}/${totalEmails} emails, no line items extracted.`;
  }
  return `${itemCount} items from ${orderCount} orders`;
}

```

### `tailwind.config.js`

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      fontFamily: {
        sans: ['Geist', 'Inter', 'system-ui', 'sans-serif'],
        mono: ['JetBrains Mono', 'monospace'],
      },
      colors: {
        // Arda-inspired color palette
        arda: {
          // Orange accent - primary brand color
          accent: '#FC5A29',
          'accent-hover': '#E54D1F',
          
          // Light backgrounds
          bg: '#FFFFFF',
          'bg-secondary': '#F9FAFB',
          'bg-tertiary': '#F3F4F6',
          
          // Borders
          border: '#E5E7EB',
          'border-hover': '#D1D5DB',
          
          // Text colors
          'text-primary': '#111827',
          'text-secondary': '#4B5563',
          'text-muted': '#9CA3AF',
          
          // Status colors
          success: '#22C55E',
          warning: '#F59E0B',
          danger: '#EF4444',
          info: '#3B82F6',
          
          // Legacy dark theme (for gradual migration)
          900: '#0f1117',
          800: '#161b22',
          700: '#21262d',
          600: '#30363d',
          500: '#8b949e',
        }
      },
      borderRadius: {
        'arda': '8px',
        'arda-lg': '12px',
      },
      boxShadow: {
        'arda': '0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06)',
        'arda-lg': '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
        'arda-hover': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
      }
    }
  },
  plugins: [],
}

```

### `tsconfig.app.json`

```json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": false,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "erasableSyntaxOnly": false,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

```

### `tsconfig.json`

```json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

```

### `tsconfig.node.json`

```json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

```

### `vercel.json`

```json
{
  "version": 2,
  "builds": [
    { "src": "package.json", "use": "@vercel/static-build", "config": { "distDir": "dist" } }
  ],
  "buildCommand": "npm run build",
  "installCommand": "npm ci",
  "outputDirectory": "dist",
  "framework": "vite",
  "rewrites": [
    { "source": "/auth/:path*", "destination": "https://order-pulse-api-production.up.railway.app/auth/:path*" },
    { "source": "/api/:path*", "destination": "https://order-pulse-api-production.up.railway.app/api/:path*" },
    { "source": "/health", "destination": "https://order-pulse-api-production.up.railway.app/health" },
    { "source": "/scan/:sessionId", "destination": "/index.html" },
    { "source": "/photo/:sessionId", "destination": "/index.html" },
    { "source": "/((?!assets/).*)", "destination": "/index.html" }
  ]
}

```

### `vite.config.ts`

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  build: {
    chunkSizeWarningLimit: 1500,
    rollupOptions: {
      output: {
        manualChunks(id) {
          if (id.includes('node_modules/@google/genai')) {
            return 'genai';
          }
          if (id.includes('node_modules/recharts')) {
            return 'recharts';
          }
          if (id.includes('node_modules/react-dom') || id.includes('node_modules/react')) {
            return 'react-vendor';
          }
          if (id.includes('node_modules/lucide-react')) {
            return 'icons';
          }
        },
      },
    },
  },
});

```

### `vitest.config.ts`

```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './src/setupTests.ts',
    include: [
      'src/**/*.test.{ts,tsx}',
      'src/__tests__/**/*.test.{ts,tsx}',
    ],
    coverage: {
      reporter: ['text', 'lcov'],
    },
  },
});

```

---

## Notes for Recreation

1. **Node.js version**: Exactly 20.20.0 (enforced via `.node-version`, `.nvmrc`, and `engine-strict=true` in `.npmrc`)
2. **Package manager**: npm (not yarn/pnpm). Run `npm ci` for deterministic installs.
3. **package-lock.json**: Not included in this document due to size (289,485 bytes). Generate via `npm install` after recreating `package.json`.
4. **Git hooks**: Run `npm run hooks:install` after cloning to configure custom `.githooks/` directory.
5. **AG Grid Enterprise**: Requires a license key for production. See `src/components/ItemsTable/gridSetup.ts`.
6. **Environment variables**: See `.env.example` and `server/.env.example` for all required configuration.
7. **Database**: Run `npm run db:migrate` in the `server/` directory to create the schema.
8. **Binary assets**: `public/vite.svg` and `src/assets/react.svg` are standard Vite/React logos.
9. **Railway deployment**: Uses project ID `f7c96f7b-ed85-4ae9-9428-de3888942936` and service name `order-pulse-api`.
10. **Vercel rewrites**: API calls are proxied to `https://order-pulse-api-production.up.railway.app`.
